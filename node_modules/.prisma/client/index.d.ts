
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model AdministrativeOrder
 */

export type AdministrativeOrder = {
  idAdministrative: number
  orderTitleId: number
  orderNumber: number
  orderDescription: string
  orderYear: string
  orderLevel: number
  studentId: number
  orderDate: Date
  createdBy: number
  createdAt: Date
}

/**
 * Model OrderTitle
 */

export type OrderTitle = {
  idOrderTitle: number
  title: string
  createdAt: Date
  createdBy: number
}

/**
 * Model ExitCauses
 */

export type ExitCauses = {
  idExitCauses: number
  exitCausesTitle: string
  createdAt: Date
  createdBy: number
}

/**
 * Model PassType
 */

export type PassType = {
  idPassType: number
  passName: string
  createdAt: Date
  createdBy: number
}

/**
 * Model User
 */

export type User = {
  idUser: number
  userName: string
  password: string
  roleId: number
  sectionId: number
  createdAt: Date
}

/**
 * Model Role
 */

export type Role = {
  idRole: number
  roleName: string
  createdAt: Date
}

/**
 * Model Section
 */

export type Section = {
  idSection: number
  sectionName: string
  code: string
  englishName: string
}

/**
 * Model Student
 */

export type Student = {
  idStudent: number
  studentName: string
  englishName: string
  mail: string
  password: string
  dob: string
  sectionId: number
  nationality: string
  phone: string
  gender: boolean
  studyType: boolean
  relationships: boolean
  note: string
  religion: string
  motherName: string
  collegeNumber: string
  registerYearId: number
  studentStatusId: number
  acceptedTypeId: number
}

/**
 * Model YearStudy
 */

export type YearStudy = {
  idYearStudy: number
  year: string
  currentYear: boolean
}

/**
 * Model StudentResponsible
 */

export type StudentResponsible = {
  idStudentResponsible: number
  responsibleName: string
  responsiblePhone: string
  studentId: number
}

/**
 * Model NationalityCertificate
 */

export type NationalityCertificate = {
  idNationalityCertificate: number
  nationalityNumber: string
  nationalityIssue: string
  nationalityPlace: string
  studentId: number
}

/**
 * Model NationalInfo
 */

export type NationalInfo = {
  idNationalInfo: number
  nationalNumber: string
  issueNumber: string
  issuePlace: string
  studentId: number
}

/**
 * Model StudentGraduation
 */

export type StudentGraduation = {
  idStudentGraduation: number
  graduationDate: string
  studentId: number
}

/**
 * Model StudentLevel
 */

export type StudentLevel = {
  idStudentLevel: number
  level: number
  class: string
  yearStudyId: number
  studentId: number
}

/**
 * Model StudentSchool
 */

export type StudentSchool = {
  idStudentSchool: number
  schoolName: string
  graduationDate: string
  documentDate: string
  totalMarks: number
  average: number
  documentNumber: number
  lessonCount: number
  Directorate: string
  studySubCategoryId: number
  studentId: number
  certificateStatusId: number
  certificateStatusDescription: string
  createdAt: Date
}

/**
 * Model StudyCategory
 */

export type StudyCategory = {
  idStudyCategory: number
  categoryName: string
}

/**
 * Model StudySubCategory
 */

export type StudySubCategory = {
  idStudySubCategory: number
  subCategoryName: string
  studyCategoryId: number
}

/**
 * Model CertificateStatus
 */

export type CertificateStatus = {
  idCertificateStatus: number
  certificateStatusName: string
}

/**
 * Model StudentStatus
 */

export type StudentStatus = {
  idStudentStatus: number
  statusName: string
}

/**
 * Model AcceptedType
 */

export type AcceptedType = {
  idAcceptedType: number
  acceptedName: string
}

/**
 * Model StudentImage
 */

export type StudentImage = {
  idStudentImage: number
  imagePath: string
  studentId: number
}

/**
 * Model Province
 */

export type Province = {
  idProvince: number
  provinceName: string
  provinceNameEn: string
}

/**
 * Model Address
 */

export type Address = {
  idAddress: number
  provinceId: number
  district: string
  avenue: string
  houseNumber: string
  streetNumber: string
  studentId: number
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more AdministrativeOrders
 * const administrativeOrders = await prisma.administrativeOrder.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more AdministrativeOrders
   * const administrativeOrders = await prisma.administrativeOrder.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;


      /**
   * `prisma.administrativeOrder`: Exposes CRUD operations for the **AdministrativeOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdministrativeOrders
    * const administrativeOrders = await prisma.administrativeOrder.findMany()
    * ```
    */
  get administrativeOrder(): Prisma.AdministrativeOrderDelegate<GlobalReject>;

  /**
   * `prisma.orderTitle`: Exposes CRUD operations for the **OrderTitle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderTitles
    * const orderTitles = await prisma.orderTitle.findMany()
    * ```
    */
  get orderTitle(): Prisma.OrderTitleDelegate<GlobalReject>;

  /**
   * `prisma.exitCauses`: Exposes CRUD operations for the **ExitCauses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExitCauses
    * const exitCauses = await prisma.exitCauses.findMany()
    * ```
    */
  get exitCauses(): Prisma.ExitCausesDelegate<GlobalReject>;

  /**
   * `prisma.passType`: Exposes CRUD operations for the **PassType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PassTypes
    * const passTypes = await prisma.passType.findMany()
    * ```
    */
  get passType(): Prisma.PassTypeDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<GlobalReject>;

  /**
   * `prisma.section`: Exposes CRUD operations for the **Section** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sections
    * const sections = await prisma.section.findMany()
    * ```
    */
  get section(): Prisma.SectionDelegate<GlobalReject>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<GlobalReject>;

  /**
   * `prisma.yearStudy`: Exposes CRUD operations for the **YearStudy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YearStudies
    * const yearStudies = await prisma.yearStudy.findMany()
    * ```
    */
  get yearStudy(): Prisma.YearStudyDelegate<GlobalReject>;

  /**
   * `prisma.studentResponsible`: Exposes CRUD operations for the **StudentResponsible** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentResponsibles
    * const studentResponsibles = await prisma.studentResponsible.findMany()
    * ```
    */
  get studentResponsible(): Prisma.StudentResponsibleDelegate<GlobalReject>;

  /**
   * `prisma.nationalityCertificate`: Exposes CRUD operations for the **NationalityCertificate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NationalityCertificates
    * const nationalityCertificates = await prisma.nationalityCertificate.findMany()
    * ```
    */
  get nationalityCertificate(): Prisma.NationalityCertificateDelegate<GlobalReject>;

  /**
   * `prisma.nationalInfo`: Exposes CRUD operations for the **NationalInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NationalInfos
    * const nationalInfos = await prisma.nationalInfo.findMany()
    * ```
    */
  get nationalInfo(): Prisma.NationalInfoDelegate<GlobalReject>;

  /**
   * `prisma.studentGraduation`: Exposes CRUD operations for the **StudentGraduation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentGraduations
    * const studentGraduations = await prisma.studentGraduation.findMany()
    * ```
    */
  get studentGraduation(): Prisma.StudentGraduationDelegate<GlobalReject>;

  /**
   * `prisma.studentLevel`: Exposes CRUD operations for the **StudentLevel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentLevels
    * const studentLevels = await prisma.studentLevel.findMany()
    * ```
    */
  get studentLevel(): Prisma.StudentLevelDelegate<GlobalReject>;

  /**
   * `prisma.studentSchool`: Exposes CRUD operations for the **StudentSchool** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentSchools
    * const studentSchools = await prisma.studentSchool.findMany()
    * ```
    */
  get studentSchool(): Prisma.StudentSchoolDelegate<GlobalReject>;

  /**
   * `prisma.studyCategory`: Exposes CRUD operations for the **StudyCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudyCategories
    * const studyCategories = await prisma.studyCategory.findMany()
    * ```
    */
  get studyCategory(): Prisma.StudyCategoryDelegate<GlobalReject>;

  /**
   * `prisma.studySubCategory`: Exposes CRUD operations for the **StudySubCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudySubCategories
    * const studySubCategories = await prisma.studySubCategory.findMany()
    * ```
    */
  get studySubCategory(): Prisma.StudySubCategoryDelegate<GlobalReject>;

  /**
   * `prisma.certificateStatus`: Exposes CRUD operations for the **CertificateStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CertificateStatuses
    * const certificateStatuses = await prisma.certificateStatus.findMany()
    * ```
    */
  get certificateStatus(): Prisma.CertificateStatusDelegate<GlobalReject>;

  /**
   * `prisma.studentStatus`: Exposes CRUD operations for the **StudentStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentStatuses
    * const studentStatuses = await prisma.studentStatus.findMany()
    * ```
    */
  get studentStatus(): Prisma.StudentStatusDelegate<GlobalReject>;

  /**
   * `prisma.acceptedType`: Exposes CRUD operations for the **AcceptedType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcceptedTypes
    * const acceptedTypes = await prisma.acceptedType.findMany()
    * ```
    */
  get acceptedType(): Prisma.AcceptedTypeDelegate<GlobalReject>;

  /**
   * `prisma.studentImage`: Exposes CRUD operations for the **StudentImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentImages
    * const studentImages = await prisma.studentImage.findMany()
    * ```
    */
  get studentImage(): Prisma.StudentImageDelegate<GlobalReject>;

  /**
   * `prisma.province`: Exposes CRUD operations for the **Province** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Provinces
    * const provinces = await prisma.province.findMany()
    * ```
    */
  get province(): Prisma.ProvinceDelegate<GlobalReject>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 3.1.1
   * Query Engine version: c22652b7e418506fab23052d569b85d3aec4883f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    AdministrativeOrder: 'AdministrativeOrder',
    OrderTitle: 'OrderTitle',
    ExitCauses: 'ExitCauses',
    PassType: 'PassType',
    User: 'User',
    Role: 'Role',
    Section: 'Section',
    Student: 'Student',
    YearStudy: 'YearStudy',
    StudentResponsible: 'StudentResponsible',
    NationalityCertificate: 'NationalityCertificate',
    NationalInfo: 'NationalInfo',
    StudentGraduation: 'StudentGraduation',
    StudentLevel: 'StudentLevel',
    StudentSchool: 'StudentSchool',
    StudyCategory: 'StudyCategory',
    StudySubCategory: 'StudySubCategory',
    CertificateStatus: 'CertificateStatus',
    StudentStatus: 'StudentStatus',
    AcceptedType: 'AcceptedType',
    StudentImage: 'StudentImage',
    Province: 'Province',
    Address: 'Address'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type OrderTitleCountOutputType
   */


  export type OrderTitleCountOutputType = {
    administrativeOrders: number
  }

  export type OrderTitleCountOutputTypeSelect = {
    administrativeOrders?: boolean
  }

  export type OrderTitleCountOutputTypeGetPayload<
    S extends boolean | null | undefined | OrderTitleCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? OrderTitleCountOutputType
    : S extends undefined
    ? never
    : S extends OrderTitleCountOutputTypeArgs
    ?'include' extends U
    ? OrderTitleCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof OrderTitleCountOutputType ?OrderTitleCountOutputType [P]
  : 
     never
  } 
    : OrderTitleCountOutputType
  : OrderTitleCountOutputType




  // Custom InputTypes

  /**
   * OrderTitleCountOutputType without action
   */
  export type OrderTitleCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OrderTitleCountOutputType
     * 
    **/
    select?: OrderTitleCountOutputTypeSelect | null
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    passTypes: number
    administrativeOrders: number
    OrderTitles: number
    ExitCauses: number
  }

  export type UserCountOutputTypeSelect = {
    passTypes?: boolean
    administrativeOrders?: boolean
    OrderTitles?: boolean
    ExitCauses?: boolean
  }

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ?'include' extends U
    ? UserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserCountOutputType ?UserCountOutputType [P]
  : 
     never
  } 
    : UserCountOutputType
  : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type RoleCountOutputType
   */


  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect = {
    users?: boolean
  }

  export type RoleCountOutputTypeGetPayload<
    S extends boolean | null | undefined | RoleCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? RoleCountOutputType
    : S extends undefined
    ? never
    : S extends RoleCountOutputTypeArgs
    ?'include' extends U
    ? RoleCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof RoleCountOutputType ?RoleCountOutputType [P]
  : 
     never
  } 
    : RoleCountOutputType
  : RoleCountOutputType




  // Custom InputTypes

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     * 
    **/
    select?: RoleCountOutputTypeSelect | null
  }



  /**
   * Count Type SectionCountOutputType
   */


  export type SectionCountOutputType = {
    students: number
    User: number
  }

  export type SectionCountOutputTypeSelect = {
    students?: boolean
    User?: boolean
  }

  export type SectionCountOutputTypeGetPayload<
    S extends boolean | null | undefined | SectionCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? SectionCountOutputType
    : S extends undefined
    ? never
    : S extends SectionCountOutputTypeArgs
    ?'include' extends U
    ? SectionCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof SectionCountOutputType ?SectionCountOutputType [P]
  : 
     never
  } 
    : SectionCountOutputType
  : SectionCountOutputType




  // Custom InputTypes

  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SectionCountOutputType
     * 
    **/
    select?: SectionCountOutputTypeSelect | null
  }



  /**
   * Count Type StudentCountOutputType
   */


  export type StudentCountOutputType = {
    administrativeOrders: number
    studentLevel: number
    studentResponsables: number
    nationalityCertificate: number
    studentImage: number
  }

  export type StudentCountOutputTypeSelect = {
    administrativeOrders?: boolean
    studentLevel?: boolean
    studentResponsables?: boolean
    nationalityCertificate?: boolean
    studentImage?: boolean
  }

  export type StudentCountOutputTypeGetPayload<
    S extends boolean | null | undefined | StudentCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? StudentCountOutputType
    : S extends undefined
    ? never
    : S extends StudentCountOutputTypeArgs
    ?'include' extends U
    ? StudentCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof StudentCountOutputType ?StudentCountOutputType [P]
  : 
     never
  } 
    : StudentCountOutputType
  : StudentCountOutputType




  // Custom InputTypes

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     * 
    **/
    select?: StudentCountOutputTypeSelect | null
  }



  /**
   * Count Type YearStudyCountOutputType
   */


  export type YearStudyCountOutputType = {
    StudentLevel: number
    Student: number
  }

  export type YearStudyCountOutputTypeSelect = {
    StudentLevel?: boolean
    Student?: boolean
  }

  export type YearStudyCountOutputTypeGetPayload<
    S extends boolean | null | undefined | YearStudyCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? YearStudyCountOutputType
    : S extends undefined
    ? never
    : S extends YearStudyCountOutputTypeArgs
    ?'include' extends U
    ? YearStudyCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof YearStudyCountOutputType ?YearStudyCountOutputType [P]
  : 
     never
  } 
    : YearStudyCountOutputType
  : YearStudyCountOutputType




  // Custom InputTypes

  /**
   * YearStudyCountOutputType without action
   */
  export type YearStudyCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the YearStudyCountOutputType
     * 
    **/
    select?: YearStudyCountOutputTypeSelect | null
  }



  /**
   * Count Type StudyCategoryCountOutputType
   */


  export type StudyCategoryCountOutputType = {
    StudySubCategory: number
  }

  export type StudyCategoryCountOutputTypeSelect = {
    StudySubCategory?: boolean
  }

  export type StudyCategoryCountOutputTypeGetPayload<
    S extends boolean | null | undefined | StudyCategoryCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? StudyCategoryCountOutputType
    : S extends undefined
    ? never
    : S extends StudyCategoryCountOutputTypeArgs
    ?'include' extends U
    ? StudyCategoryCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof StudyCategoryCountOutputType ?StudyCategoryCountOutputType [P]
  : 
     never
  } 
    : StudyCategoryCountOutputType
  : StudyCategoryCountOutputType




  // Custom InputTypes

  /**
   * StudyCategoryCountOutputType without action
   */
  export type StudyCategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the StudyCategoryCountOutputType
     * 
    **/
    select?: StudyCategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type StudySubCategoryCountOutputType
   */


  export type StudySubCategoryCountOutputType = {
    StudentSchool: number
  }

  export type StudySubCategoryCountOutputTypeSelect = {
    StudentSchool?: boolean
  }

  export type StudySubCategoryCountOutputTypeGetPayload<
    S extends boolean | null | undefined | StudySubCategoryCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? StudySubCategoryCountOutputType
    : S extends undefined
    ? never
    : S extends StudySubCategoryCountOutputTypeArgs
    ?'include' extends U
    ? StudySubCategoryCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof StudySubCategoryCountOutputType ?StudySubCategoryCountOutputType [P]
  : 
     never
  } 
    : StudySubCategoryCountOutputType
  : StudySubCategoryCountOutputType




  // Custom InputTypes

  /**
   * StudySubCategoryCountOutputType without action
   */
  export type StudySubCategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the StudySubCategoryCountOutputType
     * 
    **/
    select?: StudySubCategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type CertificateStatusCountOutputType
   */


  export type CertificateStatusCountOutputType = {
    studentSchool: number
  }

  export type CertificateStatusCountOutputTypeSelect = {
    studentSchool?: boolean
  }

  export type CertificateStatusCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CertificateStatusCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CertificateStatusCountOutputType
    : S extends undefined
    ? never
    : S extends CertificateStatusCountOutputTypeArgs
    ?'include' extends U
    ? CertificateStatusCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CertificateStatusCountOutputType ?CertificateStatusCountOutputType [P]
  : 
     never
  } 
    : CertificateStatusCountOutputType
  : CertificateStatusCountOutputType




  // Custom InputTypes

  /**
   * CertificateStatusCountOutputType without action
   */
  export type CertificateStatusCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CertificateStatusCountOutputType
     * 
    **/
    select?: CertificateStatusCountOutputTypeSelect | null
  }



  /**
   * Count Type StudentStatusCountOutputType
   */


  export type StudentStatusCountOutputType = {
    students: number
  }

  export type StudentStatusCountOutputTypeSelect = {
    students?: boolean
  }

  export type StudentStatusCountOutputTypeGetPayload<
    S extends boolean | null | undefined | StudentStatusCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? StudentStatusCountOutputType
    : S extends undefined
    ? never
    : S extends StudentStatusCountOutputTypeArgs
    ?'include' extends U
    ? StudentStatusCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof StudentStatusCountOutputType ?StudentStatusCountOutputType [P]
  : 
     never
  } 
    : StudentStatusCountOutputType
  : StudentStatusCountOutputType




  // Custom InputTypes

  /**
   * StudentStatusCountOutputType without action
   */
  export type StudentStatusCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the StudentStatusCountOutputType
     * 
    **/
    select?: StudentStatusCountOutputTypeSelect | null
  }



  /**
   * Count Type AcceptedTypeCountOutputType
   */


  export type AcceptedTypeCountOutputType = {
    students: number
  }

  export type AcceptedTypeCountOutputTypeSelect = {
    students?: boolean
  }

  export type AcceptedTypeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | AcceptedTypeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? AcceptedTypeCountOutputType
    : S extends undefined
    ? never
    : S extends AcceptedTypeCountOutputTypeArgs
    ?'include' extends U
    ? AcceptedTypeCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof AcceptedTypeCountOutputType ?AcceptedTypeCountOutputType [P]
  : 
     never
  } 
    : AcceptedTypeCountOutputType
  : AcceptedTypeCountOutputType




  // Custom InputTypes

  /**
   * AcceptedTypeCountOutputType without action
   */
  export type AcceptedTypeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AcceptedTypeCountOutputType
     * 
    **/
    select?: AcceptedTypeCountOutputTypeSelect | null
  }



  /**
   * Count Type ProvinceCountOutputType
   */


  export type ProvinceCountOutputType = {
    addresses: number
  }

  export type ProvinceCountOutputTypeSelect = {
    addresses?: boolean
  }

  export type ProvinceCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProvinceCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProvinceCountOutputType
    : S extends undefined
    ? never
    : S extends ProvinceCountOutputTypeArgs
    ?'include' extends U
    ? ProvinceCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProvinceCountOutputType ?ProvinceCountOutputType [P]
  : 
     never
  } 
    : ProvinceCountOutputType
  : ProvinceCountOutputType




  // Custom InputTypes

  /**
   * ProvinceCountOutputType without action
   */
  export type ProvinceCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProvinceCountOutputType
     * 
    **/
    select?: ProvinceCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model AdministrativeOrder
   */


  export type AggregateAdministrativeOrder = {
    _count: AdministrativeOrderCountAggregateOutputType | null
    _avg: AdministrativeOrderAvgAggregateOutputType | null
    _sum: AdministrativeOrderSumAggregateOutputType | null
    _min: AdministrativeOrderMinAggregateOutputType | null
    _max: AdministrativeOrderMaxAggregateOutputType | null
  }

  export type AdministrativeOrderAvgAggregateOutputType = {
    idAdministrative: number | null
    orderTitleId: number | null
    orderNumber: number | null
    orderLevel: number | null
    studentId: number | null
    createdBy: number | null
  }

  export type AdministrativeOrderSumAggregateOutputType = {
    idAdministrative: number | null
    orderTitleId: number | null
    orderNumber: number | null
    orderLevel: number | null
    studentId: number | null
    createdBy: number | null
  }

  export type AdministrativeOrderMinAggregateOutputType = {
    idAdministrative: number | null
    orderTitleId: number | null
    orderNumber: number | null
    orderDescription: string | null
    orderYear: string | null
    orderLevel: number | null
    studentId: number | null
    orderDate: Date | null
    createdBy: number | null
    createdAt: Date | null
  }

  export type AdministrativeOrderMaxAggregateOutputType = {
    idAdministrative: number | null
    orderTitleId: number | null
    orderNumber: number | null
    orderDescription: string | null
    orderYear: string | null
    orderLevel: number | null
    studentId: number | null
    orderDate: Date | null
    createdBy: number | null
    createdAt: Date | null
  }

  export type AdministrativeOrderCountAggregateOutputType = {
    idAdministrative: number
    orderTitleId: number
    orderNumber: number
    orderDescription: number
    orderYear: number
    orderLevel: number
    studentId: number
    orderDate: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type AdministrativeOrderAvgAggregateInputType = {
    idAdministrative?: true
    orderTitleId?: true
    orderNumber?: true
    orderLevel?: true
    studentId?: true
    createdBy?: true
  }

  export type AdministrativeOrderSumAggregateInputType = {
    idAdministrative?: true
    orderTitleId?: true
    orderNumber?: true
    orderLevel?: true
    studentId?: true
    createdBy?: true
  }

  export type AdministrativeOrderMinAggregateInputType = {
    idAdministrative?: true
    orderTitleId?: true
    orderNumber?: true
    orderDescription?: true
    orderYear?: true
    orderLevel?: true
    studentId?: true
    orderDate?: true
    createdBy?: true
    createdAt?: true
  }

  export type AdministrativeOrderMaxAggregateInputType = {
    idAdministrative?: true
    orderTitleId?: true
    orderNumber?: true
    orderDescription?: true
    orderYear?: true
    orderLevel?: true
    studentId?: true
    orderDate?: true
    createdBy?: true
    createdAt?: true
  }

  export type AdministrativeOrderCountAggregateInputType = {
    idAdministrative?: true
    orderTitleId?: true
    orderNumber?: true
    orderDescription?: true
    orderYear?: true
    orderLevel?: true
    studentId?: true
    orderDate?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type AdministrativeOrderAggregateArgs = {
    /**
     * Filter which AdministrativeOrder to aggregate.
     * 
    **/
    where?: AdministrativeOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdministrativeOrders to fetch.
     * 
    **/
    orderBy?: Enumerable<AdministrativeOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AdministrativeOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdministrativeOrders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdministrativeOrders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdministrativeOrders
    **/
    _count?: true | AdministrativeOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdministrativeOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdministrativeOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdministrativeOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdministrativeOrderMaxAggregateInputType
  }

  export type GetAdministrativeOrderAggregateType<T extends AdministrativeOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateAdministrativeOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdministrativeOrder[P]>
      : GetScalarType<T[P], AggregateAdministrativeOrder[P]>
  }


    
    
  export type AdministrativeOrderGroupByArgs = {
    where?: AdministrativeOrderWhereInput
    orderBy?: Enumerable<AdministrativeOrderOrderByWithAggregationInput>
    by: Array<AdministrativeOrderScalarFieldEnum>
    having?: AdministrativeOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdministrativeOrderCountAggregateInputType | true
    _avg?: AdministrativeOrderAvgAggregateInputType
    _sum?: AdministrativeOrderSumAggregateInputType
    _min?: AdministrativeOrderMinAggregateInputType
    _max?: AdministrativeOrderMaxAggregateInputType
  }


  export type AdministrativeOrderGroupByOutputType = {
    idAdministrative: number
    orderTitleId: number
    orderNumber: number
    orderDescription: string
    orderYear: string
    orderLevel: number
    studentId: number
    orderDate: Date
    createdBy: number
    createdAt: Date
    _count: AdministrativeOrderCountAggregateOutputType | null
    _avg: AdministrativeOrderAvgAggregateOutputType | null
    _sum: AdministrativeOrderSumAggregateOutputType | null
    _min: AdministrativeOrderMinAggregateOutputType | null
    _max: AdministrativeOrderMaxAggregateOutputType | null
  }

  type GetAdministrativeOrderGroupByPayload<T extends AdministrativeOrderGroupByArgs> = Promise<
    Array<
      PickArray<AdministrativeOrderGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof AdministrativeOrderGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], AdministrativeOrderGroupByOutputType[P]> 
            : GetScalarType<T[P], AdministrativeOrderGroupByOutputType[P]>
        }
      > 
    >


  export type AdministrativeOrderSelect = {
    idAdministrative?: boolean
    orderTitle?: boolean | OrderTitleArgs
    orderTitleId?: boolean
    orderNumber?: boolean
    orderDescription?: boolean
    orderYear?: boolean
    orderLevel?: boolean
    student?: boolean | StudentArgs
    studentId?: boolean
    orderDate?: boolean
    user?: boolean | UserArgs
    createdBy?: boolean
    createdAt?: boolean
  }

  export type AdministrativeOrderInclude = {
    orderTitle?: boolean | OrderTitleArgs
    student?: boolean | StudentArgs
    user?: boolean | UserArgs
  }

  export type AdministrativeOrderGetPayload<
    S extends boolean | null | undefined | AdministrativeOrderArgs,
    U = keyof S
      > = S extends true
        ? AdministrativeOrder
    : S extends undefined
    ? never
    : S extends AdministrativeOrderArgs | AdministrativeOrderFindManyArgs
    ?'include' extends U
    ? AdministrativeOrder  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'orderTitle'
        ? OrderTitleGetPayload<S['include'][P]> :
        P extends 'student'
        ? StudentGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof AdministrativeOrder ?AdministrativeOrder [P]
  : 
          P extends 'orderTitle'
        ? OrderTitleGetPayload<S['select'][P]> :
        P extends 'student'
        ? StudentGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : AdministrativeOrder
  : AdministrativeOrder


  type AdministrativeOrderCountArgs = Merge<
    Omit<AdministrativeOrderFindManyArgs, 'select' | 'include'> & {
      select?: AdministrativeOrderCountAggregateInputType | true
    }
  >

  export interface AdministrativeOrderDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one AdministrativeOrder that matches the filter.
     * @param {AdministrativeOrderFindUniqueArgs} args - Arguments to find a AdministrativeOrder
     * @example
     * // Get one AdministrativeOrder
     * const administrativeOrder = await prisma.administrativeOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdministrativeOrderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AdministrativeOrderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AdministrativeOrder'> extends True ? CheckSelect<T, Prisma__AdministrativeOrderClient<AdministrativeOrder>, Prisma__AdministrativeOrderClient<AdministrativeOrderGetPayload<T>>> : CheckSelect<T, Prisma__AdministrativeOrderClient<AdministrativeOrder | null >, Prisma__AdministrativeOrderClient<AdministrativeOrderGetPayload<T> | null >>

    /**
     * Find the first AdministrativeOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministrativeOrderFindFirstArgs} args - Arguments to find a AdministrativeOrder
     * @example
     * // Get one AdministrativeOrder
     * const administrativeOrder = await prisma.administrativeOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdministrativeOrderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AdministrativeOrderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AdministrativeOrder'> extends True ? CheckSelect<T, Prisma__AdministrativeOrderClient<AdministrativeOrder>, Prisma__AdministrativeOrderClient<AdministrativeOrderGetPayload<T>>> : CheckSelect<T, Prisma__AdministrativeOrderClient<AdministrativeOrder | null >, Prisma__AdministrativeOrderClient<AdministrativeOrderGetPayload<T> | null >>

    /**
     * Find zero or more AdministrativeOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministrativeOrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdministrativeOrders
     * const administrativeOrders = await prisma.administrativeOrder.findMany()
     * 
     * // Get first 10 AdministrativeOrders
     * const administrativeOrders = await prisma.administrativeOrder.findMany({ take: 10 })
     * 
     * // Only select the `idAdministrative`
     * const administrativeOrderWithIdAdministrativeOnly = await prisma.administrativeOrder.findMany({ select: { idAdministrative: true } })
     * 
    **/
    findMany<T extends AdministrativeOrderFindManyArgs>(
      args?: SelectSubset<T, AdministrativeOrderFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AdministrativeOrder>>, PrismaPromise<Array<AdministrativeOrderGetPayload<T>>>>

    /**
     * Create a AdministrativeOrder.
     * @param {AdministrativeOrderCreateArgs} args - Arguments to create a AdministrativeOrder.
     * @example
     * // Create one AdministrativeOrder
     * const AdministrativeOrder = await prisma.administrativeOrder.create({
     *   data: {
     *     // ... data to create a AdministrativeOrder
     *   }
     * })
     * 
    **/
    create<T extends AdministrativeOrderCreateArgs>(
      args: SelectSubset<T, AdministrativeOrderCreateArgs>
    ): CheckSelect<T, Prisma__AdministrativeOrderClient<AdministrativeOrder>, Prisma__AdministrativeOrderClient<AdministrativeOrderGetPayload<T>>>

    /**
     * Create many AdministrativeOrders.
     *     @param {AdministrativeOrderCreateManyArgs} args - Arguments to create many AdministrativeOrders.
     *     @example
     *     // Create many AdministrativeOrders
     *     const administrativeOrder = await prisma.administrativeOrder.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdministrativeOrderCreateManyArgs>(
      args?: SelectSubset<T, AdministrativeOrderCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AdministrativeOrder.
     * @param {AdministrativeOrderDeleteArgs} args - Arguments to delete one AdministrativeOrder.
     * @example
     * // Delete one AdministrativeOrder
     * const AdministrativeOrder = await prisma.administrativeOrder.delete({
     *   where: {
     *     // ... filter to delete one AdministrativeOrder
     *   }
     * })
     * 
    **/
    delete<T extends AdministrativeOrderDeleteArgs>(
      args: SelectSubset<T, AdministrativeOrderDeleteArgs>
    ): CheckSelect<T, Prisma__AdministrativeOrderClient<AdministrativeOrder>, Prisma__AdministrativeOrderClient<AdministrativeOrderGetPayload<T>>>

    /**
     * Update one AdministrativeOrder.
     * @param {AdministrativeOrderUpdateArgs} args - Arguments to update one AdministrativeOrder.
     * @example
     * // Update one AdministrativeOrder
     * const administrativeOrder = await prisma.administrativeOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdministrativeOrderUpdateArgs>(
      args: SelectSubset<T, AdministrativeOrderUpdateArgs>
    ): CheckSelect<T, Prisma__AdministrativeOrderClient<AdministrativeOrder>, Prisma__AdministrativeOrderClient<AdministrativeOrderGetPayload<T>>>

    /**
     * Delete zero or more AdministrativeOrders.
     * @param {AdministrativeOrderDeleteManyArgs} args - Arguments to filter AdministrativeOrders to delete.
     * @example
     * // Delete a few AdministrativeOrders
     * const { count } = await prisma.administrativeOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdministrativeOrderDeleteManyArgs>(
      args?: SelectSubset<T, AdministrativeOrderDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdministrativeOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministrativeOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdministrativeOrders
     * const administrativeOrder = await prisma.administrativeOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdministrativeOrderUpdateManyArgs>(
      args: SelectSubset<T, AdministrativeOrderUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AdministrativeOrder.
     * @param {AdministrativeOrderUpsertArgs} args - Arguments to update or create a AdministrativeOrder.
     * @example
     * // Update or create a AdministrativeOrder
     * const administrativeOrder = await prisma.administrativeOrder.upsert({
     *   create: {
     *     // ... data to create a AdministrativeOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdministrativeOrder we want to update
     *   }
     * })
    **/
    upsert<T extends AdministrativeOrderUpsertArgs>(
      args: SelectSubset<T, AdministrativeOrderUpsertArgs>
    ): CheckSelect<T, Prisma__AdministrativeOrderClient<AdministrativeOrder>, Prisma__AdministrativeOrderClient<AdministrativeOrderGetPayload<T>>>

    /**
     * Count the number of AdministrativeOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministrativeOrderCountArgs} args - Arguments to filter AdministrativeOrders to count.
     * @example
     * // Count the number of AdministrativeOrders
     * const count = await prisma.administrativeOrder.count({
     *   where: {
     *     // ... the filter for the AdministrativeOrders we want to count
     *   }
     * })
    **/
    count<T extends AdministrativeOrderCountArgs>(
      args?: Subset<T, AdministrativeOrderCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdministrativeOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdministrativeOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministrativeOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdministrativeOrderAggregateArgs>(args: Subset<T, AdministrativeOrderAggregateArgs>): PrismaPromise<GetAdministrativeOrderAggregateType<T>>

    /**
     * Group by AdministrativeOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministrativeOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdministrativeOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdministrativeOrderGroupByArgs['orderBy'] }
        : { orderBy?: AdministrativeOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdministrativeOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdministrativeOrderGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdministrativeOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AdministrativeOrderClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    orderTitle<T extends OrderTitleArgs = {}>(args?: Subset<T, OrderTitleArgs>): CheckSelect<T, Prisma__OrderTitleClient<OrderTitle | null >, Prisma__OrderTitleClient<OrderTitleGetPayload<T> | null >>;

    student<T extends StudentArgs = {}>(args?: Subset<T, StudentArgs>): CheckSelect<T, Prisma__StudentClient<Student | null >, Prisma__StudentClient<StudentGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * AdministrativeOrder findUnique
   */
  export type AdministrativeOrderFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the AdministrativeOrder
     * 
    **/
    select?: AdministrativeOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdministrativeOrderInclude | null
    /**
     * Throw an Error if a AdministrativeOrder can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AdministrativeOrder to fetch.
     * 
    **/
    where: AdministrativeOrderWhereUniqueInput
  }


  /**
   * AdministrativeOrder findFirst
   */
  export type AdministrativeOrderFindFirstArgs = {
    /**
     * Select specific fields to fetch from the AdministrativeOrder
     * 
    **/
    select?: AdministrativeOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdministrativeOrderInclude | null
    /**
     * Throw an Error if a AdministrativeOrder can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AdministrativeOrder to fetch.
     * 
    **/
    where?: AdministrativeOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdministrativeOrders to fetch.
     * 
    **/
    orderBy?: Enumerable<AdministrativeOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdministrativeOrders.
     * 
    **/
    cursor?: AdministrativeOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdministrativeOrders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdministrativeOrders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdministrativeOrders.
     * 
    **/
    distinct?: Enumerable<AdministrativeOrderScalarFieldEnum>
  }


  /**
   * AdministrativeOrder findMany
   */
  export type AdministrativeOrderFindManyArgs = {
    /**
     * Select specific fields to fetch from the AdministrativeOrder
     * 
    **/
    select?: AdministrativeOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdministrativeOrderInclude | null
    /**
     * Filter, which AdministrativeOrders to fetch.
     * 
    **/
    where?: AdministrativeOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdministrativeOrders to fetch.
     * 
    **/
    orderBy?: Enumerable<AdministrativeOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdministrativeOrders.
     * 
    **/
    cursor?: AdministrativeOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdministrativeOrders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdministrativeOrders.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AdministrativeOrderScalarFieldEnum>
  }


  /**
   * AdministrativeOrder create
   */
  export type AdministrativeOrderCreateArgs = {
    /**
     * Select specific fields to fetch from the AdministrativeOrder
     * 
    **/
    select?: AdministrativeOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdministrativeOrderInclude | null
    /**
     * The data needed to create a AdministrativeOrder.
     * 
    **/
    data: XOR<AdministrativeOrderCreateInput, AdministrativeOrderUncheckedCreateInput>
  }


  /**
   * AdministrativeOrder createMany
   */
  export type AdministrativeOrderCreateManyArgs = {
    data: Enumerable<AdministrativeOrderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AdministrativeOrder update
   */
  export type AdministrativeOrderUpdateArgs = {
    /**
     * Select specific fields to fetch from the AdministrativeOrder
     * 
    **/
    select?: AdministrativeOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdministrativeOrderInclude | null
    /**
     * The data needed to update a AdministrativeOrder.
     * 
    **/
    data: XOR<AdministrativeOrderUpdateInput, AdministrativeOrderUncheckedUpdateInput>
    /**
     * Choose, which AdministrativeOrder to update.
     * 
    **/
    where: AdministrativeOrderWhereUniqueInput
  }


  /**
   * AdministrativeOrder updateMany
   */
  export type AdministrativeOrderUpdateManyArgs = {
    data: XOR<AdministrativeOrderUpdateManyMutationInput, AdministrativeOrderUncheckedUpdateManyInput>
    where?: AdministrativeOrderWhereInput
  }


  /**
   * AdministrativeOrder upsert
   */
  export type AdministrativeOrderUpsertArgs = {
    /**
     * Select specific fields to fetch from the AdministrativeOrder
     * 
    **/
    select?: AdministrativeOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdministrativeOrderInclude | null
    /**
     * The filter to search for the AdministrativeOrder to update in case it exists.
     * 
    **/
    where: AdministrativeOrderWhereUniqueInput
    /**
     * In case the AdministrativeOrder found by the `where` argument doesn't exist, create a new AdministrativeOrder with this data.
     * 
    **/
    create: XOR<AdministrativeOrderCreateInput, AdministrativeOrderUncheckedCreateInput>
    /**
     * In case the AdministrativeOrder was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AdministrativeOrderUpdateInput, AdministrativeOrderUncheckedUpdateInput>
  }


  /**
   * AdministrativeOrder delete
   */
  export type AdministrativeOrderDeleteArgs = {
    /**
     * Select specific fields to fetch from the AdministrativeOrder
     * 
    **/
    select?: AdministrativeOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdministrativeOrderInclude | null
    /**
     * Filter which AdministrativeOrder to delete.
     * 
    **/
    where: AdministrativeOrderWhereUniqueInput
  }


  /**
   * AdministrativeOrder deleteMany
   */
  export type AdministrativeOrderDeleteManyArgs = {
    where?: AdministrativeOrderWhereInput
  }


  /**
   * AdministrativeOrder without action
   */
  export type AdministrativeOrderArgs = {
    /**
     * Select specific fields to fetch from the AdministrativeOrder
     * 
    **/
    select?: AdministrativeOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdministrativeOrderInclude | null
  }



  /**
   * Model OrderTitle
   */


  export type AggregateOrderTitle = {
    _count: OrderTitleCountAggregateOutputType | null
    _avg: OrderTitleAvgAggregateOutputType | null
    _sum: OrderTitleSumAggregateOutputType | null
    _min: OrderTitleMinAggregateOutputType | null
    _max: OrderTitleMaxAggregateOutputType | null
  }

  export type OrderTitleAvgAggregateOutputType = {
    idOrderTitle: number | null
    createdBy: number | null
  }

  export type OrderTitleSumAggregateOutputType = {
    idOrderTitle: number | null
    createdBy: number | null
  }

  export type OrderTitleMinAggregateOutputType = {
    idOrderTitle: number | null
    title: string | null
    createdAt: Date | null
    createdBy: number | null
  }

  export type OrderTitleMaxAggregateOutputType = {
    idOrderTitle: number | null
    title: string | null
    createdAt: Date | null
    createdBy: number | null
  }

  export type OrderTitleCountAggregateOutputType = {
    idOrderTitle: number
    title: number
    createdAt: number
    createdBy: number
    _all: number
  }


  export type OrderTitleAvgAggregateInputType = {
    idOrderTitle?: true
    createdBy?: true
  }

  export type OrderTitleSumAggregateInputType = {
    idOrderTitle?: true
    createdBy?: true
  }

  export type OrderTitleMinAggregateInputType = {
    idOrderTitle?: true
    title?: true
    createdAt?: true
    createdBy?: true
  }

  export type OrderTitleMaxAggregateInputType = {
    idOrderTitle?: true
    title?: true
    createdAt?: true
    createdBy?: true
  }

  export type OrderTitleCountAggregateInputType = {
    idOrderTitle?: true
    title?: true
    createdAt?: true
    createdBy?: true
    _all?: true
  }

  export type OrderTitleAggregateArgs = {
    /**
     * Filter which OrderTitle to aggregate.
     * 
    **/
    where?: OrderTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderTitles to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderTitleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OrderTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderTitles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderTitles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderTitles
    **/
    _count?: true | OrderTitleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderTitleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderTitleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderTitleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderTitleMaxAggregateInputType
  }

  export type GetOrderTitleAggregateType<T extends OrderTitleAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderTitle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderTitle[P]>
      : GetScalarType<T[P], AggregateOrderTitle[P]>
  }


    
    
  export type OrderTitleGroupByArgs = {
    where?: OrderTitleWhereInput
    orderBy?: Enumerable<OrderTitleOrderByWithAggregationInput>
    by: Array<OrderTitleScalarFieldEnum>
    having?: OrderTitleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderTitleCountAggregateInputType | true
    _avg?: OrderTitleAvgAggregateInputType
    _sum?: OrderTitleSumAggregateInputType
    _min?: OrderTitleMinAggregateInputType
    _max?: OrderTitleMaxAggregateInputType
  }


  export type OrderTitleGroupByOutputType = {
    idOrderTitle: number
    title: string
    createdAt: Date
    createdBy: number
    _count: OrderTitleCountAggregateOutputType | null
    _avg: OrderTitleAvgAggregateOutputType | null
    _sum: OrderTitleSumAggregateOutputType | null
    _min: OrderTitleMinAggregateOutputType | null
    _max: OrderTitleMaxAggregateOutputType | null
  }

  type GetOrderTitleGroupByPayload<T extends OrderTitleGroupByArgs> = Promise<
    Array<
      PickArray<OrderTitleGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof OrderTitleGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], OrderTitleGroupByOutputType[P]> 
            : GetScalarType<T[P], OrderTitleGroupByOutputType[P]>
        }
      > 
    >


  export type OrderTitleSelect = {
    idOrderTitle?: boolean
    title?: boolean
    createdAt?: boolean
    user?: boolean | UserArgs
    createdBy?: boolean
    administrativeOrders?: boolean | AdministrativeOrderFindManyArgs
    _count?: boolean | OrderTitleCountOutputTypeArgs
  }

  export type OrderTitleInclude = {
    user?: boolean | UserArgs
    administrativeOrders?: boolean | AdministrativeOrderFindManyArgs
    _count?: boolean | OrderTitleCountOutputTypeArgs
  }

  export type OrderTitleGetPayload<
    S extends boolean | null | undefined | OrderTitleArgs,
    U = keyof S
      > = S extends true
        ? OrderTitle
    : S extends undefined
    ? never
    : S extends OrderTitleArgs | OrderTitleFindManyArgs
    ?'include' extends U
    ? OrderTitle  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'administrativeOrders'
        ? Array < AdministrativeOrderGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? OrderTitleCountOutputTypeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof OrderTitle ?OrderTitle [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'administrativeOrders'
        ? Array < AdministrativeOrderGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? OrderTitleCountOutputTypeGetPayload<S['select'][P]> | null : never
  } 
    : OrderTitle
  : OrderTitle


  type OrderTitleCountArgs = Merge<
    Omit<OrderTitleFindManyArgs, 'select' | 'include'> & {
      select?: OrderTitleCountAggregateInputType | true
    }
  >

  export interface OrderTitleDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one OrderTitle that matches the filter.
     * @param {OrderTitleFindUniqueArgs} args - Arguments to find a OrderTitle
     * @example
     * // Get one OrderTitle
     * const orderTitle = await prisma.orderTitle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderTitleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrderTitleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OrderTitle'> extends True ? CheckSelect<T, Prisma__OrderTitleClient<OrderTitle>, Prisma__OrderTitleClient<OrderTitleGetPayload<T>>> : CheckSelect<T, Prisma__OrderTitleClient<OrderTitle | null >, Prisma__OrderTitleClient<OrderTitleGetPayload<T> | null >>

    /**
     * Find the first OrderTitle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderTitleFindFirstArgs} args - Arguments to find a OrderTitle
     * @example
     * // Get one OrderTitle
     * const orderTitle = await prisma.orderTitle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderTitleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrderTitleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OrderTitle'> extends True ? CheckSelect<T, Prisma__OrderTitleClient<OrderTitle>, Prisma__OrderTitleClient<OrderTitleGetPayload<T>>> : CheckSelect<T, Prisma__OrderTitleClient<OrderTitle | null >, Prisma__OrderTitleClient<OrderTitleGetPayload<T> | null >>

    /**
     * Find zero or more OrderTitles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderTitleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderTitles
     * const orderTitles = await prisma.orderTitle.findMany()
     * 
     * // Get first 10 OrderTitles
     * const orderTitles = await prisma.orderTitle.findMany({ take: 10 })
     * 
     * // Only select the `idOrderTitle`
     * const orderTitleWithIdOrderTitleOnly = await prisma.orderTitle.findMany({ select: { idOrderTitle: true } })
     * 
    **/
    findMany<T extends OrderTitleFindManyArgs>(
      args?: SelectSubset<T, OrderTitleFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OrderTitle>>, PrismaPromise<Array<OrderTitleGetPayload<T>>>>

    /**
     * Create a OrderTitle.
     * @param {OrderTitleCreateArgs} args - Arguments to create a OrderTitle.
     * @example
     * // Create one OrderTitle
     * const OrderTitle = await prisma.orderTitle.create({
     *   data: {
     *     // ... data to create a OrderTitle
     *   }
     * })
     * 
    **/
    create<T extends OrderTitleCreateArgs>(
      args: SelectSubset<T, OrderTitleCreateArgs>
    ): CheckSelect<T, Prisma__OrderTitleClient<OrderTitle>, Prisma__OrderTitleClient<OrderTitleGetPayload<T>>>

    /**
     * Create many OrderTitles.
     *     @param {OrderTitleCreateManyArgs} args - Arguments to create many OrderTitles.
     *     @example
     *     // Create many OrderTitles
     *     const orderTitle = await prisma.orderTitle.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderTitleCreateManyArgs>(
      args?: SelectSubset<T, OrderTitleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OrderTitle.
     * @param {OrderTitleDeleteArgs} args - Arguments to delete one OrderTitle.
     * @example
     * // Delete one OrderTitle
     * const OrderTitle = await prisma.orderTitle.delete({
     *   where: {
     *     // ... filter to delete one OrderTitle
     *   }
     * })
     * 
    **/
    delete<T extends OrderTitleDeleteArgs>(
      args: SelectSubset<T, OrderTitleDeleteArgs>
    ): CheckSelect<T, Prisma__OrderTitleClient<OrderTitle>, Prisma__OrderTitleClient<OrderTitleGetPayload<T>>>

    /**
     * Update one OrderTitle.
     * @param {OrderTitleUpdateArgs} args - Arguments to update one OrderTitle.
     * @example
     * // Update one OrderTitle
     * const orderTitle = await prisma.orderTitle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderTitleUpdateArgs>(
      args: SelectSubset<T, OrderTitleUpdateArgs>
    ): CheckSelect<T, Prisma__OrderTitleClient<OrderTitle>, Prisma__OrderTitleClient<OrderTitleGetPayload<T>>>

    /**
     * Delete zero or more OrderTitles.
     * @param {OrderTitleDeleteManyArgs} args - Arguments to filter OrderTitles to delete.
     * @example
     * // Delete a few OrderTitles
     * const { count } = await prisma.orderTitle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderTitleDeleteManyArgs>(
      args?: SelectSubset<T, OrderTitleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderTitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderTitleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderTitles
     * const orderTitle = await prisma.orderTitle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderTitleUpdateManyArgs>(
      args: SelectSubset<T, OrderTitleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderTitle.
     * @param {OrderTitleUpsertArgs} args - Arguments to update or create a OrderTitle.
     * @example
     * // Update or create a OrderTitle
     * const orderTitle = await prisma.orderTitle.upsert({
     *   create: {
     *     // ... data to create a OrderTitle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderTitle we want to update
     *   }
     * })
    **/
    upsert<T extends OrderTitleUpsertArgs>(
      args: SelectSubset<T, OrderTitleUpsertArgs>
    ): CheckSelect<T, Prisma__OrderTitleClient<OrderTitle>, Prisma__OrderTitleClient<OrderTitleGetPayload<T>>>

    /**
     * Count the number of OrderTitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderTitleCountArgs} args - Arguments to filter OrderTitles to count.
     * @example
     * // Count the number of OrderTitles
     * const count = await prisma.orderTitle.count({
     *   where: {
     *     // ... the filter for the OrderTitles we want to count
     *   }
     * })
    **/
    count<T extends OrderTitleCountArgs>(
      args?: Subset<T, OrderTitleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderTitleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderTitle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderTitleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderTitleAggregateArgs>(args: Subset<T, OrderTitleAggregateArgs>): PrismaPromise<GetOrderTitleAggregateType<T>>

    /**
     * Group by OrderTitle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderTitleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderTitleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderTitleGroupByArgs['orderBy'] }
        : { orderBy?: OrderTitleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderTitleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderTitleGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderTitle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrderTitleClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    administrativeOrders<T extends AdministrativeOrderFindManyArgs = {}>(args?: Subset<T, AdministrativeOrderFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AdministrativeOrder>>, PrismaPromise<Array<AdministrativeOrderGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * OrderTitle findUnique
   */
  export type OrderTitleFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the OrderTitle
     * 
    **/
    select?: OrderTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderTitleInclude | null
    /**
     * Throw an Error if a OrderTitle can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OrderTitle to fetch.
     * 
    **/
    where: OrderTitleWhereUniqueInput
  }


  /**
   * OrderTitle findFirst
   */
  export type OrderTitleFindFirstArgs = {
    /**
     * Select specific fields to fetch from the OrderTitle
     * 
    **/
    select?: OrderTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderTitleInclude | null
    /**
     * Throw an Error if a OrderTitle can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OrderTitle to fetch.
     * 
    **/
    where?: OrderTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderTitles to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderTitleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderTitles.
     * 
    **/
    cursor?: OrderTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderTitles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderTitles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderTitles.
     * 
    **/
    distinct?: Enumerable<OrderTitleScalarFieldEnum>
  }


  /**
   * OrderTitle findMany
   */
  export type OrderTitleFindManyArgs = {
    /**
     * Select specific fields to fetch from the OrderTitle
     * 
    **/
    select?: OrderTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderTitleInclude | null
    /**
     * Filter, which OrderTitles to fetch.
     * 
    **/
    where?: OrderTitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderTitles to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderTitleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderTitles.
     * 
    **/
    cursor?: OrderTitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderTitles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderTitles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OrderTitleScalarFieldEnum>
  }


  /**
   * OrderTitle create
   */
  export type OrderTitleCreateArgs = {
    /**
     * Select specific fields to fetch from the OrderTitle
     * 
    **/
    select?: OrderTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderTitleInclude | null
    /**
     * The data needed to create a OrderTitle.
     * 
    **/
    data: XOR<OrderTitleCreateInput, OrderTitleUncheckedCreateInput>
  }


  /**
   * OrderTitle createMany
   */
  export type OrderTitleCreateManyArgs = {
    data: Enumerable<OrderTitleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OrderTitle update
   */
  export type OrderTitleUpdateArgs = {
    /**
     * Select specific fields to fetch from the OrderTitle
     * 
    **/
    select?: OrderTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderTitleInclude | null
    /**
     * The data needed to update a OrderTitle.
     * 
    **/
    data: XOR<OrderTitleUpdateInput, OrderTitleUncheckedUpdateInput>
    /**
     * Choose, which OrderTitle to update.
     * 
    **/
    where: OrderTitleWhereUniqueInput
  }


  /**
   * OrderTitle updateMany
   */
  export type OrderTitleUpdateManyArgs = {
    data: XOR<OrderTitleUpdateManyMutationInput, OrderTitleUncheckedUpdateManyInput>
    where?: OrderTitleWhereInput
  }


  /**
   * OrderTitle upsert
   */
  export type OrderTitleUpsertArgs = {
    /**
     * Select specific fields to fetch from the OrderTitle
     * 
    **/
    select?: OrderTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderTitleInclude | null
    /**
     * The filter to search for the OrderTitle to update in case it exists.
     * 
    **/
    where: OrderTitleWhereUniqueInput
    /**
     * In case the OrderTitle found by the `where` argument doesn't exist, create a new OrderTitle with this data.
     * 
    **/
    create: XOR<OrderTitleCreateInput, OrderTitleUncheckedCreateInput>
    /**
     * In case the OrderTitle was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OrderTitleUpdateInput, OrderTitleUncheckedUpdateInput>
  }


  /**
   * OrderTitle delete
   */
  export type OrderTitleDeleteArgs = {
    /**
     * Select specific fields to fetch from the OrderTitle
     * 
    **/
    select?: OrderTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderTitleInclude | null
    /**
     * Filter which OrderTitle to delete.
     * 
    **/
    where: OrderTitleWhereUniqueInput
  }


  /**
   * OrderTitle deleteMany
   */
  export type OrderTitleDeleteManyArgs = {
    where?: OrderTitleWhereInput
  }


  /**
   * OrderTitle without action
   */
  export type OrderTitleArgs = {
    /**
     * Select specific fields to fetch from the OrderTitle
     * 
    **/
    select?: OrderTitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderTitleInclude | null
  }



  /**
   * Model ExitCauses
   */


  export type AggregateExitCauses = {
    _count: ExitCausesCountAggregateOutputType | null
    _avg: ExitCausesAvgAggregateOutputType | null
    _sum: ExitCausesSumAggregateOutputType | null
    _min: ExitCausesMinAggregateOutputType | null
    _max: ExitCausesMaxAggregateOutputType | null
  }

  export type ExitCausesAvgAggregateOutputType = {
    idExitCauses: number | null
    createdBy: number | null
  }

  export type ExitCausesSumAggregateOutputType = {
    idExitCauses: number | null
    createdBy: number | null
  }

  export type ExitCausesMinAggregateOutputType = {
    idExitCauses: number | null
    exitCausesTitle: string | null
    createdAt: Date | null
    createdBy: number | null
  }

  export type ExitCausesMaxAggregateOutputType = {
    idExitCauses: number | null
    exitCausesTitle: string | null
    createdAt: Date | null
    createdBy: number | null
  }

  export type ExitCausesCountAggregateOutputType = {
    idExitCauses: number
    exitCausesTitle: number
    createdAt: number
    createdBy: number
    _all: number
  }


  export type ExitCausesAvgAggregateInputType = {
    idExitCauses?: true
    createdBy?: true
  }

  export type ExitCausesSumAggregateInputType = {
    idExitCauses?: true
    createdBy?: true
  }

  export type ExitCausesMinAggregateInputType = {
    idExitCauses?: true
    exitCausesTitle?: true
    createdAt?: true
    createdBy?: true
  }

  export type ExitCausesMaxAggregateInputType = {
    idExitCauses?: true
    exitCausesTitle?: true
    createdAt?: true
    createdBy?: true
  }

  export type ExitCausesCountAggregateInputType = {
    idExitCauses?: true
    exitCausesTitle?: true
    createdAt?: true
    createdBy?: true
    _all?: true
  }

  export type ExitCausesAggregateArgs = {
    /**
     * Filter which ExitCauses to aggregate.
     * 
    **/
    where?: ExitCausesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExitCauses to fetch.
     * 
    **/
    orderBy?: Enumerable<ExitCausesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ExitCausesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExitCauses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExitCauses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExitCauses
    **/
    _count?: true | ExitCausesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExitCausesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExitCausesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExitCausesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExitCausesMaxAggregateInputType
  }

  export type GetExitCausesAggregateType<T extends ExitCausesAggregateArgs> = {
        [P in keyof T & keyof AggregateExitCauses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExitCauses[P]>
      : GetScalarType<T[P], AggregateExitCauses[P]>
  }


    
    
  export type ExitCausesGroupByArgs = {
    where?: ExitCausesWhereInput
    orderBy?: Enumerable<ExitCausesOrderByWithAggregationInput>
    by: Array<ExitCausesScalarFieldEnum>
    having?: ExitCausesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExitCausesCountAggregateInputType | true
    _avg?: ExitCausesAvgAggregateInputType
    _sum?: ExitCausesSumAggregateInputType
    _min?: ExitCausesMinAggregateInputType
    _max?: ExitCausesMaxAggregateInputType
  }


  export type ExitCausesGroupByOutputType = {
    idExitCauses: number
    exitCausesTitle: string
    createdAt: Date
    createdBy: number
    _count: ExitCausesCountAggregateOutputType | null
    _avg: ExitCausesAvgAggregateOutputType | null
    _sum: ExitCausesSumAggregateOutputType | null
    _min: ExitCausesMinAggregateOutputType | null
    _max: ExitCausesMaxAggregateOutputType | null
  }

  type GetExitCausesGroupByPayload<T extends ExitCausesGroupByArgs> = Promise<
    Array<
      PickArray<ExitCausesGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ExitCausesGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ExitCausesGroupByOutputType[P]> 
            : GetScalarType<T[P], ExitCausesGroupByOutputType[P]>
        }
      > 
    >


  export type ExitCausesSelect = {
    idExitCauses?: boolean
    exitCausesTitle?: boolean
    createdAt?: boolean
    user?: boolean | UserArgs
    createdBy?: boolean
  }

  export type ExitCausesInclude = {
    user?: boolean | UserArgs
  }

  export type ExitCausesGetPayload<
    S extends boolean | null | undefined | ExitCausesArgs,
    U = keyof S
      > = S extends true
        ? ExitCauses
    : S extends undefined
    ? never
    : S extends ExitCausesArgs | ExitCausesFindManyArgs
    ?'include' extends U
    ? ExitCauses  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ExitCauses ?ExitCauses [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : ExitCauses
  : ExitCauses


  type ExitCausesCountArgs = Merge<
    Omit<ExitCausesFindManyArgs, 'select' | 'include'> & {
      select?: ExitCausesCountAggregateInputType | true
    }
  >

  export interface ExitCausesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ExitCauses that matches the filter.
     * @param {ExitCausesFindUniqueArgs} args - Arguments to find a ExitCauses
     * @example
     * // Get one ExitCauses
     * const exitCauses = await prisma.exitCauses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ExitCausesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ExitCausesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ExitCauses'> extends True ? CheckSelect<T, Prisma__ExitCausesClient<ExitCauses>, Prisma__ExitCausesClient<ExitCausesGetPayload<T>>> : CheckSelect<T, Prisma__ExitCausesClient<ExitCauses | null >, Prisma__ExitCausesClient<ExitCausesGetPayload<T> | null >>

    /**
     * Find the first ExitCauses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExitCausesFindFirstArgs} args - Arguments to find a ExitCauses
     * @example
     * // Get one ExitCauses
     * const exitCauses = await prisma.exitCauses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ExitCausesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ExitCausesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ExitCauses'> extends True ? CheckSelect<T, Prisma__ExitCausesClient<ExitCauses>, Prisma__ExitCausesClient<ExitCausesGetPayload<T>>> : CheckSelect<T, Prisma__ExitCausesClient<ExitCauses | null >, Prisma__ExitCausesClient<ExitCausesGetPayload<T> | null >>

    /**
     * Find zero or more ExitCauses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExitCausesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExitCauses
     * const exitCauses = await prisma.exitCauses.findMany()
     * 
     * // Get first 10 ExitCauses
     * const exitCauses = await prisma.exitCauses.findMany({ take: 10 })
     * 
     * // Only select the `idExitCauses`
     * const exitCausesWithIdExitCausesOnly = await prisma.exitCauses.findMany({ select: { idExitCauses: true } })
     * 
    **/
    findMany<T extends ExitCausesFindManyArgs>(
      args?: SelectSubset<T, ExitCausesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ExitCauses>>, PrismaPromise<Array<ExitCausesGetPayload<T>>>>

    /**
     * Create a ExitCauses.
     * @param {ExitCausesCreateArgs} args - Arguments to create a ExitCauses.
     * @example
     * // Create one ExitCauses
     * const ExitCauses = await prisma.exitCauses.create({
     *   data: {
     *     // ... data to create a ExitCauses
     *   }
     * })
     * 
    **/
    create<T extends ExitCausesCreateArgs>(
      args: SelectSubset<T, ExitCausesCreateArgs>
    ): CheckSelect<T, Prisma__ExitCausesClient<ExitCauses>, Prisma__ExitCausesClient<ExitCausesGetPayload<T>>>

    /**
     * Create many ExitCauses.
     *     @param {ExitCausesCreateManyArgs} args - Arguments to create many ExitCauses.
     *     @example
     *     // Create many ExitCauses
     *     const exitCauses = await prisma.exitCauses.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ExitCausesCreateManyArgs>(
      args?: SelectSubset<T, ExitCausesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ExitCauses.
     * @param {ExitCausesDeleteArgs} args - Arguments to delete one ExitCauses.
     * @example
     * // Delete one ExitCauses
     * const ExitCauses = await prisma.exitCauses.delete({
     *   where: {
     *     // ... filter to delete one ExitCauses
     *   }
     * })
     * 
    **/
    delete<T extends ExitCausesDeleteArgs>(
      args: SelectSubset<T, ExitCausesDeleteArgs>
    ): CheckSelect<T, Prisma__ExitCausesClient<ExitCauses>, Prisma__ExitCausesClient<ExitCausesGetPayload<T>>>

    /**
     * Update one ExitCauses.
     * @param {ExitCausesUpdateArgs} args - Arguments to update one ExitCauses.
     * @example
     * // Update one ExitCauses
     * const exitCauses = await prisma.exitCauses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ExitCausesUpdateArgs>(
      args: SelectSubset<T, ExitCausesUpdateArgs>
    ): CheckSelect<T, Prisma__ExitCausesClient<ExitCauses>, Prisma__ExitCausesClient<ExitCausesGetPayload<T>>>

    /**
     * Delete zero or more ExitCauses.
     * @param {ExitCausesDeleteManyArgs} args - Arguments to filter ExitCauses to delete.
     * @example
     * // Delete a few ExitCauses
     * const { count } = await prisma.exitCauses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ExitCausesDeleteManyArgs>(
      args?: SelectSubset<T, ExitCausesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExitCauses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExitCausesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExitCauses
     * const exitCauses = await prisma.exitCauses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ExitCausesUpdateManyArgs>(
      args: SelectSubset<T, ExitCausesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ExitCauses.
     * @param {ExitCausesUpsertArgs} args - Arguments to update or create a ExitCauses.
     * @example
     * // Update or create a ExitCauses
     * const exitCauses = await prisma.exitCauses.upsert({
     *   create: {
     *     // ... data to create a ExitCauses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExitCauses we want to update
     *   }
     * })
    **/
    upsert<T extends ExitCausesUpsertArgs>(
      args: SelectSubset<T, ExitCausesUpsertArgs>
    ): CheckSelect<T, Prisma__ExitCausesClient<ExitCauses>, Prisma__ExitCausesClient<ExitCausesGetPayload<T>>>

    /**
     * Count the number of ExitCauses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExitCausesCountArgs} args - Arguments to filter ExitCauses to count.
     * @example
     * // Count the number of ExitCauses
     * const count = await prisma.exitCauses.count({
     *   where: {
     *     // ... the filter for the ExitCauses we want to count
     *   }
     * })
    **/
    count<T extends ExitCausesCountArgs>(
      args?: Subset<T, ExitCausesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExitCausesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExitCauses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExitCausesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExitCausesAggregateArgs>(args: Subset<T, ExitCausesAggregateArgs>): PrismaPromise<GetExitCausesAggregateType<T>>

    /**
     * Group by ExitCauses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExitCausesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExitCausesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExitCausesGroupByArgs['orderBy'] }
        : { orderBy?: ExitCausesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExitCausesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExitCausesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExitCauses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ExitCausesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ExitCauses findUnique
   */
  export type ExitCausesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ExitCauses
     * 
    **/
    select?: ExitCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExitCausesInclude | null
    /**
     * Throw an Error if a ExitCauses can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ExitCauses to fetch.
     * 
    **/
    where: ExitCausesWhereUniqueInput
  }


  /**
   * ExitCauses findFirst
   */
  export type ExitCausesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ExitCauses
     * 
    **/
    select?: ExitCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExitCausesInclude | null
    /**
     * Throw an Error if a ExitCauses can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ExitCauses to fetch.
     * 
    **/
    where?: ExitCausesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExitCauses to fetch.
     * 
    **/
    orderBy?: Enumerable<ExitCausesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExitCauses.
     * 
    **/
    cursor?: ExitCausesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExitCauses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExitCauses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExitCauses.
     * 
    **/
    distinct?: Enumerable<ExitCausesScalarFieldEnum>
  }


  /**
   * ExitCauses findMany
   */
  export type ExitCausesFindManyArgs = {
    /**
     * Select specific fields to fetch from the ExitCauses
     * 
    **/
    select?: ExitCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExitCausesInclude | null
    /**
     * Filter, which ExitCauses to fetch.
     * 
    **/
    where?: ExitCausesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExitCauses to fetch.
     * 
    **/
    orderBy?: Enumerable<ExitCausesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExitCauses.
     * 
    **/
    cursor?: ExitCausesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExitCauses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExitCauses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ExitCausesScalarFieldEnum>
  }


  /**
   * ExitCauses create
   */
  export type ExitCausesCreateArgs = {
    /**
     * Select specific fields to fetch from the ExitCauses
     * 
    **/
    select?: ExitCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExitCausesInclude | null
    /**
     * The data needed to create a ExitCauses.
     * 
    **/
    data: XOR<ExitCausesCreateInput, ExitCausesUncheckedCreateInput>
  }


  /**
   * ExitCauses createMany
   */
  export type ExitCausesCreateManyArgs = {
    data: Enumerable<ExitCausesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ExitCauses update
   */
  export type ExitCausesUpdateArgs = {
    /**
     * Select specific fields to fetch from the ExitCauses
     * 
    **/
    select?: ExitCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExitCausesInclude | null
    /**
     * The data needed to update a ExitCauses.
     * 
    **/
    data: XOR<ExitCausesUpdateInput, ExitCausesUncheckedUpdateInput>
    /**
     * Choose, which ExitCauses to update.
     * 
    **/
    where: ExitCausesWhereUniqueInput
  }


  /**
   * ExitCauses updateMany
   */
  export type ExitCausesUpdateManyArgs = {
    data: XOR<ExitCausesUpdateManyMutationInput, ExitCausesUncheckedUpdateManyInput>
    where?: ExitCausesWhereInput
  }


  /**
   * ExitCauses upsert
   */
  export type ExitCausesUpsertArgs = {
    /**
     * Select specific fields to fetch from the ExitCauses
     * 
    **/
    select?: ExitCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExitCausesInclude | null
    /**
     * The filter to search for the ExitCauses to update in case it exists.
     * 
    **/
    where: ExitCausesWhereUniqueInput
    /**
     * In case the ExitCauses found by the `where` argument doesn't exist, create a new ExitCauses with this data.
     * 
    **/
    create: XOR<ExitCausesCreateInput, ExitCausesUncheckedCreateInput>
    /**
     * In case the ExitCauses was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ExitCausesUpdateInput, ExitCausesUncheckedUpdateInput>
  }


  /**
   * ExitCauses delete
   */
  export type ExitCausesDeleteArgs = {
    /**
     * Select specific fields to fetch from the ExitCauses
     * 
    **/
    select?: ExitCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExitCausesInclude | null
    /**
     * Filter which ExitCauses to delete.
     * 
    **/
    where: ExitCausesWhereUniqueInput
  }


  /**
   * ExitCauses deleteMany
   */
  export type ExitCausesDeleteManyArgs = {
    where?: ExitCausesWhereInput
  }


  /**
   * ExitCauses without action
   */
  export type ExitCausesArgs = {
    /**
     * Select specific fields to fetch from the ExitCauses
     * 
    **/
    select?: ExitCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExitCausesInclude | null
  }



  /**
   * Model PassType
   */


  export type AggregatePassType = {
    _count: PassTypeCountAggregateOutputType | null
    _avg: PassTypeAvgAggregateOutputType | null
    _sum: PassTypeSumAggregateOutputType | null
    _min: PassTypeMinAggregateOutputType | null
    _max: PassTypeMaxAggregateOutputType | null
  }

  export type PassTypeAvgAggregateOutputType = {
    idPassType: number | null
    createdBy: number | null
  }

  export type PassTypeSumAggregateOutputType = {
    idPassType: number | null
    createdBy: number | null
  }

  export type PassTypeMinAggregateOutputType = {
    idPassType: number | null
    passName: string | null
    createdAt: Date | null
    createdBy: number | null
  }

  export type PassTypeMaxAggregateOutputType = {
    idPassType: number | null
    passName: string | null
    createdAt: Date | null
    createdBy: number | null
  }

  export type PassTypeCountAggregateOutputType = {
    idPassType: number
    passName: number
    createdAt: number
    createdBy: number
    _all: number
  }


  export type PassTypeAvgAggregateInputType = {
    idPassType?: true
    createdBy?: true
  }

  export type PassTypeSumAggregateInputType = {
    idPassType?: true
    createdBy?: true
  }

  export type PassTypeMinAggregateInputType = {
    idPassType?: true
    passName?: true
    createdAt?: true
    createdBy?: true
  }

  export type PassTypeMaxAggregateInputType = {
    idPassType?: true
    passName?: true
    createdAt?: true
    createdBy?: true
  }

  export type PassTypeCountAggregateInputType = {
    idPassType?: true
    passName?: true
    createdAt?: true
    createdBy?: true
    _all?: true
  }

  export type PassTypeAggregateArgs = {
    /**
     * Filter which PassType to aggregate.
     * 
    **/
    where?: PassTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PassTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<PassTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PassTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PassTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PassTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PassTypes
    **/
    _count?: true | PassTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PassTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PassTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PassTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PassTypeMaxAggregateInputType
  }

  export type GetPassTypeAggregateType<T extends PassTypeAggregateArgs> = {
        [P in keyof T & keyof AggregatePassType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePassType[P]>
      : GetScalarType<T[P], AggregatePassType[P]>
  }


    
    
  export type PassTypeGroupByArgs = {
    where?: PassTypeWhereInput
    orderBy?: Enumerable<PassTypeOrderByWithAggregationInput>
    by: Array<PassTypeScalarFieldEnum>
    having?: PassTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PassTypeCountAggregateInputType | true
    _avg?: PassTypeAvgAggregateInputType
    _sum?: PassTypeSumAggregateInputType
    _min?: PassTypeMinAggregateInputType
    _max?: PassTypeMaxAggregateInputType
  }


  export type PassTypeGroupByOutputType = {
    idPassType: number
    passName: string
    createdAt: Date
    createdBy: number
    _count: PassTypeCountAggregateOutputType | null
    _avg: PassTypeAvgAggregateOutputType | null
    _sum: PassTypeSumAggregateOutputType | null
    _min: PassTypeMinAggregateOutputType | null
    _max: PassTypeMaxAggregateOutputType | null
  }

  type GetPassTypeGroupByPayload<T extends PassTypeGroupByArgs> = Promise<
    Array<
      PickArray<PassTypeGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof PassTypeGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], PassTypeGroupByOutputType[P]> 
            : GetScalarType<T[P], PassTypeGroupByOutputType[P]>
        }
      > 
    >


  export type PassTypeSelect = {
    idPassType?: boolean
    passName?: boolean
    createdAt?: boolean
    user?: boolean | UserArgs
    createdBy?: boolean
  }

  export type PassTypeInclude = {
    user?: boolean | UserArgs
  }

  export type PassTypeGetPayload<
    S extends boolean | null | undefined | PassTypeArgs,
    U = keyof S
      > = S extends true
        ? PassType
    : S extends undefined
    ? never
    : S extends PassTypeArgs | PassTypeFindManyArgs
    ?'include' extends U
    ? PassType  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof PassType ?PassType [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : PassType
  : PassType


  type PassTypeCountArgs = Merge<
    Omit<PassTypeFindManyArgs, 'select' | 'include'> & {
      select?: PassTypeCountAggregateInputType | true
    }
  >

  export interface PassTypeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PassType that matches the filter.
     * @param {PassTypeFindUniqueArgs} args - Arguments to find a PassType
     * @example
     * // Get one PassType
     * const passType = await prisma.passType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PassTypeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PassTypeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PassType'> extends True ? CheckSelect<T, Prisma__PassTypeClient<PassType>, Prisma__PassTypeClient<PassTypeGetPayload<T>>> : CheckSelect<T, Prisma__PassTypeClient<PassType | null >, Prisma__PassTypeClient<PassTypeGetPayload<T> | null >>

    /**
     * Find the first PassType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassTypeFindFirstArgs} args - Arguments to find a PassType
     * @example
     * // Get one PassType
     * const passType = await prisma.passType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PassTypeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PassTypeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PassType'> extends True ? CheckSelect<T, Prisma__PassTypeClient<PassType>, Prisma__PassTypeClient<PassTypeGetPayload<T>>> : CheckSelect<T, Prisma__PassTypeClient<PassType | null >, Prisma__PassTypeClient<PassTypeGetPayload<T> | null >>

    /**
     * Find zero or more PassTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PassTypes
     * const passTypes = await prisma.passType.findMany()
     * 
     * // Get first 10 PassTypes
     * const passTypes = await prisma.passType.findMany({ take: 10 })
     * 
     * // Only select the `idPassType`
     * const passTypeWithIdPassTypeOnly = await prisma.passType.findMany({ select: { idPassType: true } })
     * 
    **/
    findMany<T extends PassTypeFindManyArgs>(
      args?: SelectSubset<T, PassTypeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PassType>>, PrismaPromise<Array<PassTypeGetPayload<T>>>>

    /**
     * Create a PassType.
     * @param {PassTypeCreateArgs} args - Arguments to create a PassType.
     * @example
     * // Create one PassType
     * const PassType = await prisma.passType.create({
     *   data: {
     *     // ... data to create a PassType
     *   }
     * })
     * 
    **/
    create<T extends PassTypeCreateArgs>(
      args: SelectSubset<T, PassTypeCreateArgs>
    ): CheckSelect<T, Prisma__PassTypeClient<PassType>, Prisma__PassTypeClient<PassTypeGetPayload<T>>>

    /**
     * Create many PassTypes.
     *     @param {PassTypeCreateManyArgs} args - Arguments to create many PassTypes.
     *     @example
     *     // Create many PassTypes
     *     const passType = await prisma.passType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PassTypeCreateManyArgs>(
      args?: SelectSubset<T, PassTypeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PassType.
     * @param {PassTypeDeleteArgs} args - Arguments to delete one PassType.
     * @example
     * // Delete one PassType
     * const PassType = await prisma.passType.delete({
     *   where: {
     *     // ... filter to delete one PassType
     *   }
     * })
     * 
    **/
    delete<T extends PassTypeDeleteArgs>(
      args: SelectSubset<T, PassTypeDeleteArgs>
    ): CheckSelect<T, Prisma__PassTypeClient<PassType>, Prisma__PassTypeClient<PassTypeGetPayload<T>>>

    /**
     * Update one PassType.
     * @param {PassTypeUpdateArgs} args - Arguments to update one PassType.
     * @example
     * // Update one PassType
     * const passType = await prisma.passType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PassTypeUpdateArgs>(
      args: SelectSubset<T, PassTypeUpdateArgs>
    ): CheckSelect<T, Prisma__PassTypeClient<PassType>, Prisma__PassTypeClient<PassTypeGetPayload<T>>>

    /**
     * Delete zero or more PassTypes.
     * @param {PassTypeDeleteManyArgs} args - Arguments to filter PassTypes to delete.
     * @example
     * // Delete a few PassTypes
     * const { count } = await prisma.passType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PassTypeDeleteManyArgs>(
      args?: SelectSubset<T, PassTypeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PassTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PassTypes
     * const passType = await prisma.passType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PassTypeUpdateManyArgs>(
      args: SelectSubset<T, PassTypeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PassType.
     * @param {PassTypeUpsertArgs} args - Arguments to update or create a PassType.
     * @example
     * // Update or create a PassType
     * const passType = await prisma.passType.upsert({
     *   create: {
     *     // ... data to create a PassType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PassType we want to update
     *   }
     * })
    **/
    upsert<T extends PassTypeUpsertArgs>(
      args: SelectSubset<T, PassTypeUpsertArgs>
    ): CheckSelect<T, Prisma__PassTypeClient<PassType>, Prisma__PassTypeClient<PassTypeGetPayload<T>>>

    /**
     * Count the number of PassTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassTypeCountArgs} args - Arguments to filter PassTypes to count.
     * @example
     * // Count the number of PassTypes
     * const count = await prisma.passType.count({
     *   where: {
     *     // ... the filter for the PassTypes we want to count
     *   }
     * })
    **/
    count<T extends PassTypeCountArgs>(
      args?: Subset<T, PassTypeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PassTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PassType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PassTypeAggregateArgs>(args: Subset<T, PassTypeAggregateArgs>): PrismaPromise<GetPassTypeAggregateType<T>>

    /**
     * Group by PassType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PassTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PassTypeGroupByArgs['orderBy'] }
        : { orderBy?: PassTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PassTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPassTypeGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PassType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PassTypeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PassType findUnique
   */
  export type PassTypeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PassType
     * 
    **/
    select?: PassTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PassTypeInclude | null
    /**
     * Throw an Error if a PassType can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PassType to fetch.
     * 
    **/
    where: PassTypeWhereUniqueInput
  }


  /**
   * PassType findFirst
   */
  export type PassTypeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PassType
     * 
    **/
    select?: PassTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PassTypeInclude | null
    /**
     * Throw an Error if a PassType can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PassType to fetch.
     * 
    **/
    where?: PassTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PassTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<PassTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PassTypes.
     * 
    **/
    cursor?: PassTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PassTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PassTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PassTypes.
     * 
    **/
    distinct?: Enumerable<PassTypeScalarFieldEnum>
  }


  /**
   * PassType findMany
   */
  export type PassTypeFindManyArgs = {
    /**
     * Select specific fields to fetch from the PassType
     * 
    **/
    select?: PassTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PassTypeInclude | null
    /**
     * Filter, which PassTypes to fetch.
     * 
    **/
    where?: PassTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PassTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<PassTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PassTypes.
     * 
    **/
    cursor?: PassTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PassTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PassTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PassTypeScalarFieldEnum>
  }


  /**
   * PassType create
   */
  export type PassTypeCreateArgs = {
    /**
     * Select specific fields to fetch from the PassType
     * 
    **/
    select?: PassTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PassTypeInclude | null
    /**
     * The data needed to create a PassType.
     * 
    **/
    data: XOR<PassTypeCreateInput, PassTypeUncheckedCreateInput>
  }


  /**
   * PassType createMany
   */
  export type PassTypeCreateManyArgs = {
    data: Enumerable<PassTypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PassType update
   */
  export type PassTypeUpdateArgs = {
    /**
     * Select specific fields to fetch from the PassType
     * 
    **/
    select?: PassTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PassTypeInclude | null
    /**
     * The data needed to update a PassType.
     * 
    **/
    data: XOR<PassTypeUpdateInput, PassTypeUncheckedUpdateInput>
    /**
     * Choose, which PassType to update.
     * 
    **/
    where: PassTypeWhereUniqueInput
  }


  /**
   * PassType updateMany
   */
  export type PassTypeUpdateManyArgs = {
    data: XOR<PassTypeUpdateManyMutationInput, PassTypeUncheckedUpdateManyInput>
    where?: PassTypeWhereInput
  }


  /**
   * PassType upsert
   */
  export type PassTypeUpsertArgs = {
    /**
     * Select specific fields to fetch from the PassType
     * 
    **/
    select?: PassTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PassTypeInclude | null
    /**
     * The filter to search for the PassType to update in case it exists.
     * 
    **/
    where: PassTypeWhereUniqueInput
    /**
     * In case the PassType found by the `where` argument doesn't exist, create a new PassType with this data.
     * 
    **/
    create: XOR<PassTypeCreateInput, PassTypeUncheckedCreateInput>
    /**
     * In case the PassType was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PassTypeUpdateInput, PassTypeUncheckedUpdateInput>
  }


  /**
   * PassType delete
   */
  export type PassTypeDeleteArgs = {
    /**
     * Select specific fields to fetch from the PassType
     * 
    **/
    select?: PassTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PassTypeInclude | null
    /**
     * Filter which PassType to delete.
     * 
    **/
    where: PassTypeWhereUniqueInput
  }


  /**
   * PassType deleteMany
   */
  export type PassTypeDeleteManyArgs = {
    where?: PassTypeWhereInput
  }


  /**
   * PassType without action
   */
  export type PassTypeArgs = {
    /**
     * Select specific fields to fetch from the PassType
     * 
    **/
    select?: PassTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PassTypeInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    idUser: number | null
    roleId: number | null
    sectionId: number | null
  }

  export type UserSumAggregateOutputType = {
    idUser: number | null
    roleId: number | null
    sectionId: number | null
  }

  export type UserMinAggregateOutputType = {
    idUser: number | null
    userName: string | null
    password: string | null
    roleId: number | null
    sectionId: number | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    idUser: number | null
    userName: string | null
    password: string | null
    roleId: number | null
    sectionId: number | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    idUser: number
    userName: number
    password: number
    roleId: number
    sectionId: number
    createdAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    idUser?: true
    roleId?: true
    sectionId?: true
  }

  export type UserSumAggregateInputType = {
    idUser?: true
    roleId?: true
    sectionId?: true
  }

  export type UserMinAggregateInputType = {
    idUser?: true
    userName?: true
    password?: true
    roleId?: true
    sectionId?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    idUser?: true
    userName?: true
    password?: true
    roleId?: true
    sectionId?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    idUser?: true
    userName?: true
    password?: true
    roleId?: true
    sectionId?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }


    
    
  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    idUser: number
    userName: string
    password: string
    roleId: number
    sectionId: number
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Promise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], UserGroupByOutputType[P]> 
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      > 
    >


  export type UserSelect = {
    idUser?: boolean
    userName?: boolean
    password?: boolean
    role?: boolean | RoleArgs
    roleId?: boolean
    section?: boolean | SectionArgs
    sectionId?: boolean
    createdAt?: boolean
    passTypes?: boolean | PassTypeFindManyArgs
    administrativeOrders?: boolean | AdministrativeOrderFindManyArgs
    OrderTitles?: boolean | OrderTitleFindManyArgs
    ExitCauses?: boolean | ExitCausesFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserInclude = {
    role?: boolean | RoleArgs
    section?: boolean | SectionArgs
    passTypes?: boolean | PassTypeFindManyArgs
    administrativeOrders?: boolean | AdministrativeOrderFindManyArgs
    OrderTitles?: boolean | OrderTitleFindManyArgs
    ExitCauses?: boolean | ExitCausesFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'role'
        ? RoleGetPayload<S['include'][P]> :
        P extends 'section'
        ? SectionGetPayload<S['include'][P]> :
        P extends 'passTypes'
        ? Array < PassTypeGetPayload<S['include'][P]>>  :
        P extends 'administrativeOrders'
        ? Array < AdministrativeOrderGetPayload<S['include'][P]>>  :
        P extends 'OrderTitles'
        ? Array < OrderTitleGetPayload<S['include'][P]>>  :
        P extends 'ExitCauses'
        ? Array < ExitCausesGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? UserCountOutputTypeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof User ?User [P]
  : 
          P extends 'role'
        ? RoleGetPayload<S['select'][P]> :
        P extends 'section'
        ? SectionGetPayload<S['select'][P]> :
        P extends 'passTypes'
        ? Array < PassTypeGetPayload<S['select'][P]>>  :
        P extends 'administrativeOrders'
        ? Array < AdministrativeOrderGetPayload<S['select'][P]>>  :
        P extends 'OrderTitles'
        ? Array < OrderTitleGetPayload<S['select'][P]>>  :
        P extends 'ExitCauses'
        ? Array < ExitCausesGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? UserCountOutputTypeGetPayload<S['select'][P]> | null : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `idUser`
     * const userWithIdUserOnly = await prisma.user.findMany({ select: { idUser: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    role<T extends RoleArgs = {}>(args?: Subset<T, RoleArgs>): CheckSelect<T, Prisma__RoleClient<Role | null >, Prisma__RoleClient<RoleGetPayload<T> | null >>;

    section<T extends SectionArgs = {}>(args?: Subset<T, SectionArgs>): CheckSelect<T, Prisma__SectionClient<Section | null >, Prisma__SectionClient<SectionGetPayload<T> | null >>;

    passTypes<T extends PassTypeFindManyArgs = {}>(args?: Subset<T, PassTypeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PassType>>, PrismaPromise<Array<PassTypeGetPayload<T>>>>;

    administrativeOrders<T extends AdministrativeOrderFindManyArgs = {}>(args?: Subset<T, AdministrativeOrderFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AdministrativeOrder>>, PrismaPromise<Array<AdministrativeOrderGetPayload<T>>>>;

    OrderTitles<T extends OrderTitleFindManyArgs = {}>(args?: Subset<T, OrderTitleFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OrderTitle>>, PrismaPromise<Array<OrderTitleGetPayload<T>>>>;

    ExitCauses<T extends ExitCausesFindManyArgs = {}>(args?: Subset<T, ExitCausesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ExitCauses>>, PrismaPromise<Array<ExitCausesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model Role
   */


  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    idRole: number | null
  }

  export type RoleSumAggregateOutputType = {
    idRole: number | null
  }

  export type RoleMinAggregateOutputType = {
    idRole: number | null
    roleName: string | null
    createdAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    idRole: number | null
    roleName: string | null
    createdAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    idRole: number
    roleName: number
    createdAt: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    idRole?: true
  }

  export type RoleSumAggregateInputType = {
    idRole?: true
  }

  export type RoleMinAggregateInputType = {
    idRole?: true
    roleName?: true
    createdAt?: true
  }

  export type RoleMaxAggregateInputType = {
    idRole?: true
    roleName?: true
    createdAt?: true
  }

  export type RoleCountAggregateInputType = {
    idRole?: true
    roleName?: true
    createdAt?: true
    _all?: true
  }

  export type RoleAggregateArgs = {
    /**
     * Filter which Role to aggregate.
     * 
    **/
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     * 
    **/
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }


    
    
  export type RoleGroupByArgs = {
    where?: RoleWhereInput
    orderBy?: Enumerable<RoleOrderByWithAggregationInput>
    by: Array<RoleScalarFieldEnum>
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }


  export type RoleGroupByOutputType = {
    idRole: number
    roleName: string
    createdAt: Date
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Promise<
    Array<
      PickArray<RoleGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], RoleGroupByOutputType[P]> 
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      > 
    >


  export type RoleSelect = {
    idRole?: boolean
    roleName?: boolean
    createdAt?: boolean
    users?: boolean | UserFindManyArgs
    _count?: boolean | RoleCountOutputTypeArgs
  }

  export type RoleInclude = {
    users?: boolean | UserFindManyArgs
    _count?: boolean | RoleCountOutputTypeArgs
  }

  export type RoleGetPayload<
    S extends boolean | null | undefined | RoleArgs,
    U = keyof S
      > = S extends true
        ? Role
    : S extends undefined
    ? never
    : S extends RoleArgs | RoleFindManyArgs
    ?'include' extends U
    ? Role  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'users'
        ? Array < UserGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? RoleCountOutputTypeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Role ?Role [P]
  : 
          P extends 'users'
        ? Array < UserGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? RoleCountOutputTypeGetPayload<S['select'][P]> | null : never
  } 
    : Role
  : Role


  type RoleCountArgs = Merge<
    Omit<RoleFindManyArgs, 'select' | 'include'> & {
      select?: RoleCountAggregateInputType | true
    }
  >

  export interface RoleDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RoleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Role'> extends True ? CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>> : CheckSelect<T, Prisma__RoleClient<Role | null >, Prisma__RoleClient<RoleGetPayload<T> | null >>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RoleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Role'> extends True ? CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>> : CheckSelect<T, Prisma__RoleClient<Role | null >, Prisma__RoleClient<RoleGetPayload<T> | null >>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `idRole`
     * const roleWithIdRoleOnly = await prisma.role.findMany({ select: { idRole: true } })
     * 
    **/
    findMany<T extends RoleFindManyArgs>(
      args?: SelectSubset<T, RoleFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Role>>, PrismaPromise<Array<RoleGetPayload<T>>>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
    **/
    create<T extends RoleCreateArgs>(
      args: SelectSubset<T, RoleCreateArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Create many Roles.
     *     @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     *     @example
     *     // Create many Roles
     *     const role = await prisma.role.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoleCreateManyArgs>(
      args?: SelectSubset<T, RoleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
    **/
    delete<T extends RoleDeleteArgs>(
      args: SelectSubset<T, RoleDeleteArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoleUpdateArgs>(
      args: SelectSubset<T, RoleUpdateArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoleDeleteManyArgs>(
      args?: SelectSubset<T, RoleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoleUpdateManyArgs>(
      args: SelectSubset<T, RoleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
    **/
    upsert<T extends RoleUpsertArgs>(
      args: SelectSubset<T, RoleUpsertArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RoleClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    users<T extends UserFindManyArgs = {}>(args?: Subset<T, UserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * Throw an Error if a Role can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Role to fetch.
     * 
    **/
    where: RoleWhereUniqueInput
  }


  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * Throw an Error if a Role can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Role to fetch.
     * 
    **/
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     * 
    **/
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     * 
    **/
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     * 
    **/
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role findMany
   */
  export type RoleFindManyArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * Filter, which Roles to fetch.
     * 
    **/
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     * 
    **/
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     * 
    **/
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role create
   */
  export type RoleCreateArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * The data needed to create a Role.
     * 
    **/
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }


  /**
   * Role createMany
   */
  export type RoleCreateManyArgs = {
    data: Enumerable<RoleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Role update
   */
  export type RoleUpdateArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * The data needed to update a Role.
     * 
    **/
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     * 
    **/
    where: RoleWhereUniqueInput
  }


  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs = {
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    where?: RoleWhereInput
  }


  /**
   * Role upsert
   */
  export type RoleUpsertArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * The filter to search for the Role to update in case it exists.
     * 
    **/
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     * 
    **/
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }


  /**
   * Role delete
   */
  export type RoleDeleteArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * Filter which Role to delete.
     * 
    **/
    where: RoleWhereUniqueInput
  }


  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs = {
    where?: RoleWhereInput
  }


  /**
   * Role without action
   */
  export type RoleArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
  }



  /**
   * Model Section
   */


  export type AggregateSection = {
    _count: SectionCountAggregateOutputType | null
    _avg: SectionAvgAggregateOutputType | null
    _sum: SectionSumAggregateOutputType | null
    _min: SectionMinAggregateOutputType | null
    _max: SectionMaxAggregateOutputType | null
  }

  export type SectionAvgAggregateOutputType = {
    idSection: number | null
  }

  export type SectionSumAggregateOutputType = {
    idSection: number | null
  }

  export type SectionMinAggregateOutputType = {
    idSection: number | null
    sectionName: string | null
    code: string | null
    englishName: string | null
  }

  export type SectionMaxAggregateOutputType = {
    idSection: number | null
    sectionName: string | null
    code: string | null
    englishName: string | null
  }

  export type SectionCountAggregateOutputType = {
    idSection: number
    sectionName: number
    code: number
    englishName: number
    _all: number
  }


  export type SectionAvgAggregateInputType = {
    idSection?: true
  }

  export type SectionSumAggregateInputType = {
    idSection?: true
  }

  export type SectionMinAggregateInputType = {
    idSection?: true
    sectionName?: true
    code?: true
    englishName?: true
  }

  export type SectionMaxAggregateInputType = {
    idSection?: true
    sectionName?: true
    code?: true
    englishName?: true
  }

  export type SectionCountAggregateInputType = {
    idSection?: true
    sectionName?: true
    code?: true
    englishName?: true
    _all?: true
  }

  export type SectionAggregateArgs = {
    /**
     * Filter which Section to aggregate.
     * 
    **/
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     * 
    **/
    orderBy?: Enumerable<SectionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sections
    **/
    _count?: true | SectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SectionMaxAggregateInputType
  }

  export type GetSectionAggregateType<T extends SectionAggregateArgs> = {
        [P in keyof T & keyof AggregateSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSection[P]>
      : GetScalarType<T[P], AggregateSection[P]>
  }


    
    
  export type SectionGroupByArgs = {
    where?: SectionWhereInput
    orderBy?: Enumerable<SectionOrderByWithAggregationInput>
    by: Array<SectionScalarFieldEnum>
    having?: SectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SectionCountAggregateInputType | true
    _avg?: SectionAvgAggregateInputType
    _sum?: SectionSumAggregateInputType
    _min?: SectionMinAggregateInputType
    _max?: SectionMaxAggregateInputType
  }


  export type SectionGroupByOutputType = {
    idSection: number
    sectionName: string
    code: string
    englishName: string
    _count: SectionCountAggregateOutputType | null
    _avg: SectionAvgAggregateOutputType | null
    _sum: SectionSumAggregateOutputType | null
    _min: SectionMinAggregateOutputType | null
    _max: SectionMaxAggregateOutputType | null
  }

  type GetSectionGroupByPayload<T extends SectionGroupByArgs> = Promise<
    Array<
      PickArray<SectionGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof SectionGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], SectionGroupByOutputType[P]> 
            : GetScalarType<T[P], SectionGroupByOutputType[P]>
        }
      > 
    >


  export type SectionSelect = {
    idSection?: boolean
    sectionName?: boolean
    code?: boolean
    englishName?: boolean
    students?: boolean | StudentFindManyArgs
    User?: boolean | UserFindManyArgs
    _count?: boolean | SectionCountOutputTypeArgs
  }

  export type SectionInclude = {
    students?: boolean | StudentFindManyArgs
    User?: boolean | UserFindManyArgs
    _count?: boolean | SectionCountOutputTypeArgs
  }

  export type SectionGetPayload<
    S extends boolean | null | undefined | SectionArgs,
    U = keyof S
      > = S extends true
        ? Section
    : S extends undefined
    ? never
    : S extends SectionArgs | SectionFindManyArgs
    ?'include' extends U
    ? Section  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'students'
        ? Array < StudentGetPayload<S['include'][P]>>  :
        P extends 'User'
        ? Array < UserGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? SectionCountOutputTypeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Section ?Section [P]
  : 
          P extends 'students'
        ? Array < StudentGetPayload<S['select'][P]>>  :
        P extends 'User'
        ? Array < UserGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? SectionCountOutputTypeGetPayload<S['select'][P]> | null : never
  } 
    : Section
  : Section


  type SectionCountArgs = Merge<
    Omit<SectionFindManyArgs, 'select' | 'include'> & {
      select?: SectionCountAggregateInputType | true
    }
  >

  export interface SectionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Section that matches the filter.
     * @param {SectionFindUniqueArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SectionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SectionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Section'> extends True ? CheckSelect<T, Prisma__SectionClient<Section>, Prisma__SectionClient<SectionGetPayload<T>>> : CheckSelect<T, Prisma__SectionClient<Section | null >, Prisma__SectionClient<SectionGetPayload<T> | null >>

    /**
     * Find the first Section that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindFirstArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SectionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SectionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Section'> extends True ? CheckSelect<T, Prisma__SectionClient<Section>, Prisma__SectionClient<SectionGetPayload<T>>> : CheckSelect<T, Prisma__SectionClient<Section | null >, Prisma__SectionClient<SectionGetPayload<T> | null >>

    /**
     * Find zero or more Sections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sections
     * const sections = await prisma.section.findMany()
     * 
     * // Get first 10 Sections
     * const sections = await prisma.section.findMany({ take: 10 })
     * 
     * // Only select the `idSection`
     * const sectionWithIdSectionOnly = await prisma.section.findMany({ select: { idSection: true } })
     * 
    **/
    findMany<T extends SectionFindManyArgs>(
      args?: SelectSubset<T, SectionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Section>>, PrismaPromise<Array<SectionGetPayload<T>>>>

    /**
     * Create a Section.
     * @param {SectionCreateArgs} args - Arguments to create a Section.
     * @example
     * // Create one Section
     * const Section = await prisma.section.create({
     *   data: {
     *     // ... data to create a Section
     *   }
     * })
     * 
    **/
    create<T extends SectionCreateArgs>(
      args: SelectSubset<T, SectionCreateArgs>
    ): CheckSelect<T, Prisma__SectionClient<Section>, Prisma__SectionClient<SectionGetPayload<T>>>

    /**
     * Create many Sections.
     *     @param {SectionCreateManyArgs} args - Arguments to create many Sections.
     *     @example
     *     // Create many Sections
     *     const section = await prisma.section.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SectionCreateManyArgs>(
      args?: SelectSubset<T, SectionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Section.
     * @param {SectionDeleteArgs} args - Arguments to delete one Section.
     * @example
     * // Delete one Section
     * const Section = await prisma.section.delete({
     *   where: {
     *     // ... filter to delete one Section
     *   }
     * })
     * 
    **/
    delete<T extends SectionDeleteArgs>(
      args: SelectSubset<T, SectionDeleteArgs>
    ): CheckSelect<T, Prisma__SectionClient<Section>, Prisma__SectionClient<SectionGetPayload<T>>>

    /**
     * Update one Section.
     * @param {SectionUpdateArgs} args - Arguments to update one Section.
     * @example
     * // Update one Section
     * const section = await prisma.section.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SectionUpdateArgs>(
      args: SelectSubset<T, SectionUpdateArgs>
    ): CheckSelect<T, Prisma__SectionClient<Section>, Prisma__SectionClient<SectionGetPayload<T>>>

    /**
     * Delete zero or more Sections.
     * @param {SectionDeleteManyArgs} args - Arguments to filter Sections to delete.
     * @example
     * // Delete a few Sections
     * const { count } = await prisma.section.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SectionDeleteManyArgs>(
      args?: SelectSubset<T, SectionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sections
     * const section = await prisma.section.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SectionUpdateManyArgs>(
      args: SelectSubset<T, SectionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Section.
     * @param {SectionUpsertArgs} args - Arguments to update or create a Section.
     * @example
     * // Update or create a Section
     * const section = await prisma.section.upsert({
     *   create: {
     *     // ... data to create a Section
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Section we want to update
     *   }
     * })
    **/
    upsert<T extends SectionUpsertArgs>(
      args: SelectSubset<T, SectionUpsertArgs>
    ): CheckSelect<T, Prisma__SectionClient<Section>, Prisma__SectionClient<SectionGetPayload<T>>>

    /**
     * Count the number of Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionCountArgs} args - Arguments to filter Sections to count.
     * @example
     * // Count the number of Sections
     * const count = await prisma.section.count({
     *   where: {
     *     // ... the filter for the Sections we want to count
     *   }
     * })
    **/
    count<T extends SectionCountArgs>(
      args?: Subset<T, SectionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectionAggregateArgs>(args: Subset<T, SectionAggregateArgs>): PrismaPromise<GetSectionAggregateType<T>>

    /**
     * Group by Section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SectionGroupByArgs['orderBy'] }
        : { orderBy?: SectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectionGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Section.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SectionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    students<T extends StudentFindManyArgs = {}>(args?: Subset<T, StudentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Student>>, PrismaPromise<Array<StudentGetPayload<T>>>>;

    User<T extends UserFindManyArgs = {}>(args?: Subset<T, UserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Section findUnique
   */
  export type SectionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Section
     * 
    **/
    select?: SectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SectionInclude | null
    /**
     * Throw an Error if a Section can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Section to fetch.
     * 
    **/
    where: SectionWhereUniqueInput
  }


  /**
   * Section findFirst
   */
  export type SectionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Section
     * 
    **/
    select?: SectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SectionInclude | null
    /**
     * Throw an Error if a Section can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Section to fetch.
     * 
    **/
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     * 
    **/
    orderBy?: Enumerable<SectionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sections.
     * 
    **/
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sections.
     * 
    **/
    distinct?: Enumerable<SectionScalarFieldEnum>
  }


  /**
   * Section findMany
   */
  export type SectionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Section
     * 
    **/
    select?: SectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SectionInclude | null
    /**
     * Filter, which Sections to fetch.
     * 
    **/
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     * 
    **/
    orderBy?: Enumerable<SectionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sections.
     * 
    **/
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SectionScalarFieldEnum>
  }


  /**
   * Section create
   */
  export type SectionCreateArgs = {
    /**
     * Select specific fields to fetch from the Section
     * 
    **/
    select?: SectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SectionInclude | null
    /**
     * The data needed to create a Section.
     * 
    **/
    data: XOR<SectionCreateInput, SectionUncheckedCreateInput>
  }


  /**
   * Section createMany
   */
  export type SectionCreateManyArgs = {
    data: Enumerable<SectionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Section update
   */
  export type SectionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Section
     * 
    **/
    select?: SectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SectionInclude | null
    /**
     * The data needed to update a Section.
     * 
    **/
    data: XOR<SectionUpdateInput, SectionUncheckedUpdateInput>
    /**
     * Choose, which Section to update.
     * 
    **/
    where: SectionWhereUniqueInput
  }


  /**
   * Section updateMany
   */
  export type SectionUpdateManyArgs = {
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyInput>
    where?: SectionWhereInput
  }


  /**
   * Section upsert
   */
  export type SectionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Section
     * 
    **/
    select?: SectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SectionInclude | null
    /**
     * The filter to search for the Section to update in case it exists.
     * 
    **/
    where: SectionWhereUniqueInput
    /**
     * In case the Section found by the `where` argument doesn't exist, create a new Section with this data.
     * 
    **/
    create: XOR<SectionCreateInput, SectionUncheckedCreateInput>
    /**
     * In case the Section was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SectionUpdateInput, SectionUncheckedUpdateInput>
  }


  /**
   * Section delete
   */
  export type SectionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Section
     * 
    **/
    select?: SectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SectionInclude | null
    /**
     * Filter which Section to delete.
     * 
    **/
    where: SectionWhereUniqueInput
  }


  /**
   * Section deleteMany
   */
  export type SectionDeleteManyArgs = {
    where?: SectionWhereInput
  }


  /**
   * Section without action
   */
  export type SectionArgs = {
    /**
     * Select specific fields to fetch from the Section
     * 
    **/
    select?: SectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SectionInclude | null
  }



  /**
   * Model Student
   */


  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentAvgAggregateOutputType = {
    idStudent: number | null
    sectionId: number | null
    registerYearId: number | null
    studentStatusId: number | null
    acceptedTypeId: number | null
  }

  export type StudentSumAggregateOutputType = {
    idStudent: number | null
    sectionId: number | null
    registerYearId: number | null
    studentStatusId: number | null
    acceptedTypeId: number | null
  }

  export type StudentMinAggregateOutputType = {
    idStudent: number | null
    studentName: string | null
    englishName: string | null
    mail: string | null
    password: string | null
    dob: string | null
    sectionId: number | null
    nationality: string | null
    phone: string | null
    gender: boolean | null
    studyType: boolean | null
    relationships: boolean | null
    note: string | null
    religion: string | null
    motherName: string | null
    collegeNumber: string | null
    registerYearId: number | null
    studentStatusId: number | null
    acceptedTypeId: number | null
  }

  export type StudentMaxAggregateOutputType = {
    idStudent: number | null
    studentName: string | null
    englishName: string | null
    mail: string | null
    password: string | null
    dob: string | null
    sectionId: number | null
    nationality: string | null
    phone: string | null
    gender: boolean | null
    studyType: boolean | null
    relationships: boolean | null
    note: string | null
    religion: string | null
    motherName: string | null
    collegeNumber: string | null
    registerYearId: number | null
    studentStatusId: number | null
    acceptedTypeId: number | null
  }

  export type StudentCountAggregateOutputType = {
    idStudent: number
    studentName: number
    englishName: number
    mail: number
    password: number
    dob: number
    sectionId: number
    nationality: number
    phone: number
    gender: number
    studyType: number
    relationships: number
    note: number
    religion: number
    motherName: number
    collegeNumber: number
    registerYearId: number
    studentStatusId: number
    acceptedTypeId: number
    _all: number
  }


  export type StudentAvgAggregateInputType = {
    idStudent?: true
    sectionId?: true
    registerYearId?: true
    studentStatusId?: true
    acceptedTypeId?: true
  }

  export type StudentSumAggregateInputType = {
    idStudent?: true
    sectionId?: true
    registerYearId?: true
    studentStatusId?: true
    acceptedTypeId?: true
  }

  export type StudentMinAggregateInputType = {
    idStudent?: true
    studentName?: true
    englishName?: true
    mail?: true
    password?: true
    dob?: true
    sectionId?: true
    nationality?: true
    phone?: true
    gender?: true
    studyType?: true
    relationships?: true
    note?: true
    religion?: true
    motherName?: true
    collegeNumber?: true
    registerYearId?: true
    studentStatusId?: true
    acceptedTypeId?: true
  }

  export type StudentMaxAggregateInputType = {
    idStudent?: true
    studentName?: true
    englishName?: true
    mail?: true
    password?: true
    dob?: true
    sectionId?: true
    nationality?: true
    phone?: true
    gender?: true
    studyType?: true
    relationships?: true
    note?: true
    religion?: true
    motherName?: true
    collegeNumber?: true
    registerYearId?: true
    studentStatusId?: true
    acceptedTypeId?: true
  }

  export type StudentCountAggregateInputType = {
    idStudent?: true
    studentName?: true
    englishName?: true
    mail?: true
    password?: true
    dob?: true
    sectionId?: true
    nationality?: true
    phone?: true
    gender?: true
    studyType?: true
    relationships?: true
    note?: true
    religion?: true
    motherName?: true
    collegeNumber?: true
    registerYearId?: true
    studentStatusId?: true
    acceptedTypeId?: true
    _all?: true
  }

  export type StudentAggregateArgs = {
    /**
     * Filter which Student to aggregate.
     * 
    **/
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     * 
    **/
    orderBy?: Enumerable<StudentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }


    
    
  export type StudentGroupByArgs = {
    where?: StudentWhereInput
    orderBy?: Enumerable<StudentOrderByWithAggregationInput>
    by: Array<StudentScalarFieldEnum>
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _avg?: StudentAvgAggregateInputType
    _sum?: StudentSumAggregateInputType
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }


  export type StudentGroupByOutputType = {
    idStudent: number
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    sectionId: number
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    registerYearId: number
    studentStatusId: number
    acceptedTypeId: number
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Promise<
    Array<
      PickArray<StudentGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], StudentGroupByOutputType[P]> 
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      > 
    >


  export type StudentSelect = {
    idStudent?: boolean
    studentName?: boolean
    englishName?: boolean
    mail?: boolean
    password?: boolean
    dob?: boolean
    section?: boolean | SectionArgs
    sectionId?: boolean
    nationality?: boolean
    phone?: boolean
    gender?: boolean
    studyType?: boolean
    relationships?: boolean
    note?: boolean
    religion?: boolean
    motherName?: boolean
    collegeNumber?: boolean
    yearStudy?: boolean | YearStudyArgs
    registerYearId?: boolean
    studentStatus?: boolean | StudentStatusArgs
    studentStatusId?: boolean
    acceptedType?: boolean | AcceptedTypeArgs
    acceptedTypeId?: boolean
    administrativeOrders?: boolean | AdministrativeOrderFindManyArgs
    studentSchool?: boolean | StudentSchoolArgs
    studentLevel?: boolean | StudentLevelFindManyArgs
    studentGraduation?: boolean | StudentGraduationArgs
    nationalInfo?: boolean | NationalInfoArgs
    studentResponsables?: boolean | StudentResponsibleFindManyArgs
    nationalityCertificate?: boolean | NationalityCertificateFindManyArgs
    studentImage?: boolean | StudentImageFindManyArgs
    address?: boolean | AddressArgs
    _count?: boolean | StudentCountOutputTypeArgs
  }

  export type StudentInclude = {
    section?: boolean | SectionArgs
    yearStudy?: boolean | YearStudyArgs
    studentStatus?: boolean | StudentStatusArgs
    acceptedType?: boolean | AcceptedTypeArgs
    administrativeOrders?: boolean | AdministrativeOrderFindManyArgs
    studentSchool?: boolean | StudentSchoolArgs
    studentLevel?: boolean | StudentLevelFindManyArgs
    studentGraduation?: boolean | StudentGraduationArgs
    nationalInfo?: boolean | NationalInfoArgs
    studentResponsables?: boolean | StudentResponsibleFindManyArgs
    nationalityCertificate?: boolean | NationalityCertificateFindManyArgs
    studentImage?: boolean | StudentImageFindManyArgs
    address?: boolean | AddressArgs
    _count?: boolean | StudentCountOutputTypeArgs
  }

  export type StudentGetPayload<
    S extends boolean | null | undefined | StudentArgs,
    U = keyof S
      > = S extends true
        ? Student
    : S extends undefined
    ? never
    : S extends StudentArgs | StudentFindManyArgs
    ?'include' extends U
    ? Student  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'section'
        ? SectionGetPayload<S['include'][P]> :
        P extends 'yearStudy'
        ? YearStudyGetPayload<S['include'][P]> :
        P extends 'studentStatus'
        ? StudentStatusGetPayload<S['include'][P]> :
        P extends 'acceptedType'
        ? AcceptedTypeGetPayload<S['include'][P]> :
        P extends 'administrativeOrders'
        ? Array < AdministrativeOrderGetPayload<S['include'][P]>>  :
        P extends 'studentSchool'
        ? StudentSchoolGetPayload<S['include'][P]> | null :
        P extends 'studentLevel'
        ? Array < StudentLevelGetPayload<S['include'][P]>>  :
        P extends 'studentGraduation'
        ? StudentGraduationGetPayload<S['include'][P]> | null :
        P extends 'nationalInfo'
        ? NationalInfoGetPayload<S['include'][P]> | null :
        P extends 'studentResponsables'
        ? Array < StudentResponsibleGetPayload<S['include'][P]>>  :
        P extends 'nationalityCertificate'
        ? Array < NationalityCertificateGetPayload<S['include'][P]>>  :
        P extends 'studentImage'
        ? Array < StudentImageGetPayload<S['include'][P]>>  :
        P extends 'address'
        ? AddressGetPayload<S['include'][P]> | null :
        P extends '_count'
        ? StudentCountOutputTypeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Student ?Student [P]
  : 
          P extends 'section'
        ? SectionGetPayload<S['select'][P]> :
        P extends 'yearStudy'
        ? YearStudyGetPayload<S['select'][P]> :
        P extends 'studentStatus'
        ? StudentStatusGetPayload<S['select'][P]> :
        P extends 'acceptedType'
        ? AcceptedTypeGetPayload<S['select'][P]> :
        P extends 'administrativeOrders'
        ? Array < AdministrativeOrderGetPayload<S['select'][P]>>  :
        P extends 'studentSchool'
        ? StudentSchoolGetPayload<S['select'][P]> | null :
        P extends 'studentLevel'
        ? Array < StudentLevelGetPayload<S['select'][P]>>  :
        P extends 'studentGraduation'
        ? StudentGraduationGetPayload<S['select'][P]> | null :
        P extends 'nationalInfo'
        ? NationalInfoGetPayload<S['select'][P]> | null :
        P extends 'studentResponsables'
        ? Array < StudentResponsibleGetPayload<S['select'][P]>>  :
        P extends 'nationalityCertificate'
        ? Array < NationalityCertificateGetPayload<S['select'][P]>>  :
        P extends 'studentImage'
        ? Array < StudentImageGetPayload<S['select'][P]>>  :
        P extends 'address'
        ? AddressGetPayload<S['select'][P]> | null :
        P extends '_count'
        ? StudentCountOutputTypeGetPayload<S['select'][P]> | null : never
  } 
    : Student
  : Student


  type StudentCountArgs = Merge<
    Omit<StudentFindManyArgs, 'select' | 'include'> & {
      select?: StudentCountAggregateInputType | true
    }
  >

  export interface StudentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StudentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Student'> extends True ? CheckSelect<T, Prisma__StudentClient<Student>, Prisma__StudentClient<StudentGetPayload<T>>> : CheckSelect<T, Prisma__StudentClient<Student | null >, Prisma__StudentClient<StudentGetPayload<T> | null >>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StudentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Student'> extends True ? CheckSelect<T, Prisma__StudentClient<Student>, Prisma__StudentClient<StudentGetPayload<T>>> : CheckSelect<T, Prisma__StudentClient<Student | null >, Prisma__StudentClient<StudentGetPayload<T> | null >>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `idStudent`
     * const studentWithIdStudentOnly = await prisma.student.findMany({ select: { idStudent: true } })
     * 
    **/
    findMany<T extends StudentFindManyArgs>(
      args?: SelectSubset<T, StudentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Student>>, PrismaPromise<Array<StudentGetPayload<T>>>>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
    **/
    create<T extends StudentCreateArgs>(
      args: SelectSubset<T, StudentCreateArgs>
    ): CheckSelect<T, Prisma__StudentClient<Student>, Prisma__StudentClient<StudentGetPayload<T>>>

    /**
     * Create many Students.
     *     @param {StudentCreateManyArgs} args - Arguments to create many Students.
     *     @example
     *     // Create many Students
     *     const student = await prisma.student.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentCreateManyArgs>(
      args?: SelectSubset<T, StudentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
    **/
    delete<T extends StudentDeleteArgs>(
      args: SelectSubset<T, StudentDeleteArgs>
    ): CheckSelect<T, Prisma__StudentClient<Student>, Prisma__StudentClient<StudentGetPayload<T>>>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentUpdateArgs>(
      args: SelectSubset<T, StudentUpdateArgs>
    ): CheckSelect<T, Prisma__StudentClient<Student>, Prisma__StudentClient<StudentGetPayload<T>>>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentDeleteManyArgs>(
      args?: SelectSubset<T, StudentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentUpdateManyArgs>(
      args: SelectSubset<T, StudentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
    **/
    upsert<T extends StudentUpsertArgs>(
      args: SelectSubset<T, StudentUpsertArgs>
    ): CheckSelect<T, Prisma__StudentClient<Student>, Prisma__StudentClient<StudentGetPayload<T>>>

    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StudentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    section<T extends SectionArgs = {}>(args?: Subset<T, SectionArgs>): CheckSelect<T, Prisma__SectionClient<Section | null >, Prisma__SectionClient<SectionGetPayload<T> | null >>;

    yearStudy<T extends YearStudyArgs = {}>(args?: Subset<T, YearStudyArgs>): CheckSelect<T, Prisma__YearStudyClient<YearStudy | null >, Prisma__YearStudyClient<YearStudyGetPayload<T> | null >>;

    studentStatus<T extends StudentStatusArgs = {}>(args?: Subset<T, StudentStatusArgs>): CheckSelect<T, Prisma__StudentStatusClient<StudentStatus | null >, Prisma__StudentStatusClient<StudentStatusGetPayload<T> | null >>;

    acceptedType<T extends AcceptedTypeArgs = {}>(args?: Subset<T, AcceptedTypeArgs>): CheckSelect<T, Prisma__AcceptedTypeClient<AcceptedType | null >, Prisma__AcceptedTypeClient<AcceptedTypeGetPayload<T> | null >>;

    administrativeOrders<T extends AdministrativeOrderFindManyArgs = {}>(args?: Subset<T, AdministrativeOrderFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AdministrativeOrder>>, PrismaPromise<Array<AdministrativeOrderGetPayload<T>>>>;

    studentSchool<T extends StudentSchoolArgs = {}>(args?: Subset<T, StudentSchoolArgs>): CheckSelect<T, Prisma__StudentSchoolClient<StudentSchool | null >, Prisma__StudentSchoolClient<StudentSchoolGetPayload<T> | null >>;

    studentLevel<T extends StudentLevelFindManyArgs = {}>(args?: Subset<T, StudentLevelFindManyArgs>): CheckSelect<T, PrismaPromise<Array<StudentLevel>>, PrismaPromise<Array<StudentLevelGetPayload<T>>>>;

    studentGraduation<T extends StudentGraduationArgs = {}>(args?: Subset<T, StudentGraduationArgs>): CheckSelect<T, Prisma__StudentGraduationClient<StudentGraduation | null >, Prisma__StudentGraduationClient<StudentGraduationGetPayload<T> | null >>;

    nationalInfo<T extends NationalInfoArgs = {}>(args?: Subset<T, NationalInfoArgs>): CheckSelect<T, Prisma__NationalInfoClient<NationalInfo | null >, Prisma__NationalInfoClient<NationalInfoGetPayload<T> | null >>;

    studentResponsables<T extends StudentResponsibleFindManyArgs = {}>(args?: Subset<T, StudentResponsibleFindManyArgs>): CheckSelect<T, PrismaPromise<Array<StudentResponsible>>, PrismaPromise<Array<StudentResponsibleGetPayload<T>>>>;

    nationalityCertificate<T extends NationalityCertificateFindManyArgs = {}>(args?: Subset<T, NationalityCertificateFindManyArgs>): CheckSelect<T, PrismaPromise<Array<NationalityCertificate>>, PrismaPromise<Array<NationalityCertificateGetPayload<T>>>>;

    studentImage<T extends StudentImageFindManyArgs = {}>(args?: Subset<T, StudentImageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<StudentImage>>, PrismaPromise<Array<StudentImageGetPayload<T>>>>;

    address<T extends AddressArgs = {}>(args?: Subset<T, AddressArgs>): CheckSelect<T, Prisma__AddressClient<Address | null >, Prisma__AddressClient<AddressGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Student
     * 
    **/
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentInclude | null
    /**
     * Throw an Error if a Student can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Student to fetch.
     * 
    **/
    where: StudentWhereUniqueInput
  }


  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Student
     * 
    **/
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentInclude | null
    /**
     * Throw an Error if a Student can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Student to fetch.
     * 
    **/
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     * 
    **/
    orderBy?: Enumerable<StudentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     * 
    **/
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     * 
    **/
    distinct?: Enumerable<StudentScalarFieldEnum>
  }


  /**
   * Student findMany
   */
  export type StudentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Student
     * 
    **/
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentInclude | null
    /**
     * Filter, which Students to fetch.
     * 
    **/
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     * 
    **/
    orderBy?: Enumerable<StudentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     * 
    **/
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StudentScalarFieldEnum>
  }


  /**
   * Student create
   */
  export type StudentCreateArgs = {
    /**
     * Select specific fields to fetch from the Student
     * 
    **/
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentInclude | null
    /**
     * The data needed to create a Student.
     * 
    **/
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }


  /**
   * Student createMany
   */
  export type StudentCreateManyArgs = {
    data: Enumerable<StudentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Student update
   */
  export type StudentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Student
     * 
    **/
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentInclude | null
    /**
     * The data needed to update a Student.
     * 
    **/
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     * 
    **/
    where: StudentWhereUniqueInput
  }


  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs = {
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    where?: StudentWhereInput
  }


  /**
   * Student upsert
   */
  export type StudentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Student
     * 
    **/
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentInclude | null
    /**
     * The filter to search for the Student to update in case it exists.
     * 
    **/
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     * 
    **/
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }


  /**
   * Student delete
   */
  export type StudentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Student
     * 
    **/
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentInclude | null
    /**
     * Filter which Student to delete.
     * 
    **/
    where: StudentWhereUniqueInput
  }


  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs = {
    where?: StudentWhereInput
  }


  /**
   * Student without action
   */
  export type StudentArgs = {
    /**
     * Select specific fields to fetch from the Student
     * 
    **/
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentInclude | null
  }



  /**
   * Model YearStudy
   */


  export type AggregateYearStudy = {
    _count: YearStudyCountAggregateOutputType | null
    _avg: YearStudyAvgAggregateOutputType | null
    _sum: YearStudySumAggregateOutputType | null
    _min: YearStudyMinAggregateOutputType | null
    _max: YearStudyMaxAggregateOutputType | null
  }

  export type YearStudyAvgAggregateOutputType = {
    idYearStudy: number | null
  }

  export type YearStudySumAggregateOutputType = {
    idYearStudy: number | null
  }

  export type YearStudyMinAggregateOutputType = {
    idYearStudy: number | null
    year: string | null
    currentYear: boolean | null
  }

  export type YearStudyMaxAggregateOutputType = {
    idYearStudy: number | null
    year: string | null
    currentYear: boolean | null
  }

  export type YearStudyCountAggregateOutputType = {
    idYearStudy: number
    year: number
    currentYear: number
    _all: number
  }


  export type YearStudyAvgAggregateInputType = {
    idYearStudy?: true
  }

  export type YearStudySumAggregateInputType = {
    idYearStudy?: true
  }

  export type YearStudyMinAggregateInputType = {
    idYearStudy?: true
    year?: true
    currentYear?: true
  }

  export type YearStudyMaxAggregateInputType = {
    idYearStudy?: true
    year?: true
    currentYear?: true
  }

  export type YearStudyCountAggregateInputType = {
    idYearStudy?: true
    year?: true
    currentYear?: true
    _all?: true
  }

  export type YearStudyAggregateArgs = {
    /**
     * Filter which YearStudy to aggregate.
     * 
    **/
    where?: YearStudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearStudies to fetch.
     * 
    **/
    orderBy?: Enumerable<YearStudyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: YearStudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearStudies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearStudies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YearStudies
    **/
    _count?: true | YearStudyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YearStudyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YearStudySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YearStudyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YearStudyMaxAggregateInputType
  }

  export type GetYearStudyAggregateType<T extends YearStudyAggregateArgs> = {
        [P in keyof T & keyof AggregateYearStudy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYearStudy[P]>
      : GetScalarType<T[P], AggregateYearStudy[P]>
  }


    
    
  export type YearStudyGroupByArgs = {
    where?: YearStudyWhereInput
    orderBy?: Enumerable<YearStudyOrderByWithAggregationInput>
    by: Array<YearStudyScalarFieldEnum>
    having?: YearStudyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YearStudyCountAggregateInputType | true
    _avg?: YearStudyAvgAggregateInputType
    _sum?: YearStudySumAggregateInputType
    _min?: YearStudyMinAggregateInputType
    _max?: YearStudyMaxAggregateInputType
  }


  export type YearStudyGroupByOutputType = {
    idYearStudy: number
    year: string
    currentYear: boolean
    _count: YearStudyCountAggregateOutputType | null
    _avg: YearStudyAvgAggregateOutputType | null
    _sum: YearStudySumAggregateOutputType | null
    _min: YearStudyMinAggregateOutputType | null
    _max: YearStudyMaxAggregateOutputType | null
  }

  type GetYearStudyGroupByPayload<T extends YearStudyGroupByArgs> = Promise<
    Array<
      PickArray<YearStudyGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof YearStudyGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], YearStudyGroupByOutputType[P]> 
            : GetScalarType<T[P], YearStudyGroupByOutputType[P]>
        }
      > 
    >


  export type YearStudySelect = {
    idYearStudy?: boolean
    year?: boolean
    currentYear?: boolean
    StudentLevel?: boolean | StudentLevelFindManyArgs
    Student?: boolean | StudentFindManyArgs
    _count?: boolean | YearStudyCountOutputTypeArgs
  }

  export type YearStudyInclude = {
    StudentLevel?: boolean | StudentLevelFindManyArgs
    Student?: boolean | StudentFindManyArgs
    _count?: boolean | YearStudyCountOutputTypeArgs
  }

  export type YearStudyGetPayload<
    S extends boolean | null | undefined | YearStudyArgs,
    U = keyof S
      > = S extends true
        ? YearStudy
    : S extends undefined
    ? never
    : S extends YearStudyArgs | YearStudyFindManyArgs
    ?'include' extends U
    ? YearStudy  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'StudentLevel'
        ? Array < StudentLevelGetPayload<S['include'][P]>>  :
        P extends 'Student'
        ? Array < StudentGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? YearStudyCountOutputTypeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof YearStudy ?YearStudy [P]
  : 
          P extends 'StudentLevel'
        ? Array < StudentLevelGetPayload<S['select'][P]>>  :
        P extends 'Student'
        ? Array < StudentGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? YearStudyCountOutputTypeGetPayload<S['select'][P]> | null : never
  } 
    : YearStudy
  : YearStudy


  type YearStudyCountArgs = Merge<
    Omit<YearStudyFindManyArgs, 'select' | 'include'> & {
      select?: YearStudyCountAggregateInputType | true
    }
  >

  export interface YearStudyDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one YearStudy that matches the filter.
     * @param {YearStudyFindUniqueArgs} args - Arguments to find a YearStudy
     * @example
     * // Get one YearStudy
     * const yearStudy = await prisma.yearStudy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YearStudyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YearStudyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YearStudy'> extends True ? CheckSelect<T, Prisma__YearStudyClient<YearStudy>, Prisma__YearStudyClient<YearStudyGetPayload<T>>> : CheckSelect<T, Prisma__YearStudyClient<YearStudy | null >, Prisma__YearStudyClient<YearStudyGetPayload<T> | null >>

    /**
     * Find the first YearStudy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearStudyFindFirstArgs} args - Arguments to find a YearStudy
     * @example
     * // Get one YearStudy
     * const yearStudy = await prisma.yearStudy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YearStudyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YearStudyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YearStudy'> extends True ? CheckSelect<T, Prisma__YearStudyClient<YearStudy>, Prisma__YearStudyClient<YearStudyGetPayload<T>>> : CheckSelect<T, Prisma__YearStudyClient<YearStudy | null >, Prisma__YearStudyClient<YearStudyGetPayload<T> | null >>

    /**
     * Find zero or more YearStudies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearStudyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YearStudies
     * const yearStudies = await prisma.yearStudy.findMany()
     * 
     * // Get first 10 YearStudies
     * const yearStudies = await prisma.yearStudy.findMany({ take: 10 })
     * 
     * // Only select the `idYearStudy`
     * const yearStudyWithIdYearStudyOnly = await prisma.yearStudy.findMany({ select: { idYearStudy: true } })
     * 
    **/
    findMany<T extends YearStudyFindManyArgs>(
      args?: SelectSubset<T, YearStudyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<YearStudy>>, PrismaPromise<Array<YearStudyGetPayload<T>>>>

    /**
     * Create a YearStudy.
     * @param {YearStudyCreateArgs} args - Arguments to create a YearStudy.
     * @example
     * // Create one YearStudy
     * const YearStudy = await prisma.yearStudy.create({
     *   data: {
     *     // ... data to create a YearStudy
     *   }
     * })
     * 
    **/
    create<T extends YearStudyCreateArgs>(
      args: SelectSubset<T, YearStudyCreateArgs>
    ): CheckSelect<T, Prisma__YearStudyClient<YearStudy>, Prisma__YearStudyClient<YearStudyGetPayload<T>>>

    /**
     * Create many YearStudies.
     *     @param {YearStudyCreateManyArgs} args - Arguments to create many YearStudies.
     *     @example
     *     // Create many YearStudies
     *     const yearStudy = await prisma.yearStudy.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YearStudyCreateManyArgs>(
      args?: SelectSubset<T, YearStudyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a YearStudy.
     * @param {YearStudyDeleteArgs} args - Arguments to delete one YearStudy.
     * @example
     * // Delete one YearStudy
     * const YearStudy = await prisma.yearStudy.delete({
     *   where: {
     *     // ... filter to delete one YearStudy
     *   }
     * })
     * 
    **/
    delete<T extends YearStudyDeleteArgs>(
      args: SelectSubset<T, YearStudyDeleteArgs>
    ): CheckSelect<T, Prisma__YearStudyClient<YearStudy>, Prisma__YearStudyClient<YearStudyGetPayload<T>>>

    /**
     * Update one YearStudy.
     * @param {YearStudyUpdateArgs} args - Arguments to update one YearStudy.
     * @example
     * // Update one YearStudy
     * const yearStudy = await prisma.yearStudy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YearStudyUpdateArgs>(
      args: SelectSubset<T, YearStudyUpdateArgs>
    ): CheckSelect<T, Prisma__YearStudyClient<YearStudy>, Prisma__YearStudyClient<YearStudyGetPayload<T>>>

    /**
     * Delete zero or more YearStudies.
     * @param {YearStudyDeleteManyArgs} args - Arguments to filter YearStudies to delete.
     * @example
     * // Delete a few YearStudies
     * const { count } = await prisma.yearStudy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YearStudyDeleteManyArgs>(
      args?: SelectSubset<T, YearStudyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more YearStudies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearStudyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YearStudies
     * const yearStudy = await prisma.yearStudy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YearStudyUpdateManyArgs>(
      args: SelectSubset<T, YearStudyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one YearStudy.
     * @param {YearStudyUpsertArgs} args - Arguments to update or create a YearStudy.
     * @example
     * // Update or create a YearStudy
     * const yearStudy = await prisma.yearStudy.upsert({
     *   create: {
     *     // ... data to create a YearStudy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YearStudy we want to update
     *   }
     * })
    **/
    upsert<T extends YearStudyUpsertArgs>(
      args: SelectSubset<T, YearStudyUpsertArgs>
    ): CheckSelect<T, Prisma__YearStudyClient<YearStudy>, Prisma__YearStudyClient<YearStudyGetPayload<T>>>

    /**
     * Count the number of YearStudies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearStudyCountArgs} args - Arguments to filter YearStudies to count.
     * @example
     * // Count the number of YearStudies
     * const count = await prisma.yearStudy.count({
     *   where: {
     *     // ... the filter for the YearStudies we want to count
     *   }
     * })
    **/
    count<T extends YearStudyCountArgs>(
      args?: Subset<T, YearStudyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YearStudyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YearStudy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearStudyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YearStudyAggregateArgs>(args: Subset<T, YearStudyAggregateArgs>): PrismaPromise<GetYearStudyAggregateType<T>>

    /**
     * Group by YearStudy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearStudyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YearStudyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YearStudyGroupByArgs['orderBy'] }
        : { orderBy?: YearStudyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YearStudyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYearStudyGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for YearStudy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YearStudyClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    StudentLevel<T extends StudentLevelFindManyArgs = {}>(args?: Subset<T, StudentLevelFindManyArgs>): CheckSelect<T, PrismaPromise<Array<StudentLevel>>, PrismaPromise<Array<StudentLevelGetPayload<T>>>>;

    Student<T extends StudentFindManyArgs = {}>(args?: Subset<T, StudentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Student>>, PrismaPromise<Array<StudentGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * YearStudy findUnique
   */
  export type YearStudyFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the YearStudy
     * 
    **/
    select?: YearStudySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: YearStudyInclude | null
    /**
     * Throw an Error if a YearStudy can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which YearStudy to fetch.
     * 
    **/
    where: YearStudyWhereUniqueInput
  }


  /**
   * YearStudy findFirst
   */
  export type YearStudyFindFirstArgs = {
    /**
     * Select specific fields to fetch from the YearStudy
     * 
    **/
    select?: YearStudySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: YearStudyInclude | null
    /**
     * Throw an Error if a YearStudy can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which YearStudy to fetch.
     * 
    **/
    where?: YearStudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearStudies to fetch.
     * 
    **/
    orderBy?: Enumerable<YearStudyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YearStudies.
     * 
    **/
    cursor?: YearStudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearStudies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearStudies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YearStudies.
     * 
    **/
    distinct?: Enumerable<YearStudyScalarFieldEnum>
  }


  /**
   * YearStudy findMany
   */
  export type YearStudyFindManyArgs = {
    /**
     * Select specific fields to fetch from the YearStudy
     * 
    **/
    select?: YearStudySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: YearStudyInclude | null
    /**
     * Filter, which YearStudies to fetch.
     * 
    **/
    where?: YearStudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearStudies to fetch.
     * 
    **/
    orderBy?: Enumerable<YearStudyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YearStudies.
     * 
    **/
    cursor?: YearStudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearStudies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearStudies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<YearStudyScalarFieldEnum>
  }


  /**
   * YearStudy create
   */
  export type YearStudyCreateArgs = {
    /**
     * Select specific fields to fetch from the YearStudy
     * 
    **/
    select?: YearStudySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: YearStudyInclude | null
    /**
     * The data needed to create a YearStudy.
     * 
    **/
    data: XOR<YearStudyCreateInput, YearStudyUncheckedCreateInput>
  }


  /**
   * YearStudy createMany
   */
  export type YearStudyCreateManyArgs = {
    data: Enumerable<YearStudyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YearStudy update
   */
  export type YearStudyUpdateArgs = {
    /**
     * Select specific fields to fetch from the YearStudy
     * 
    **/
    select?: YearStudySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: YearStudyInclude | null
    /**
     * The data needed to update a YearStudy.
     * 
    **/
    data: XOR<YearStudyUpdateInput, YearStudyUncheckedUpdateInput>
    /**
     * Choose, which YearStudy to update.
     * 
    **/
    where: YearStudyWhereUniqueInput
  }


  /**
   * YearStudy updateMany
   */
  export type YearStudyUpdateManyArgs = {
    data: XOR<YearStudyUpdateManyMutationInput, YearStudyUncheckedUpdateManyInput>
    where?: YearStudyWhereInput
  }


  /**
   * YearStudy upsert
   */
  export type YearStudyUpsertArgs = {
    /**
     * Select specific fields to fetch from the YearStudy
     * 
    **/
    select?: YearStudySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: YearStudyInclude | null
    /**
     * The filter to search for the YearStudy to update in case it exists.
     * 
    **/
    where: YearStudyWhereUniqueInput
    /**
     * In case the YearStudy found by the `where` argument doesn't exist, create a new YearStudy with this data.
     * 
    **/
    create: XOR<YearStudyCreateInput, YearStudyUncheckedCreateInput>
    /**
     * In case the YearStudy was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<YearStudyUpdateInput, YearStudyUncheckedUpdateInput>
  }


  /**
   * YearStudy delete
   */
  export type YearStudyDeleteArgs = {
    /**
     * Select specific fields to fetch from the YearStudy
     * 
    **/
    select?: YearStudySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: YearStudyInclude | null
    /**
     * Filter which YearStudy to delete.
     * 
    **/
    where: YearStudyWhereUniqueInput
  }


  /**
   * YearStudy deleteMany
   */
  export type YearStudyDeleteManyArgs = {
    where?: YearStudyWhereInput
  }


  /**
   * YearStudy without action
   */
  export type YearStudyArgs = {
    /**
     * Select specific fields to fetch from the YearStudy
     * 
    **/
    select?: YearStudySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: YearStudyInclude | null
  }



  /**
   * Model StudentResponsible
   */


  export type AggregateStudentResponsible = {
    _count: StudentResponsibleCountAggregateOutputType | null
    _avg: StudentResponsibleAvgAggregateOutputType | null
    _sum: StudentResponsibleSumAggregateOutputType | null
    _min: StudentResponsibleMinAggregateOutputType | null
    _max: StudentResponsibleMaxAggregateOutputType | null
  }

  export type StudentResponsibleAvgAggregateOutputType = {
    idStudentResponsible: number | null
    studentId: number | null
  }

  export type StudentResponsibleSumAggregateOutputType = {
    idStudentResponsible: number | null
    studentId: number | null
  }

  export type StudentResponsibleMinAggregateOutputType = {
    idStudentResponsible: number | null
    responsibleName: string | null
    responsiblePhone: string | null
    studentId: number | null
  }

  export type StudentResponsibleMaxAggregateOutputType = {
    idStudentResponsible: number | null
    responsibleName: string | null
    responsiblePhone: string | null
    studentId: number | null
  }

  export type StudentResponsibleCountAggregateOutputType = {
    idStudentResponsible: number
    responsibleName: number
    responsiblePhone: number
    studentId: number
    _all: number
  }


  export type StudentResponsibleAvgAggregateInputType = {
    idStudentResponsible?: true
    studentId?: true
  }

  export type StudentResponsibleSumAggregateInputType = {
    idStudentResponsible?: true
    studentId?: true
  }

  export type StudentResponsibleMinAggregateInputType = {
    idStudentResponsible?: true
    responsibleName?: true
    responsiblePhone?: true
    studentId?: true
  }

  export type StudentResponsibleMaxAggregateInputType = {
    idStudentResponsible?: true
    responsibleName?: true
    responsiblePhone?: true
    studentId?: true
  }

  export type StudentResponsibleCountAggregateInputType = {
    idStudentResponsible?: true
    responsibleName?: true
    responsiblePhone?: true
    studentId?: true
    _all?: true
  }

  export type StudentResponsibleAggregateArgs = {
    /**
     * Filter which StudentResponsible to aggregate.
     * 
    **/
    where?: StudentResponsibleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentResponsibles to fetch.
     * 
    **/
    orderBy?: Enumerable<StudentResponsibleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StudentResponsibleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentResponsibles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentResponsibles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentResponsibles
    **/
    _count?: true | StudentResponsibleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentResponsibleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentResponsibleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentResponsibleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentResponsibleMaxAggregateInputType
  }

  export type GetStudentResponsibleAggregateType<T extends StudentResponsibleAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentResponsible]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentResponsible[P]>
      : GetScalarType<T[P], AggregateStudentResponsible[P]>
  }


    
    
  export type StudentResponsibleGroupByArgs = {
    where?: StudentResponsibleWhereInput
    orderBy?: Enumerable<StudentResponsibleOrderByWithAggregationInput>
    by: Array<StudentResponsibleScalarFieldEnum>
    having?: StudentResponsibleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentResponsibleCountAggregateInputType | true
    _avg?: StudentResponsibleAvgAggregateInputType
    _sum?: StudentResponsibleSumAggregateInputType
    _min?: StudentResponsibleMinAggregateInputType
    _max?: StudentResponsibleMaxAggregateInputType
  }


  export type StudentResponsibleGroupByOutputType = {
    idStudentResponsible: number
    responsibleName: string
    responsiblePhone: string
    studentId: number
    _count: StudentResponsibleCountAggregateOutputType | null
    _avg: StudentResponsibleAvgAggregateOutputType | null
    _sum: StudentResponsibleSumAggregateOutputType | null
    _min: StudentResponsibleMinAggregateOutputType | null
    _max: StudentResponsibleMaxAggregateOutputType | null
  }

  type GetStudentResponsibleGroupByPayload<T extends StudentResponsibleGroupByArgs> = Promise<
    Array<
      PickArray<StudentResponsibleGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof StudentResponsibleGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], StudentResponsibleGroupByOutputType[P]> 
            : GetScalarType<T[P], StudentResponsibleGroupByOutputType[P]>
        }
      > 
    >


  export type StudentResponsibleSelect = {
    idStudentResponsible?: boolean
    responsibleName?: boolean
    responsiblePhone?: boolean
    student?: boolean | StudentArgs
    studentId?: boolean
  }

  export type StudentResponsibleInclude = {
    student?: boolean | StudentArgs
  }

  export type StudentResponsibleGetPayload<
    S extends boolean | null | undefined | StudentResponsibleArgs,
    U = keyof S
      > = S extends true
        ? StudentResponsible
    : S extends undefined
    ? never
    : S extends StudentResponsibleArgs | StudentResponsibleFindManyArgs
    ?'include' extends U
    ? StudentResponsible  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'student'
        ? StudentGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof StudentResponsible ?StudentResponsible [P]
  : 
          P extends 'student'
        ? StudentGetPayload<S['select'][P]> : never
  } 
    : StudentResponsible
  : StudentResponsible


  type StudentResponsibleCountArgs = Merge<
    Omit<StudentResponsibleFindManyArgs, 'select' | 'include'> & {
      select?: StudentResponsibleCountAggregateInputType | true
    }
  >

  export interface StudentResponsibleDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one StudentResponsible that matches the filter.
     * @param {StudentResponsibleFindUniqueArgs} args - Arguments to find a StudentResponsible
     * @example
     * // Get one StudentResponsible
     * const studentResponsible = await prisma.studentResponsible.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentResponsibleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StudentResponsibleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'StudentResponsible'> extends True ? CheckSelect<T, Prisma__StudentResponsibleClient<StudentResponsible>, Prisma__StudentResponsibleClient<StudentResponsibleGetPayload<T>>> : CheckSelect<T, Prisma__StudentResponsibleClient<StudentResponsible | null >, Prisma__StudentResponsibleClient<StudentResponsibleGetPayload<T> | null >>

    /**
     * Find the first StudentResponsible that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentResponsibleFindFirstArgs} args - Arguments to find a StudentResponsible
     * @example
     * // Get one StudentResponsible
     * const studentResponsible = await prisma.studentResponsible.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentResponsibleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StudentResponsibleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'StudentResponsible'> extends True ? CheckSelect<T, Prisma__StudentResponsibleClient<StudentResponsible>, Prisma__StudentResponsibleClient<StudentResponsibleGetPayload<T>>> : CheckSelect<T, Prisma__StudentResponsibleClient<StudentResponsible | null >, Prisma__StudentResponsibleClient<StudentResponsibleGetPayload<T> | null >>

    /**
     * Find zero or more StudentResponsibles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentResponsibleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentResponsibles
     * const studentResponsibles = await prisma.studentResponsible.findMany()
     * 
     * // Get first 10 StudentResponsibles
     * const studentResponsibles = await prisma.studentResponsible.findMany({ take: 10 })
     * 
     * // Only select the `idStudentResponsible`
     * const studentResponsibleWithIdStudentResponsibleOnly = await prisma.studentResponsible.findMany({ select: { idStudentResponsible: true } })
     * 
    **/
    findMany<T extends StudentResponsibleFindManyArgs>(
      args?: SelectSubset<T, StudentResponsibleFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<StudentResponsible>>, PrismaPromise<Array<StudentResponsibleGetPayload<T>>>>

    /**
     * Create a StudentResponsible.
     * @param {StudentResponsibleCreateArgs} args - Arguments to create a StudentResponsible.
     * @example
     * // Create one StudentResponsible
     * const StudentResponsible = await prisma.studentResponsible.create({
     *   data: {
     *     // ... data to create a StudentResponsible
     *   }
     * })
     * 
    **/
    create<T extends StudentResponsibleCreateArgs>(
      args: SelectSubset<T, StudentResponsibleCreateArgs>
    ): CheckSelect<T, Prisma__StudentResponsibleClient<StudentResponsible>, Prisma__StudentResponsibleClient<StudentResponsibleGetPayload<T>>>

    /**
     * Create many StudentResponsibles.
     *     @param {StudentResponsibleCreateManyArgs} args - Arguments to create many StudentResponsibles.
     *     @example
     *     // Create many StudentResponsibles
     *     const studentResponsible = await prisma.studentResponsible.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentResponsibleCreateManyArgs>(
      args?: SelectSubset<T, StudentResponsibleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a StudentResponsible.
     * @param {StudentResponsibleDeleteArgs} args - Arguments to delete one StudentResponsible.
     * @example
     * // Delete one StudentResponsible
     * const StudentResponsible = await prisma.studentResponsible.delete({
     *   where: {
     *     // ... filter to delete one StudentResponsible
     *   }
     * })
     * 
    **/
    delete<T extends StudentResponsibleDeleteArgs>(
      args: SelectSubset<T, StudentResponsibleDeleteArgs>
    ): CheckSelect<T, Prisma__StudentResponsibleClient<StudentResponsible>, Prisma__StudentResponsibleClient<StudentResponsibleGetPayload<T>>>

    /**
     * Update one StudentResponsible.
     * @param {StudentResponsibleUpdateArgs} args - Arguments to update one StudentResponsible.
     * @example
     * // Update one StudentResponsible
     * const studentResponsible = await prisma.studentResponsible.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentResponsibleUpdateArgs>(
      args: SelectSubset<T, StudentResponsibleUpdateArgs>
    ): CheckSelect<T, Prisma__StudentResponsibleClient<StudentResponsible>, Prisma__StudentResponsibleClient<StudentResponsibleGetPayload<T>>>

    /**
     * Delete zero or more StudentResponsibles.
     * @param {StudentResponsibleDeleteManyArgs} args - Arguments to filter StudentResponsibles to delete.
     * @example
     * // Delete a few StudentResponsibles
     * const { count } = await prisma.studentResponsible.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentResponsibleDeleteManyArgs>(
      args?: SelectSubset<T, StudentResponsibleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentResponsibles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentResponsibleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentResponsibles
     * const studentResponsible = await prisma.studentResponsible.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentResponsibleUpdateManyArgs>(
      args: SelectSubset<T, StudentResponsibleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentResponsible.
     * @param {StudentResponsibleUpsertArgs} args - Arguments to update or create a StudentResponsible.
     * @example
     * // Update or create a StudentResponsible
     * const studentResponsible = await prisma.studentResponsible.upsert({
     *   create: {
     *     // ... data to create a StudentResponsible
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentResponsible we want to update
     *   }
     * })
    **/
    upsert<T extends StudentResponsibleUpsertArgs>(
      args: SelectSubset<T, StudentResponsibleUpsertArgs>
    ): CheckSelect<T, Prisma__StudentResponsibleClient<StudentResponsible>, Prisma__StudentResponsibleClient<StudentResponsibleGetPayload<T>>>

    /**
     * Count the number of StudentResponsibles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentResponsibleCountArgs} args - Arguments to filter StudentResponsibles to count.
     * @example
     * // Count the number of StudentResponsibles
     * const count = await prisma.studentResponsible.count({
     *   where: {
     *     // ... the filter for the StudentResponsibles we want to count
     *   }
     * })
    **/
    count<T extends StudentResponsibleCountArgs>(
      args?: Subset<T, StudentResponsibleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentResponsibleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentResponsible.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentResponsibleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentResponsibleAggregateArgs>(args: Subset<T, StudentResponsibleAggregateArgs>): PrismaPromise<GetStudentResponsibleAggregateType<T>>

    /**
     * Group by StudentResponsible.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentResponsibleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentResponsibleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentResponsibleGroupByArgs['orderBy'] }
        : { orderBy?: StudentResponsibleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentResponsibleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentResponsibleGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentResponsible.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StudentResponsibleClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    student<T extends StudentArgs = {}>(args?: Subset<T, StudentArgs>): CheckSelect<T, Prisma__StudentClient<Student | null >, Prisma__StudentClient<StudentGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * StudentResponsible findUnique
   */
  export type StudentResponsibleFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the StudentResponsible
     * 
    **/
    select?: StudentResponsibleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentResponsibleInclude | null
    /**
     * Throw an Error if a StudentResponsible can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which StudentResponsible to fetch.
     * 
    **/
    where: StudentResponsibleWhereUniqueInput
  }


  /**
   * StudentResponsible findFirst
   */
  export type StudentResponsibleFindFirstArgs = {
    /**
     * Select specific fields to fetch from the StudentResponsible
     * 
    **/
    select?: StudentResponsibleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentResponsibleInclude | null
    /**
     * Throw an Error if a StudentResponsible can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which StudentResponsible to fetch.
     * 
    **/
    where?: StudentResponsibleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentResponsibles to fetch.
     * 
    **/
    orderBy?: Enumerable<StudentResponsibleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentResponsibles.
     * 
    **/
    cursor?: StudentResponsibleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentResponsibles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentResponsibles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentResponsibles.
     * 
    **/
    distinct?: Enumerable<StudentResponsibleScalarFieldEnum>
  }


  /**
   * StudentResponsible findMany
   */
  export type StudentResponsibleFindManyArgs = {
    /**
     * Select specific fields to fetch from the StudentResponsible
     * 
    **/
    select?: StudentResponsibleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentResponsibleInclude | null
    /**
     * Filter, which StudentResponsibles to fetch.
     * 
    **/
    where?: StudentResponsibleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentResponsibles to fetch.
     * 
    **/
    orderBy?: Enumerable<StudentResponsibleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentResponsibles.
     * 
    **/
    cursor?: StudentResponsibleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentResponsibles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentResponsibles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StudentResponsibleScalarFieldEnum>
  }


  /**
   * StudentResponsible create
   */
  export type StudentResponsibleCreateArgs = {
    /**
     * Select specific fields to fetch from the StudentResponsible
     * 
    **/
    select?: StudentResponsibleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentResponsibleInclude | null
    /**
     * The data needed to create a StudentResponsible.
     * 
    **/
    data: XOR<StudentResponsibleCreateInput, StudentResponsibleUncheckedCreateInput>
  }


  /**
   * StudentResponsible createMany
   */
  export type StudentResponsibleCreateManyArgs = {
    data: Enumerable<StudentResponsibleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * StudentResponsible update
   */
  export type StudentResponsibleUpdateArgs = {
    /**
     * Select specific fields to fetch from the StudentResponsible
     * 
    **/
    select?: StudentResponsibleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentResponsibleInclude | null
    /**
     * The data needed to update a StudentResponsible.
     * 
    **/
    data: XOR<StudentResponsibleUpdateInput, StudentResponsibleUncheckedUpdateInput>
    /**
     * Choose, which StudentResponsible to update.
     * 
    **/
    where: StudentResponsibleWhereUniqueInput
  }


  /**
   * StudentResponsible updateMany
   */
  export type StudentResponsibleUpdateManyArgs = {
    data: XOR<StudentResponsibleUpdateManyMutationInput, StudentResponsibleUncheckedUpdateManyInput>
    where?: StudentResponsibleWhereInput
  }


  /**
   * StudentResponsible upsert
   */
  export type StudentResponsibleUpsertArgs = {
    /**
     * Select specific fields to fetch from the StudentResponsible
     * 
    **/
    select?: StudentResponsibleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentResponsibleInclude | null
    /**
     * The filter to search for the StudentResponsible to update in case it exists.
     * 
    **/
    where: StudentResponsibleWhereUniqueInput
    /**
     * In case the StudentResponsible found by the `where` argument doesn't exist, create a new StudentResponsible with this data.
     * 
    **/
    create: XOR<StudentResponsibleCreateInput, StudentResponsibleUncheckedCreateInput>
    /**
     * In case the StudentResponsible was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StudentResponsibleUpdateInput, StudentResponsibleUncheckedUpdateInput>
  }


  /**
   * StudentResponsible delete
   */
  export type StudentResponsibleDeleteArgs = {
    /**
     * Select specific fields to fetch from the StudentResponsible
     * 
    **/
    select?: StudentResponsibleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentResponsibleInclude | null
    /**
     * Filter which StudentResponsible to delete.
     * 
    **/
    where: StudentResponsibleWhereUniqueInput
  }


  /**
   * StudentResponsible deleteMany
   */
  export type StudentResponsibleDeleteManyArgs = {
    where?: StudentResponsibleWhereInput
  }


  /**
   * StudentResponsible without action
   */
  export type StudentResponsibleArgs = {
    /**
     * Select specific fields to fetch from the StudentResponsible
     * 
    **/
    select?: StudentResponsibleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentResponsibleInclude | null
  }



  /**
   * Model NationalityCertificate
   */


  export type AggregateNationalityCertificate = {
    _count: NationalityCertificateCountAggregateOutputType | null
    _avg: NationalityCertificateAvgAggregateOutputType | null
    _sum: NationalityCertificateSumAggregateOutputType | null
    _min: NationalityCertificateMinAggregateOutputType | null
    _max: NationalityCertificateMaxAggregateOutputType | null
  }

  export type NationalityCertificateAvgAggregateOutputType = {
    idNationalityCertificate: number | null
    studentId: number | null
  }

  export type NationalityCertificateSumAggregateOutputType = {
    idNationalityCertificate: number | null
    studentId: number | null
  }

  export type NationalityCertificateMinAggregateOutputType = {
    idNationalityCertificate: number | null
    nationalityNumber: string | null
    nationalityIssue: string | null
    nationalityPlace: string | null
    studentId: number | null
  }

  export type NationalityCertificateMaxAggregateOutputType = {
    idNationalityCertificate: number | null
    nationalityNumber: string | null
    nationalityIssue: string | null
    nationalityPlace: string | null
    studentId: number | null
  }

  export type NationalityCertificateCountAggregateOutputType = {
    idNationalityCertificate: number
    nationalityNumber: number
    nationalityIssue: number
    nationalityPlace: number
    studentId: number
    _all: number
  }


  export type NationalityCertificateAvgAggregateInputType = {
    idNationalityCertificate?: true
    studentId?: true
  }

  export type NationalityCertificateSumAggregateInputType = {
    idNationalityCertificate?: true
    studentId?: true
  }

  export type NationalityCertificateMinAggregateInputType = {
    idNationalityCertificate?: true
    nationalityNumber?: true
    nationalityIssue?: true
    nationalityPlace?: true
    studentId?: true
  }

  export type NationalityCertificateMaxAggregateInputType = {
    idNationalityCertificate?: true
    nationalityNumber?: true
    nationalityIssue?: true
    nationalityPlace?: true
    studentId?: true
  }

  export type NationalityCertificateCountAggregateInputType = {
    idNationalityCertificate?: true
    nationalityNumber?: true
    nationalityIssue?: true
    nationalityPlace?: true
    studentId?: true
    _all?: true
  }

  export type NationalityCertificateAggregateArgs = {
    /**
     * Filter which NationalityCertificate to aggregate.
     * 
    **/
    where?: NationalityCertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NationalityCertificates to fetch.
     * 
    **/
    orderBy?: Enumerable<NationalityCertificateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: NationalityCertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NationalityCertificates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NationalityCertificates.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NationalityCertificates
    **/
    _count?: true | NationalityCertificateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NationalityCertificateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NationalityCertificateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NationalityCertificateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NationalityCertificateMaxAggregateInputType
  }

  export type GetNationalityCertificateAggregateType<T extends NationalityCertificateAggregateArgs> = {
        [P in keyof T & keyof AggregateNationalityCertificate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNationalityCertificate[P]>
      : GetScalarType<T[P], AggregateNationalityCertificate[P]>
  }


    
    
  export type NationalityCertificateGroupByArgs = {
    where?: NationalityCertificateWhereInput
    orderBy?: Enumerable<NationalityCertificateOrderByWithAggregationInput>
    by: Array<NationalityCertificateScalarFieldEnum>
    having?: NationalityCertificateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NationalityCertificateCountAggregateInputType | true
    _avg?: NationalityCertificateAvgAggregateInputType
    _sum?: NationalityCertificateSumAggregateInputType
    _min?: NationalityCertificateMinAggregateInputType
    _max?: NationalityCertificateMaxAggregateInputType
  }


  export type NationalityCertificateGroupByOutputType = {
    idNationalityCertificate: number
    nationalityNumber: string
    nationalityIssue: string
    nationalityPlace: string
    studentId: number
    _count: NationalityCertificateCountAggregateOutputType | null
    _avg: NationalityCertificateAvgAggregateOutputType | null
    _sum: NationalityCertificateSumAggregateOutputType | null
    _min: NationalityCertificateMinAggregateOutputType | null
    _max: NationalityCertificateMaxAggregateOutputType | null
  }

  type GetNationalityCertificateGroupByPayload<T extends NationalityCertificateGroupByArgs> = Promise<
    Array<
      PickArray<NationalityCertificateGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof NationalityCertificateGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], NationalityCertificateGroupByOutputType[P]> 
            : GetScalarType<T[P], NationalityCertificateGroupByOutputType[P]>
        }
      > 
    >


  export type NationalityCertificateSelect = {
    idNationalityCertificate?: boolean
    nationalityNumber?: boolean
    nationalityIssue?: boolean
    nationalityPlace?: boolean
    student?: boolean | StudentArgs
    studentId?: boolean
  }

  export type NationalityCertificateInclude = {
    student?: boolean | StudentArgs
  }

  export type NationalityCertificateGetPayload<
    S extends boolean | null | undefined | NationalityCertificateArgs,
    U = keyof S
      > = S extends true
        ? NationalityCertificate
    : S extends undefined
    ? never
    : S extends NationalityCertificateArgs | NationalityCertificateFindManyArgs
    ?'include' extends U
    ? NationalityCertificate  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'student'
        ? StudentGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof NationalityCertificate ?NationalityCertificate [P]
  : 
          P extends 'student'
        ? StudentGetPayload<S['select'][P]> : never
  } 
    : NationalityCertificate
  : NationalityCertificate


  type NationalityCertificateCountArgs = Merge<
    Omit<NationalityCertificateFindManyArgs, 'select' | 'include'> & {
      select?: NationalityCertificateCountAggregateInputType | true
    }
  >

  export interface NationalityCertificateDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one NationalityCertificate that matches the filter.
     * @param {NationalityCertificateFindUniqueArgs} args - Arguments to find a NationalityCertificate
     * @example
     * // Get one NationalityCertificate
     * const nationalityCertificate = await prisma.nationalityCertificate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NationalityCertificateFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NationalityCertificateFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'NationalityCertificate'> extends True ? CheckSelect<T, Prisma__NationalityCertificateClient<NationalityCertificate>, Prisma__NationalityCertificateClient<NationalityCertificateGetPayload<T>>> : CheckSelect<T, Prisma__NationalityCertificateClient<NationalityCertificate | null >, Prisma__NationalityCertificateClient<NationalityCertificateGetPayload<T> | null >>

    /**
     * Find the first NationalityCertificate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NationalityCertificateFindFirstArgs} args - Arguments to find a NationalityCertificate
     * @example
     * // Get one NationalityCertificate
     * const nationalityCertificate = await prisma.nationalityCertificate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NationalityCertificateFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NationalityCertificateFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'NationalityCertificate'> extends True ? CheckSelect<T, Prisma__NationalityCertificateClient<NationalityCertificate>, Prisma__NationalityCertificateClient<NationalityCertificateGetPayload<T>>> : CheckSelect<T, Prisma__NationalityCertificateClient<NationalityCertificate | null >, Prisma__NationalityCertificateClient<NationalityCertificateGetPayload<T> | null >>

    /**
     * Find zero or more NationalityCertificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NationalityCertificateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NationalityCertificates
     * const nationalityCertificates = await prisma.nationalityCertificate.findMany()
     * 
     * // Get first 10 NationalityCertificates
     * const nationalityCertificates = await prisma.nationalityCertificate.findMany({ take: 10 })
     * 
     * // Only select the `idNationalityCertificate`
     * const nationalityCertificateWithIdNationalityCertificateOnly = await prisma.nationalityCertificate.findMany({ select: { idNationalityCertificate: true } })
     * 
    **/
    findMany<T extends NationalityCertificateFindManyArgs>(
      args?: SelectSubset<T, NationalityCertificateFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<NationalityCertificate>>, PrismaPromise<Array<NationalityCertificateGetPayload<T>>>>

    /**
     * Create a NationalityCertificate.
     * @param {NationalityCertificateCreateArgs} args - Arguments to create a NationalityCertificate.
     * @example
     * // Create one NationalityCertificate
     * const NationalityCertificate = await prisma.nationalityCertificate.create({
     *   data: {
     *     // ... data to create a NationalityCertificate
     *   }
     * })
     * 
    **/
    create<T extends NationalityCertificateCreateArgs>(
      args: SelectSubset<T, NationalityCertificateCreateArgs>
    ): CheckSelect<T, Prisma__NationalityCertificateClient<NationalityCertificate>, Prisma__NationalityCertificateClient<NationalityCertificateGetPayload<T>>>

    /**
     * Create many NationalityCertificates.
     *     @param {NationalityCertificateCreateManyArgs} args - Arguments to create many NationalityCertificates.
     *     @example
     *     // Create many NationalityCertificates
     *     const nationalityCertificate = await prisma.nationalityCertificate.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NationalityCertificateCreateManyArgs>(
      args?: SelectSubset<T, NationalityCertificateCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a NationalityCertificate.
     * @param {NationalityCertificateDeleteArgs} args - Arguments to delete one NationalityCertificate.
     * @example
     * // Delete one NationalityCertificate
     * const NationalityCertificate = await prisma.nationalityCertificate.delete({
     *   where: {
     *     // ... filter to delete one NationalityCertificate
     *   }
     * })
     * 
    **/
    delete<T extends NationalityCertificateDeleteArgs>(
      args: SelectSubset<T, NationalityCertificateDeleteArgs>
    ): CheckSelect<T, Prisma__NationalityCertificateClient<NationalityCertificate>, Prisma__NationalityCertificateClient<NationalityCertificateGetPayload<T>>>

    /**
     * Update one NationalityCertificate.
     * @param {NationalityCertificateUpdateArgs} args - Arguments to update one NationalityCertificate.
     * @example
     * // Update one NationalityCertificate
     * const nationalityCertificate = await prisma.nationalityCertificate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NationalityCertificateUpdateArgs>(
      args: SelectSubset<T, NationalityCertificateUpdateArgs>
    ): CheckSelect<T, Prisma__NationalityCertificateClient<NationalityCertificate>, Prisma__NationalityCertificateClient<NationalityCertificateGetPayload<T>>>

    /**
     * Delete zero or more NationalityCertificates.
     * @param {NationalityCertificateDeleteManyArgs} args - Arguments to filter NationalityCertificates to delete.
     * @example
     * // Delete a few NationalityCertificates
     * const { count } = await prisma.nationalityCertificate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NationalityCertificateDeleteManyArgs>(
      args?: SelectSubset<T, NationalityCertificateDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more NationalityCertificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NationalityCertificateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NationalityCertificates
     * const nationalityCertificate = await prisma.nationalityCertificate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NationalityCertificateUpdateManyArgs>(
      args: SelectSubset<T, NationalityCertificateUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one NationalityCertificate.
     * @param {NationalityCertificateUpsertArgs} args - Arguments to update or create a NationalityCertificate.
     * @example
     * // Update or create a NationalityCertificate
     * const nationalityCertificate = await prisma.nationalityCertificate.upsert({
     *   create: {
     *     // ... data to create a NationalityCertificate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NationalityCertificate we want to update
     *   }
     * })
    **/
    upsert<T extends NationalityCertificateUpsertArgs>(
      args: SelectSubset<T, NationalityCertificateUpsertArgs>
    ): CheckSelect<T, Prisma__NationalityCertificateClient<NationalityCertificate>, Prisma__NationalityCertificateClient<NationalityCertificateGetPayload<T>>>

    /**
     * Count the number of NationalityCertificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NationalityCertificateCountArgs} args - Arguments to filter NationalityCertificates to count.
     * @example
     * // Count the number of NationalityCertificates
     * const count = await prisma.nationalityCertificate.count({
     *   where: {
     *     // ... the filter for the NationalityCertificates we want to count
     *   }
     * })
    **/
    count<T extends NationalityCertificateCountArgs>(
      args?: Subset<T, NationalityCertificateCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NationalityCertificateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NationalityCertificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NationalityCertificateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NationalityCertificateAggregateArgs>(args: Subset<T, NationalityCertificateAggregateArgs>): PrismaPromise<GetNationalityCertificateAggregateType<T>>

    /**
     * Group by NationalityCertificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NationalityCertificateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NationalityCertificateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NationalityCertificateGroupByArgs['orderBy'] }
        : { orderBy?: NationalityCertificateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NationalityCertificateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNationalityCertificateGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for NationalityCertificate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NationalityCertificateClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    student<T extends StudentArgs = {}>(args?: Subset<T, StudentArgs>): CheckSelect<T, Prisma__StudentClient<Student | null >, Prisma__StudentClient<StudentGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * NationalityCertificate findUnique
   */
  export type NationalityCertificateFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the NationalityCertificate
     * 
    **/
    select?: NationalityCertificateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NationalityCertificateInclude | null
    /**
     * Throw an Error if a NationalityCertificate can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which NationalityCertificate to fetch.
     * 
    **/
    where: NationalityCertificateWhereUniqueInput
  }


  /**
   * NationalityCertificate findFirst
   */
  export type NationalityCertificateFindFirstArgs = {
    /**
     * Select specific fields to fetch from the NationalityCertificate
     * 
    **/
    select?: NationalityCertificateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NationalityCertificateInclude | null
    /**
     * Throw an Error if a NationalityCertificate can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which NationalityCertificate to fetch.
     * 
    **/
    where?: NationalityCertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NationalityCertificates to fetch.
     * 
    **/
    orderBy?: Enumerable<NationalityCertificateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NationalityCertificates.
     * 
    **/
    cursor?: NationalityCertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NationalityCertificates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NationalityCertificates.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NationalityCertificates.
     * 
    **/
    distinct?: Enumerable<NationalityCertificateScalarFieldEnum>
  }


  /**
   * NationalityCertificate findMany
   */
  export type NationalityCertificateFindManyArgs = {
    /**
     * Select specific fields to fetch from the NationalityCertificate
     * 
    **/
    select?: NationalityCertificateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NationalityCertificateInclude | null
    /**
     * Filter, which NationalityCertificates to fetch.
     * 
    **/
    where?: NationalityCertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NationalityCertificates to fetch.
     * 
    **/
    orderBy?: Enumerable<NationalityCertificateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NationalityCertificates.
     * 
    **/
    cursor?: NationalityCertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NationalityCertificates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NationalityCertificates.
     * 
    **/
    skip?: number
    distinct?: Enumerable<NationalityCertificateScalarFieldEnum>
  }


  /**
   * NationalityCertificate create
   */
  export type NationalityCertificateCreateArgs = {
    /**
     * Select specific fields to fetch from the NationalityCertificate
     * 
    **/
    select?: NationalityCertificateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NationalityCertificateInclude | null
    /**
     * The data needed to create a NationalityCertificate.
     * 
    **/
    data: XOR<NationalityCertificateCreateInput, NationalityCertificateUncheckedCreateInput>
  }


  /**
   * NationalityCertificate createMany
   */
  export type NationalityCertificateCreateManyArgs = {
    data: Enumerable<NationalityCertificateCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * NationalityCertificate update
   */
  export type NationalityCertificateUpdateArgs = {
    /**
     * Select specific fields to fetch from the NationalityCertificate
     * 
    **/
    select?: NationalityCertificateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NationalityCertificateInclude | null
    /**
     * The data needed to update a NationalityCertificate.
     * 
    **/
    data: XOR<NationalityCertificateUpdateInput, NationalityCertificateUncheckedUpdateInput>
    /**
     * Choose, which NationalityCertificate to update.
     * 
    **/
    where: NationalityCertificateWhereUniqueInput
  }


  /**
   * NationalityCertificate updateMany
   */
  export type NationalityCertificateUpdateManyArgs = {
    data: XOR<NationalityCertificateUpdateManyMutationInput, NationalityCertificateUncheckedUpdateManyInput>
    where?: NationalityCertificateWhereInput
  }


  /**
   * NationalityCertificate upsert
   */
  export type NationalityCertificateUpsertArgs = {
    /**
     * Select specific fields to fetch from the NationalityCertificate
     * 
    **/
    select?: NationalityCertificateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NationalityCertificateInclude | null
    /**
     * The filter to search for the NationalityCertificate to update in case it exists.
     * 
    **/
    where: NationalityCertificateWhereUniqueInput
    /**
     * In case the NationalityCertificate found by the `where` argument doesn't exist, create a new NationalityCertificate with this data.
     * 
    **/
    create: XOR<NationalityCertificateCreateInput, NationalityCertificateUncheckedCreateInput>
    /**
     * In case the NationalityCertificate was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<NationalityCertificateUpdateInput, NationalityCertificateUncheckedUpdateInput>
  }


  /**
   * NationalityCertificate delete
   */
  export type NationalityCertificateDeleteArgs = {
    /**
     * Select specific fields to fetch from the NationalityCertificate
     * 
    **/
    select?: NationalityCertificateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NationalityCertificateInclude | null
    /**
     * Filter which NationalityCertificate to delete.
     * 
    **/
    where: NationalityCertificateWhereUniqueInput
  }


  /**
   * NationalityCertificate deleteMany
   */
  export type NationalityCertificateDeleteManyArgs = {
    where?: NationalityCertificateWhereInput
  }


  /**
   * NationalityCertificate without action
   */
  export type NationalityCertificateArgs = {
    /**
     * Select specific fields to fetch from the NationalityCertificate
     * 
    **/
    select?: NationalityCertificateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NationalityCertificateInclude | null
  }



  /**
   * Model NationalInfo
   */


  export type AggregateNationalInfo = {
    _count: NationalInfoCountAggregateOutputType | null
    _avg: NationalInfoAvgAggregateOutputType | null
    _sum: NationalInfoSumAggregateOutputType | null
    _min: NationalInfoMinAggregateOutputType | null
    _max: NationalInfoMaxAggregateOutputType | null
  }

  export type NationalInfoAvgAggregateOutputType = {
    idNationalInfo: number | null
    studentId: number | null
  }

  export type NationalInfoSumAggregateOutputType = {
    idNationalInfo: number | null
    studentId: number | null
  }

  export type NationalInfoMinAggregateOutputType = {
    idNationalInfo: number | null
    nationalNumber: string | null
    issueNumber: string | null
    issuePlace: string | null
    studentId: number | null
  }

  export type NationalInfoMaxAggregateOutputType = {
    idNationalInfo: number | null
    nationalNumber: string | null
    issueNumber: string | null
    issuePlace: string | null
    studentId: number | null
  }

  export type NationalInfoCountAggregateOutputType = {
    idNationalInfo: number
    nationalNumber: number
    issueNumber: number
    issuePlace: number
    studentId: number
    _all: number
  }


  export type NationalInfoAvgAggregateInputType = {
    idNationalInfo?: true
    studentId?: true
  }

  export type NationalInfoSumAggregateInputType = {
    idNationalInfo?: true
    studentId?: true
  }

  export type NationalInfoMinAggregateInputType = {
    idNationalInfo?: true
    nationalNumber?: true
    issueNumber?: true
    issuePlace?: true
    studentId?: true
  }

  export type NationalInfoMaxAggregateInputType = {
    idNationalInfo?: true
    nationalNumber?: true
    issueNumber?: true
    issuePlace?: true
    studentId?: true
  }

  export type NationalInfoCountAggregateInputType = {
    idNationalInfo?: true
    nationalNumber?: true
    issueNumber?: true
    issuePlace?: true
    studentId?: true
    _all?: true
  }

  export type NationalInfoAggregateArgs = {
    /**
     * Filter which NationalInfo to aggregate.
     * 
    **/
    where?: NationalInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NationalInfos to fetch.
     * 
    **/
    orderBy?: Enumerable<NationalInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: NationalInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NationalInfos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NationalInfos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NationalInfos
    **/
    _count?: true | NationalInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NationalInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NationalInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NationalInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NationalInfoMaxAggregateInputType
  }

  export type GetNationalInfoAggregateType<T extends NationalInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateNationalInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNationalInfo[P]>
      : GetScalarType<T[P], AggregateNationalInfo[P]>
  }


    
    
  export type NationalInfoGroupByArgs = {
    where?: NationalInfoWhereInput
    orderBy?: Enumerable<NationalInfoOrderByWithAggregationInput>
    by: Array<NationalInfoScalarFieldEnum>
    having?: NationalInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NationalInfoCountAggregateInputType | true
    _avg?: NationalInfoAvgAggregateInputType
    _sum?: NationalInfoSumAggregateInputType
    _min?: NationalInfoMinAggregateInputType
    _max?: NationalInfoMaxAggregateInputType
  }


  export type NationalInfoGroupByOutputType = {
    idNationalInfo: number
    nationalNumber: string
    issueNumber: string
    issuePlace: string
    studentId: number
    _count: NationalInfoCountAggregateOutputType | null
    _avg: NationalInfoAvgAggregateOutputType | null
    _sum: NationalInfoSumAggregateOutputType | null
    _min: NationalInfoMinAggregateOutputType | null
    _max: NationalInfoMaxAggregateOutputType | null
  }

  type GetNationalInfoGroupByPayload<T extends NationalInfoGroupByArgs> = Promise<
    Array<
      PickArray<NationalInfoGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof NationalInfoGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], NationalInfoGroupByOutputType[P]> 
            : GetScalarType<T[P], NationalInfoGroupByOutputType[P]>
        }
      > 
    >


  export type NationalInfoSelect = {
    idNationalInfo?: boolean
    nationalNumber?: boolean
    issueNumber?: boolean
    issuePlace?: boolean
    student?: boolean | StudentArgs
    studentId?: boolean
  }

  export type NationalInfoInclude = {
    student?: boolean | StudentArgs
  }

  export type NationalInfoGetPayload<
    S extends boolean | null | undefined | NationalInfoArgs,
    U = keyof S
      > = S extends true
        ? NationalInfo
    : S extends undefined
    ? never
    : S extends NationalInfoArgs | NationalInfoFindManyArgs
    ?'include' extends U
    ? NationalInfo  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'student'
        ? StudentGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof NationalInfo ?NationalInfo [P]
  : 
          P extends 'student'
        ? StudentGetPayload<S['select'][P]> : never
  } 
    : NationalInfo
  : NationalInfo


  type NationalInfoCountArgs = Merge<
    Omit<NationalInfoFindManyArgs, 'select' | 'include'> & {
      select?: NationalInfoCountAggregateInputType | true
    }
  >

  export interface NationalInfoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one NationalInfo that matches the filter.
     * @param {NationalInfoFindUniqueArgs} args - Arguments to find a NationalInfo
     * @example
     * // Get one NationalInfo
     * const nationalInfo = await prisma.nationalInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NationalInfoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NationalInfoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'NationalInfo'> extends True ? CheckSelect<T, Prisma__NationalInfoClient<NationalInfo>, Prisma__NationalInfoClient<NationalInfoGetPayload<T>>> : CheckSelect<T, Prisma__NationalInfoClient<NationalInfo | null >, Prisma__NationalInfoClient<NationalInfoGetPayload<T> | null >>

    /**
     * Find the first NationalInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NationalInfoFindFirstArgs} args - Arguments to find a NationalInfo
     * @example
     * // Get one NationalInfo
     * const nationalInfo = await prisma.nationalInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NationalInfoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NationalInfoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'NationalInfo'> extends True ? CheckSelect<T, Prisma__NationalInfoClient<NationalInfo>, Prisma__NationalInfoClient<NationalInfoGetPayload<T>>> : CheckSelect<T, Prisma__NationalInfoClient<NationalInfo | null >, Prisma__NationalInfoClient<NationalInfoGetPayload<T> | null >>

    /**
     * Find zero or more NationalInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NationalInfoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NationalInfos
     * const nationalInfos = await prisma.nationalInfo.findMany()
     * 
     * // Get first 10 NationalInfos
     * const nationalInfos = await prisma.nationalInfo.findMany({ take: 10 })
     * 
     * // Only select the `idNationalInfo`
     * const nationalInfoWithIdNationalInfoOnly = await prisma.nationalInfo.findMany({ select: { idNationalInfo: true } })
     * 
    **/
    findMany<T extends NationalInfoFindManyArgs>(
      args?: SelectSubset<T, NationalInfoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<NationalInfo>>, PrismaPromise<Array<NationalInfoGetPayload<T>>>>

    /**
     * Create a NationalInfo.
     * @param {NationalInfoCreateArgs} args - Arguments to create a NationalInfo.
     * @example
     * // Create one NationalInfo
     * const NationalInfo = await prisma.nationalInfo.create({
     *   data: {
     *     // ... data to create a NationalInfo
     *   }
     * })
     * 
    **/
    create<T extends NationalInfoCreateArgs>(
      args: SelectSubset<T, NationalInfoCreateArgs>
    ): CheckSelect<T, Prisma__NationalInfoClient<NationalInfo>, Prisma__NationalInfoClient<NationalInfoGetPayload<T>>>

    /**
     * Create many NationalInfos.
     *     @param {NationalInfoCreateManyArgs} args - Arguments to create many NationalInfos.
     *     @example
     *     // Create many NationalInfos
     *     const nationalInfo = await prisma.nationalInfo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NationalInfoCreateManyArgs>(
      args?: SelectSubset<T, NationalInfoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a NationalInfo.
     * @param {NationalInfoDeleteArgs} args - Arguments to delete one NationalInfo.
     * @example
     * // Delete one NationalInfo
     * const NationalInfo = await prisma.nationalInfo.delete({
     *   where: {
     *     // ... filter to delete one NationalInfo
     *   }
     * })
     * 
    **/
    delete<T extends NationalInfoDeleteArgs>(
      args: SelectSubset<T, NationalInfoDeleteArgs>
    ): CheckSelect<T, Prisma__NationalInfoClient<NationalInfo>, Prisma__NationalInfoClient<NationalInfoGetPayload<T>>>

    /**
     * Update one NationalInfo.
     * @param {NationalInfoUpdateArgs} args - Arguments to update one NationalInfo.
     * @example
     * // Update one NationalInfo
     * const nationalInfo = await prisma.nationalInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NationalInfoUpdateArgs>(
      args: SelectSubset<T, NationalInfoUpdateArgs>
    ): CheckSelect<T, Prisma__NationalInfoClient<NationalInfo>, Prisma__NationalInfoClient<NationalInfoGetPayload<T>>>

    /**
     * Delete zero or more NationalInfos.
     * @param {NationalInfoDeleteManyArgs} args - Arguments to filter NationalInfos to delete.
     * @example
     * // Delete a few NationalInfos
     * const { count } = await prisma.nationalInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NationalInfoDeleteManyArgs>(
      args?: SelectSubset<T, NationalInfoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more NationalInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NationalInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NationalInfos
     * const nationalInfo = await prisma.nationalInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NationalInfoUpdateManyArgs>(
      args: SelectSubset<T, NationalInfoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one NationalInfo.
     * @param {NationalInfoUpsertArgs} args - Arguments to update or create a NationalInfo.
     * @example
     * // Update or create a NationalInfo
     * const nationalInfo = await prisma.nationalInfo.upsert({
     *   create: {
     *     // ... data to create a NationalInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NationalInfo we want to update
     *   }
     * })
    **/
    upsert<T extends NationalInfoUpsertArgs>(
      args: SelectSubset<T, NationalInfoUpsertArgs>
    ): CheckSelect<T, Prisma__NationalInfoClient<NationalInfo>, Prisma__NationalInfoClient<NationalInfoGetPayload<T>>>

    /**
     * Count the number of NationalInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NationalInfoCountArgs} args - Arguments to filter NationalInfos to count.
     * @example
     * // Count the number of NationalInfos
     * const count = await prisma.nationalInfo.count({
     *   where: {
     *     // ... the filter for the NationalInfos we want to count
     *   }
     * })
    **/
    count<T extends NationalInfoCountArgs>(
      args?: Subset<T, NationalInfoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NationalInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NationalInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NationalInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NationalInfoAggregateArgs>(args: Subset<T, NationalInfoAggregateArgs>): PrismaPromise<GetNationalInfoAggregateType<T>>

    /**
     * Group by NationalInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NationalInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NationalInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NationalInfoGroupByArgs['orderBy'] }
        : { orderBy?: NationalInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NationalInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNationalInfoGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for NationalInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NationalInfoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    student<T extends StudentArgs = {}>(args?: Subset<T, StudentArgs>): CheckSelect<T, Prisma__StudentClient<Student | null >, Prisma__StudentClient<StudentGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * NationalInfo findUnique
   */
  export type NationalInfoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the NationalInfo
     * 
    **/
    select?: NationalInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NationalInfoInclude | null
    /**
     * Throw an Error if a NationalInfo can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which NationalInfo to fetch.
     * 
    **/
    where: NationalInfoWhereUniqueInput
  }


  /**
   * NationalInfo findFirst
   */
  export type NationalInfoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the NationalInfo
     * 
    **/
    select?: NationalInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NationalInfoInclude | null
    /**
     * Throw an Error if a NationalInfo can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which NationalInfo to fetch.
     * 
    **/
    where?: NationalInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NationalInfos to fetch.
     * 
    **/
    orderBy?: Enumerable<NationalInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NationalInfos.
     * 
    **/
    cursor?: NationalInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NationalInfos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NationalInfos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NationalInfos.
     * 
    **/
    distinct?: Enumerable<NationalInfoScalarFieldEnum>
  }


  /**
   * NationalInfo findMany
   */
  export type NationalInfoFindManyArgs = {
    /**
     * Select specific fields to fetch from the NationalInfo
     * 
    **/
    select?: NationalInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NationalInfoInclude | null
    /**
     * Filter, which NationalInfos to fetch.
     * 
    **/
    where?: NationalInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NationalInfos to fetch.
     * 
    **/
    orderBy?: Enumerable<NationalInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NationalInfos.
     * 
    **/
    cursor?: NationalInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NationalInfos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NationalInfos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<NationalInfoScalarFieldEnum>
  }


  /**
   * NationalInfo create
   */
  export type NationalInfoCreateArgs = {
    /**
     * Select specific fields to fetch from the NationalInfo
     * 
    **/
    select?: NationalInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NationalInfoInclude | null
    /**
     * The data needed to create a NationalInfo.
     * 
    **/
    data: XOR<NationalInfoCreateInput, NationalInfoUncheckedCreateInput>
  }


  /**
   * NationalInfo createMany
   */
  export type NationalInfoCreateManyArgs = {
    data: Enumerable<NationalInfoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * NationalInfo update
   */
  export type NationalInfoUpdateArgs = {
    /**
     * Select specific fields to fetch from the NationalInfo
     * 
    **/
    select?: NationalInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NationalInfoInclude | null
    /**
     * The data needed to update a NationalInfo.
     * 
    **/
    data: XOR<NationalInfoUpdateInput, NationalInfoUncheckedUpdateInput>
    /**
     * Choose, which NationalInfo to update.
     * 
    **/
    where: NationalInfoWhereUniqueInput
  }


  /**
   * NationalInfo updateMany
   */
  export type NationalInfoUpdateManyArgs = {
    data: XOR<NationalInfoUpdateManyMutationInput, NationalInfoUncheckedUpdateManyInput>
    where?: NationalInfoWhereInput
  }


  /**
   * NationalInfo upsert
   */
  export type NationalInfoUpsertArgs = {
    /**
     * Select specific fields to fetch from the NationalInfo
     * 
    **/
    select?: NationalInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NationalInfoInclude | null
    /**
     * The filter to search for the NationalInfo to update in case it exists.
     * 
    **/
    where: NationalInfoWhereUniqueInput
    /**
     * In case the NationalInfo found by the `where` argument doesn't exist, create a new NationalInfo with this data.
     * 
    **/
    create: XOR<NationalInfoCreateInput, NationalInfoUncheckedCreateInput>
    /**
     * In case the NationalInfo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<NationalInfoUpdateInput, NationalInfoUncheckedUpdateInput>
  }


  /**
   * NationalInfo delete
   */
  export type NationalInfoDeleteArgs = {
    /**
     * Select specific fields to fetch from the NationalInfo
     * 
    **/
    select?: NationalInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NationalInfoInclude | null
    /**
     * Filter which NationalInfo to delete.
     * 
    **/
    where: NationalInfoWhereUniqueInput
  }


  /**
   * NationalInfo deleteMany
   */
  export type NationalInfoDeleteManyArgs = {
    where?: NationalInfoWhereInput
  }


  /**
   * NationalInfo without action
   */
  export type NationalInfoArgs = {
    /**
     * Select specific fields to fetch from the NationalInfo
     * 
    **/
    select?: NationalInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NationalInfoInclude | null
  }



  /**
   * Model StudentGraduation
   */


  export type AggregateStudentGraduation = {
    _count: StudentGraduationCountAggregateOutputType | null
    _avg: StudentGraduationAvgAggregateOutputType | null
    _sum: StudentGraduationSumAggregateOutputType | null
    _min: StudentGraduationMinAggregateOutputType | null
    _max: StudentGraduationMaxAggregateOutputType | null
  }

  export type StudentGraduationAvgAggregateOutputType = {
    idStudentGraduation: number | null
    studentId: number | null
  }

  export type StudentGraduationSumAggregateOutputType = {
    idStudentGraduation: number | null
    studentId: number | null
  }

  export type StudentGraduationMinAggregateOutputType = {
    idStudentGraduation: number | null
    graduationDate: string | null
    studentId: number | null
  }

  export type StudentGraduationMaxAggregateOutputType = {
    idStudentGraduation: number | null
    graduationDate: string | null
    studentId: number | null
  }

  export type StudentGraduationCountAggregateOutputType = {
    idStudentGraduation: number
    graduationDate: number
    studentId: number
    _all: number
  }


  export type StudentGraduationAvgAggregateInputType = {
    idStudentGraduation?: true
    studentId?: true
  }

  export type StudentGraduationSumAggregateInputType = {
    idStudentGraduation?: true
    studentId?: true
  }

  export type StudentGraduationMinAggregateInputType = {
    idStudentGraduation?: true
    graduationDate?: true
    studentId?: true
  }

  export type StudentGraduationMaxAggregateInputType = {
    idStudentGraduation?: true
    graduationDate?: true
    studentId?: true
  }

  export type StudentGraduationCountAggregateInputType = {
    idStudentGraduation?: true
    graduationDate?: true
    studentId?: true
    _all?: true
  }

  export type StudentGraduationAggregateArgs = {
    /**
     * Filter which StudentGraduation to aggregate.
     * 
    **/
    where?: StudentGraduationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentGraduations to fetch.
     * 
    **/
    orderBy?: Enumerable<StudentGraduationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StudentGraduationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentGraduations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentGraduations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentGraduations
    **/
    _count?: true | StudentGraduationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentGraduationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentGraduationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentGraduationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentGraduationMaxAggregateInputType
  }

  export type GetStudentGraduationAggregateType<T extends StudentGraduationAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentGraduation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentGraduation[P]>
      : GetScalarType<T[P], AggregateStudentGraduation[P]>
  }


    
    
  export type StudentGraduationGroupByArgs = {
    where?: StudentGraduationWhereInput
    orderBy?: Enumerable<StudentGraduationOrderByWithAggregationInput>
    by: Array<StudentGraduationScalarFieldEnum>
    having?: StudentGraduationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentGraduationCountAggregateInputType | true
    _avg?: StudentGraduationAvgAggregateInputType
    _sum?: StudentGraduationSumAggregateInputType
    _min?: StudentGraduationMinAggregateInputType
    _max?: StudentGraduationMaxAggregateInputType
  }


  export type StudentGraduationGroupByOutputType = {
    idStudentGraduation: number
    graduationDate: string
    studentId: number
    _count: StudentGraduationCountAggregateOutputType | null
    _avg: StudentGraduationAvgAggregateOutputType | null
    _sum: StudentGraduationSumAggregateOutputType | null
    _min: StudentGraduationMinAggregateOutputType | null
    _max: StudentGraduationMaxAggregateOutputType | null
  }

  type GetStudentGraduationGroupByPayload<T extends StudentGraduationGroupByArgs> = Promise<
    Array<
      PickArray<StudentGraduationGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof StudentGraduationGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], StudentGraduationGroupByOutputType[P]> 
            : GetScalarType<T[P], StudentGraduationGroupByOutputType[P]>
        }
      > 
    >


  export type StudentGraduationSelect = {
    idStudentGraduation?: boolean
    graduationDate?: boolean
    student?: boolean | StudentArgs
    studentId?: boolean
  }

  export type StudentGraduationInclude = {
    student?: boolean | StudentArgs
  }

  export type StudentGraduationGetPayload<
    S extends boolean | null | undefined | StudentGraduationArgs,
    U = keyof S
      > = S extends true
        ? StudentGraduation
    : S extends undefined
    ? never
    : S extends StudentGraduationArgs | StudentGraduationFindManyArgs
    ?'include' extends U
    ? StudentGraduation  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'student'
        ? StudentGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof StudentGraduation ?StudentGraduation [P]
  : 
          P extends 'student'
        ? StudentGetPayload<S['select'][P]> : never
  } 
    : StudentGraduation
  : StudentGraduation


  type StudentGraduationCountArgs = Merge<
    Omit<StudentGraduationFindManyArgs, 'select' | 'include'> & {
      select?: StudentGraduationCountAggregateInputType | true
    }
  >

  export interface StudentGraduationDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one StudentGraduation that matches the filter.
     * @param {StudentGraduationFindUniqueArgs} args - Arguments to find a StudentGraduation
     * @example
     * // Get one StudentGraduation
     * const studentGraduation = await prisma.studentGraduation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentGraduationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StudentGraduationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'StudentGraduation'> extends True ? CheckSelect<T, Prisma__StudentGraduationClient<StudentGraduation>, Prisma__StudentGraduationClient<StudentGraduationGetPayload<T>>> : CheckSelect<T, Prisma__StudentGraduationClient<StudentGraduation | null >, Prisma__StudentGraduationClient<StudentGraduationGetPayload<T> | null >>

    /**
     * Find the first StudentGraduation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGraduationFindFirstArgs} args - Arguments to find a StudentGraduation
     * @example
     * // Get one StudentGraduation
     * const studentGraduation = await prisma.studentGraduation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentGraduationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StudentGraduationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'StudentGraduation'> extends True ? CheckSelect<T, Prisma__StudentGraduationClient<StudentGraduation>, Prisma__StudentGraduationClient<StudentGraduationGetPayload<T>>> : CheckSelect<T, Prisma__StudentGraduationClient<StudentGraduation | null >, Prisma__StudentGraduationClient<StudentGraduationGetPayload<T> | null >>

    /**
     * Find zero or more StudentGraduations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGraduationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentGraduations
     * const studentGraduations = await prisma.studentGraduation.findMany()
     * 
     * // Get first 10 StudentGraduations
     * const studentGraduations = await prisma.studentGraduation.findMany({ take: 10 })
     * 
     * // Only select the `idStudentGraduation`
     * const studentGraduationWithIdStudentGraduationOnly = await prisma.studentGraduation.findMany({ select: { idStudentGraduation: true } })
     * 
    **/
    findMany<T extends StudentGraduationFindManyArgs>(
      args?: SelectSubset<T, StudentGraduationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<StudentGraduation>>, PrismaPromise<Array<StudentGraduationGetPayload<T>>>>

    /**
     * Create a StudentGraduation.
     * @param {StudentGraduationCreateArgs} args - Arguments to create a StudentGraduation.
     * @example
     * // Create one StudentGraduation
     * const StudentGraduation = await prisma.studentGraduation.create({
     *   data: {
     *     // ... data to create a StudentGraduation
     *   }
     * })
     * 
    **/
    create<T extends StudentGraduationCreateArgs>(
      args: SelectSubset<T, StudentGraduationCreateArgs>
    ): CheckSelect<T, Prisma__StudentGraduationClient<StudentGraduation>, Prisma__StudentGraduationClient<StudentGraduationGetPayload<T>>>

    /**
     * Create many StudentGraduations.
     *     @param {StudentGraduationCreateManyArgs} args - Arguments to create many StudentGraduations.
     *     @example
     *     // Create many StudentGraduations
     *     const studentGraduation = await prisma.studentGraduation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentGraduationCreateManyArgs>(
      args?: SelectSubset<T, StudentGraduationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a StudentGraduation.
     * @param {StudentGraduationDeleteArgs} args - Arguments to delete one StudentGraduation.
     * @example
     * // Delete one StudentGraduation
     * const StudentGraduation = await prisma.studentGraduation.delete({
     *   where: {
     *     // ... filter to delete one StudentGraduation
     *   }
     * })
     * 
    **/
    delete<T extends StudentGraduationDeleteArgs>(
      args: SelectSubset<T, StudentGraduationDeleteArgs>
    ): CheckSelect<T, Prisma__StudentGraduationClient<StudentGraduation>, Prisma__StudentGraduationClient<StudentGraduationGetPayload<T>>>

    /**
     * Update one StudentGraduation.
     * @param {StudentGraduationUpdateArgs} args - Arguments to update one StudentGraduation.
     * @example
     * // Update one StudentGraduation
     * const studentGraduation = await prisma.studentGraduation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentGraduationUpdateArgs>(
      args: SelectSubset<T, StudentGraduationUpdateArgs>
    ): CheckSelect<T, Prisma__StudentGraduationClient<StudentGraduation>, Prisma__StudentGraduationClient<StudentGraduationGetPayload<T>>>

    /**
     * Delete zero or more StudentGraduations.
     * @param {StudentGraduationDeleteManyArgs} args - Arguments to filter StudentGraduations to delete.
     * @example
     * // Delete a few StudentGraduations
     * const { count } = await prisma.studentGraduation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentGraduationDeleteManyArgs>(
      args?: SelectSubset<T, StudentGraduationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentGraduations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGraduationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentGraduations
     * const studentGraduation = await prisma.studentGraduation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentGraduationUpdateManyArgs>(
      args: SelectSubset<T, StudentGraduationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentGraduation.
     * @param {StudentGraduationUpsertArgs} args - Arguments to update or create a StudentGraduation.
     * @example
     * // Update or create a StudentGraduation
     * const studentGraduation = await prisma.studentGraduation.upsert({
     *   create: {
     *     // ... data to create a StudentGraduation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentGraduation we want to update
     *   }
     * })
    **/
    upsert<T extends StudentGraduationUpsertArgs>(
      args: SelectSubset<T, StudentGraduationUpsertArgs>
    ): CheckSelect<T, Prisma__StudentGraduationClient<StudentGraduation>, Prisma__StudentGraduationClient<StudentGraduationGetPayload<T>>>

    /**
     * Count the number of StudentGraduations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGraduationCountArgs} args - Arguments to filter StudentGraduations to count.
     * @example
     * // Count the number of StudentGraduations
     * const count = await prisma.studentGraduation.count({
     *   where: {
     *     // ... the filter for the StudentGraduations we want to count
     *   }
     * })
    **/
    count<T extends StudentGraduationCountArgs>(
      args?: Subset<T, StudentGraduationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentGraduationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentGraduation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGraduationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentGraduationAggregateArgs>(args: Subset<T, StudentGraduationAggregateArgs>): PrismaPromise<GetStudentGraduationAggregateType<T>>

    /**
     * Group by StudentGraduation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGraduationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGraduationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGraduationGroupByArgs['orderBy'] }
        : { orderBy?: StudentGraduationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGraduationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGraduationGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentGraduation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StudentGraduationClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    student<T extends StudentArgs = {}>(args?: Subset<T, StudentArgs>): CheckSelect<T, Prisma__StudentClient<Student | null >, Prisma__StudentClient<StudentGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * StudentGraduation findUnique
   */
  export type StudentGraduationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the StudentGraduation
     * 
    **/
    select?: StudentGraduationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentGraduationInclude | null
    /**
     * Throw an Error if a StudentGraduation can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which StudentGraduation to fetch.
     * 
    **/
    where: StudentGraduationWhereUniqueInput
  }


  /**
   * StudentGraduation findFirst
   */
  export type StudentGraduationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the StudentGraduation
     * 
    **/
    select?: StudentGraduationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentGraduationInclude | null
    /**
     * Throw an Error if a StudentGraduation can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which StudentGraduation to fetch.
     * 
    **/
    where?: StudentGraduationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentGraduations to fetch.
     * 
    **/
    orderBy?: Enumerable<StudentGraduationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentGraduations.
     * 
    **/
    cursor?: StudentGraduationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentGraduations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentGraduations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentGraduations.
     * 
    **/
    distinct?: Enumerable<StudentGraduationScalarFieldEnum>
  }


  /**
   * StudentGraduation findMany
   */
  export type StudentGraduationFindManyArgs = {
    /**
     * Select specific fields to fetch from the StudentGraduation
     * 
    **/
    select?: StudentGraduationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentGraduationInclude | null
    /**
     * Filter, which StudentGraduations to fetch.
     * 
    **/
    where?: StudentGraduationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentGraduations to fetch.
     * 
    **/
    orderBy?: Enumerable<StudentGraduationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentGraduations.
     * 
    **/
    cursor?: StudentGraduationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentGraduations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentGraduations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StudentGraduationScalarFieldEnum>
  }


  /**
   * StudentGraduation create
   */
  export type StudentGraduationCreateArgs = {
    /**
     * Select specific fields to fetch from the StudentGraduation
     * 
    **/
    select?: StudentGraduationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentGraduationInclude | null
    /**
     * The data needed to create a StudentGraduation.
     * 
    **/
    data: XOR<StudentGraduationCreateInput, StudentGraduationUncheckedCreateInput>
  }


  /**
   * StudentGraduation createMany
   */
  export type StudentGraduationCreateManyArgs = {
    data: Enumerable<StudentGraduationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * StudentGraduation update
   */
  export type StudentGraduationUpdateArgs = {
    /**
     * Select specific fields to fetch from the StudentGraduation
     * 
    **/
    select?: StudentGraduationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentGraduationInclude | null
    /**
     * The data needed to update a StudentGraduation.
     * 
    **/
    data: XOR<StudentGraduationUpdateInput, StudentGraduationUncheckedUpdateInput>
    /**
     * Choose, which StudentGraduation to update.
     * 
    **/
    where: StudentGraduationWhereUniqueInput
  }


  /**
   * StudentGraduation updateMany
   */
  export type StudentGraduationUpdateManyArgs = {
    data: XOR<StudentGraduationUpdateManyMutationInput, StudentGraduationUncheckedUpdateManyInput>
    where?: StudentGraduationWhereInput
  }


  /**
   * StudentGraduation upsert
   */
  export type StudentGraduationUpsertArgs = {
    /**
     * Select specific fields to fetch from the StudentGraduation
     * 
    **/
    select?: StudentGraduationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentGraduationInclude | null
    /**
     * The filter to search for the StudentGraduation to update in case it exists.
     * 
    **/
    where: StudentGraduationWhereUniqueInput
    /**
     * In case the StudentGraduation found by the `where` argument doesn't exist, create a new StudentGraduation with this data.
     * 
    **/
    create: XOR<StudentGraduationCreateInput, StudentGraduationUncheckedCreateInput>
    /**
     * In case the StudentGraduation was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StudentGraduationUpdateInput, StudentGraduationUncheckedUpdateInput>
  }


  /**
   * StudentGraduation delete
   */
  export type StudentGraduationDeleteArgs = {
    /**
     * Select specific fields to fetch from the StudentGraduation
     * 
    **/
    select?: StudentGraduationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentGraduationInclude | null
    /**
     * Filter which StudentGraduation to delete.
     * 
    **/
    where: StudentGraduationWhereUniqueInput
  }


  /**
   * StudentGraduation deleteMany
   */
  export type StudentGraduationDeleteManyArgs = {
    where?: StudentGraduationWhereInput
  }


  /**
   * StudentGraduation without action
   */
  export type StudentGraduationArgs = {
    /**
     * Select specific fields to fetch from the StudentGraduation
     * 
    **/
    select?: StudentGraduationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentGraduationInclude | null
  }



  /**
   * Model StudentLevel
   */


  export type AggregateStudentLevel = {
    _count: StudentLevelCountAggregateOutputType | null
    _avg: StudentLevelAvgAggregateOutputType | null
    _sum: StudentLevelSumAggregateOutputType | null
    _min: StudentLevelMinAggregateOutputType | null
    _max: StudentLevelMaxAggregateOutputType | null
  }

  export type StudentLevelAvgAggregateOutputType = {
    idStudentLevel: number | null
    level: number | null
    yearStudyId: number | null
    studentId: number | null
  }

  export type StudentLevelSumAggregateOutputType = {
    idStudentLevel: number | null
    level: number | null
    yearStudyId: number | null
    studentId: number | null
  }

  export type StudentLevelMinAggregateOutputType = {
    idStudentLevel: number | null
    level: number | null
    class: string | null
    yearStudyId: number | null
    studentId: number | null
  }

  export type StudentLevelMaxAggregateOutputType = {
    idStudentLevel: number | null
    level: number | null
    class: string | null
    yearStudyId: number | null
    studentId: number | null
  }

  export type StudentLevelCountAggregateOutputType = {
    idStudentLevel: number
    level: number
    class: number
    yearStudyId: number
    studentId: number
    _all: number
  }


  export type StudentLevelAvgAggregateInputType = {
    idStudentLevel?: true
    level?: true
    yearStudyId?: true
    studentId?: true
  }

  export type StudentLevelSumAggregateInputType = {
    idStudentLevel?: true
    level?: true
    yearStudyId?: true
    studentId?: true
  }

  export type StudentLevelMinAggregateInputType = {
    idStudentLevel?: true
    level?: true
    class?: true
    yearStudyId?: true
    studentId?: true
  }

  export type StudentLevelMaxAggregateInputType = {
    idStudentLevel?: true
    level?: true
    class?: true
    yearStudyId?: true
    studentId?: true
  }

  export type StudentLevelCountAggregateInputType = {
    idStudentLevel?: true
    level?: true
    class?: true
    yearStudyId?: true
    studentId?: true
    _all?: true
  }

  export type StudentLevelAggregateArgs = {
    /**
     * Filter which StudentLevel to aggregate.
     * 
    **/
    where?: StudentLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentLevels to fetch.
     * 
    **/
    orderBy?: Enumerable<StudentLevelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StudentLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentLevels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentLevels.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentLevels
    **/
    _count?: true | StudentLevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentLevelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentLevelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentLevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentLevelMaxAggregateInputType
  }

  export type GetStudentLevelAggregateType<T extends StudentLevelAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentLevel[P]>
      : GetScalarType<T[P], AggregateStudentLevel[P]>
  }


    
    
  export type StudentLevelGroupByArgs = {
    where?: StudentLevelWhereInput
    orderBy?: Enumerable<StudentLevelOrderByWithAggregationInput>
    by: Array<StudentLevelScalarFieldEnum>
    having?: StudentLevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentLevelCountAggregateInputType | true
    _avg?: StudentLevelAvgAggregateInputType
    _sum?: StudentLevelSumAggregateInputType
    _min?: StudentLevelMinAggregateInputType
    _max?: StudentLevelMaxAggregateInputType
  }


  export type StudentLevelGroupByOutputType = {
    idStudentLevel: number
    level: number
    class: string
    yearStudyId: number
    studentId: number
    _count: StudentLevelCountAggregateOutputType | null
    _avg: StudentLevelAvgAggregateOutputType | null
    _sum: StudentLevelSumAggregateOutputType | null
    _min: StudentLevelMinAggregateOutputType | null
    _max: StudentLevelMaxAggregateOutputType | null
  }

  type GetStudentLevelGroupByPayload<T extends StudentLevelGroupByArgs> = Promise<
    Array<
      PickArray<StudentLevelGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof StudentLevelGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], StudentLevelGroupByOutputType[P]> 
            : GetScalarType<T[P], StudentLevelGroupByOutputType[P]>
        }
      > 
    >


  export type StudentLevelSelect = {
    idStudentLevel?: boolean
    level?: boolean
    class?: boolean
    yearStudy?: boolean | YearStudyArgs
    yearStudyId?: boolean
    student?: boolean | StudentArgs
    studentId?: boolean
  }

  export type StudentLevelInclude = {
    yearStudy?: boolean | YearStudyArgs
    student?: boolean | StudentArgs
  }

  export type StudentLevelGetPayload<
    S extends boolean | null | undefined | StudentLevelArgs,
    U = keyof S
      > = S extends true
        ? StudentLevel
    : S extends undefined
    ? never
    : S extends StudentLevelArgs | StudentLevelFindManyArgs
    ?'include' extends U
    ? StudentLevel  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'yearStudy'
        ? YearStudyGetPayload<S['include'][P]> :
        P extends 'student'
        ? StudentGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof StudentLevel ?StudentLevel [P]
  : 
          P extends 'yearStudy'
        ? YearStudyGetPayload<S['select'][P]> :
        P extends 'student'
        ? StudentGetPayload<S['select'][P]> : never
  } 
    : StudentLevel
  : StudentLevel


  type StudentLevelCountArgs = Merge<
    Omit<StudentLevelFindManyArgs, 'select' | 'include'> & {
      select?: StudentLevelCountAggregateInputType | true
    }
  >

  export interface StudentLevelDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one StudentLevel that matches the filter.
     * @param {StudentLevelFindUniqueArgs} args - Arguments to find a StudentLevel
     * @example
     * // Get one StudentLevel
     * const studentLevel = await prisma.studentLevel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentLevelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StudentLevelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'StudentLevel'> extends True ? CheckSelect<T, Prisma__StudentLevelClient<StudentLevel>, Prisma__StudentLevelClient<StudentLevelGetPayload<T>>> : CheckSelect<T, Prisma__StudentLevelClient<StudentLevel | null >, Prisma__StudentLevelClient<StudentLevelGetPayload<T> | null >>

    /**
     * Find the first StudentLevel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentLevelFindFirstArgs} args - Arguments to find a StudentLevel
     * @example
     * // Get one StudentLevel
     * const studentLevel = await prisma.studentLevel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentLevelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StudentLevelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'StudentLevel'> extends True ? CheckSelect<T, Prisma__StudentLevelClient<StudentLevel>, Prisma__StudentLevelClient<StudentLevelGetPayload<T>>> : CheckSelect<T, Prisma__StudentLevelClient<StudentLevel | null >, Prisma__StudentLevelClient<StudentLevelGetPayload<T> | null >>

    /**
     * Find zero or more StudentLevels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentLevelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentLevels
     * const studentLevels = await prisma.studentLevel.findMany()
     * 
     * // Get first 10 StudentLevels
     * const studentLevels = await prisma.studentLevel.findMany({ take: 10 })
     * 
     * // Only select the `idStudentLevel`
     * const studentLevelWithIdStudentLevelOnly = await prisma.studentLevel.findMany({ select: { idStudentLevel: true } })
     * 
    **/
    findMany<T extends StudentLevelFindManyArgs>(
      args?: SelectSubset<T, StudentLevelFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<StudentLevel>>, PrismaPromise<Array<StudentLevelGetPayload<T>>>>

    /**
     * Create a StudentLevel.
     * @param {StudentLevelCreateArgs} args - Arguments to create a StudentLevel.
     * @example
     * // Create one StudentLevel
     * const StudentLevel = await prisma.studentLevel.create({
     *   data: {
     *     // ... data to create a StudentLevel
     *   }
     * })
     * 
    **/
    create<T extends StudentLevelCreateArgs>(
      args: SelectSubset<T, StudentLevelCreateArgs>
    ): CheckSelect<T, Prisma__StudentLevelClient<StudentLevel>, Prisma__StudentLevelClient<StudentLevelGetPayload<T>>>

    /**
     * Create many StudentLevels.
     *     @param {StudentLevelCreateManyArgs} args - Arguments to create many StudentLevels.
     *     @example
     *     // Create many StudentLevels
     *     const studentLevel = await prisma.studentLevel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentLevelCreateManyArgs>(
      args?: SelectSubset<T, StudentLevelCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a StudentLevel.
     * @param {StudentLevelDeleteArgs} args - Arguments to delete one StudentLevel.
     * @example
     * // Delete one StudentLevel
     * const StudentLevel = await prisma.studentLevel.delete({
     *   where: {
     *     // ... filter to delete one StudentLevel
     *   }
     * })
     * 
    **/
    delete<T extends StudentLevelDeleteArgs>(
      args: SelectSubset<T, StudentLevelDeleteArgs>
    ): CheckSelect<T, Prisma__StudentLevelClient<StudentLevel>, Prisma__StudentLevelClient<StudentLevelGetPayload<T>>>

    /**
     * Update one StudentLevel.
     * @param {StudentLevelUpdateArgs} args - Arguments to update one StudentLevel.
     * @example
     * // Update one StudentLevel
     * const studentLevel = await prisma.studentLevel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentLevelUpdateArgs>(
      args: SelectSubset<T, StudentLevelUpdateArgs>
    ): CheckSelect<T, Prisma__StudentLevelClient<StudentLevel>, Prisma__StudentLevelClient<StudentLevelGetPayload<T>>>

    /**
     * Delete zero or more StudentLevels.
     * @param {StudentLevelDeleteManyArgs} args - Arguments to filter StudentLevels to delete.
     * @example
     * // Delete a few StudentLevels
     * const { count } = await prisma.studentLevel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentLevelDeleteManyArgs>(
      args?: SelectSubset<T, StudentLevelDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentLevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentLevels
     * const studentLevel = await prisma.studentLevel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentLevelUpdateManyArgs>(
      args: SelectSubset<T, StudentLevelUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentLevel.
     * @param {StudentLevelUpsertArgs} args - Arguments to update or create a StudentLevel.
     * @example
     * // Update or create a StudentLevel
     * const studentLevel = await prisma.studentLevel.upsert({
     *   create: {
     *     // ... data to create a StudentLevel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentLevel we want to update
     *   }
     * })
    **/
    upsert<T extends StudentLevelUpsertArgs>(
      args: SelectSubset<T, StudentLevelUpsertArgs>
    ): CheckSelect<T, Prisma__StudentLevelClient<StudentLevel>, Prisma__StudentLevelClient<StudentLevelGetPayload<T>>>

    /**
     * Count the number of StudentLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentLevelCountArgs} args - Arguments to filter StudentLevels to count.
     * @example
     * // Count the number of StudentLevels
     * const count = await prisma.studentLevel.count({
     *   where: {
     *     // ... the filter for the StudentLevels we want to count
     *   }
     * })
    **/
    count<T extends StudentLevelCountArgs>(
      args?: Subset<T, StudentLevelCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentLevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentLevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentLevelAggregateArgs>(args: Subset<T, StudentLevelAggregateArgs>): PrismaPromise<GetStudentLevelAggregateType<T>>

    /**
     * Group by StudentLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentLevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentLevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentLevelGroupByArgs['orderBy'] }
        : { orderBy?: StudentLevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentLevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentLevelGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentLevel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StudentLevelClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    yearStudy<T extends YearStudyArgs = {}>(args?: Subset<T, YearStudyArgs>): CheckSelect<T, Prisma__YearStudyClient<YearStudy | null >, Prisma__YearStudyClient<YearStudyGetPayload<T> | null >>;

    student<T extends StudentArgs = {}>(args?: Subset<T, StudentArgs>): CheckSelect<T, Prisma__StudentClient<Student | null >, Prisma__StudentClient<StudentGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * StudentLevel findUnique
   */
  export type StudentLevelFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the StudentLevel
     * 
    **/
    select?: StudentLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentLevelInclude | null
    /**
     * Throw an Error if a StudentLevel can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which StudentLevel to fetch.
     * 
    **/
    where: StudentLevelWhereUniqueInput
  }


  /**
   * StudentLevel findFirst
   */
  export type StudentLevelFindFirstArgs = {
    /**
     * Select specific fields to fetch from the StudentLevel
     * 
    **/
    select?: StudentLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentLevelInclude | null
    /**
     * Throw an Error if a StudentLevel can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which StudentLevel to fetch.
     * 
    **/
    where?: StudentLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentLevels to fetch.
     * 
    **/
    orderBy?: Enumerable<StudentLevelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentLevels.
     * 
    **/
    cursor?: StudentLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentLevels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentLevels.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentLevels.
     * 
    **/
    distinct?: Enumerable<StudentLevelScalarFieldEnum>
  }


  /**
   * StudentLevel findMany
   */
  export type StudentLevelFindManyArgs = {
    /**
     * Select specific fields to fetch from the StudentLevel
     * 
    **/
    select?: StudentLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentLevelInclude | null
    /**
     * Filter, which StudentLevels to fetch.
     * 
    **/
    where?: StudentLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentLevels to fetch.
     * 
    **/
    orderBy?: Enumerable<StudentLevelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentLevels.
     * 
    **/
    cursor?: StudentLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentLevels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentLevels.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StudentLevelScalarFieldEnum>
  }


  /**
   * StudentLevel create
   */
  export type StudentLevelCreateArgs = {
    /**
     * Select specific fields to fetch from the StudentLevel
     * 
    **/
    select?: StudentLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentLevelInclude | null
    /**
     * The data needed to create a StudentLevel.
     * 
    **/
    data: XOR<StudentLevelCreateInput, StudentLevelUncheckedCreateInput>
  }


  /**
   * StudentLevel createMany
   */
  export type StudentLevelCreateManyArgs = {
    data: Enumerable<StudentLevelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * StudentLevel update
   */
  export type StudentLevelUpdateArgs = {
    /**
     * Select specific fields to fetch from the StudentLevel
     * 
    **/
    select?: StudentLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentLevelInclude | null
    /**
     * The data needed to update a StudentLevel.
     * 
    **/
    data: XOR<StudentLevelUpdateInput, StudentLevelUncheckedUpdateInput>
    /**
     * Choose, which StudentLevel to update.
     * 
    **/
    where: StudentLevelWhereUniqueInput
  }


  /**
   * StudentLevel updateMany
   */
  export type StudentLevelUpdateManyArgs = {
    data: XOR<StudentLevelUpdateManyMutationInput, StudentLevelUncheckedUpdateManyInput>
    where?: StudentLevelWhereInput
  }


  /**
   * StudentLevel upsert
   */
  export type StudentLevelUpsertArgs = {
    /**
     * Select specific fields to fetch from the StudentLevel
     * 
    **/
    select?: StudentLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentLevelInclude | null
    /**
     * The filter to search for the StudentLevel to update in case it exists.
     * 
    **/
    where: StudentLevelWhereUniqueInput
    /**
     * In case the StudentLevel found by the `where` argument doesn't exist, create a new StudentLevel with this data.
     * 
    **/
    create: XOR<StudentLevelCreateInput, StudentLevelUncheckedCreateInput>
    /**
     * In case the StudentLevel was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StudentLevelUpdateInput, StudentLevelUncheckedUpdateInput>
  }


  /**
   * StudentLevel delete
   */
  export type StudentLevelDeleteArgs = {
    /**
     * Select specific fields to fetch from the StudentLevel
     * 
    **/
    select?: StudentLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentLevelInclude | null
    /**
     * Filter which StudentLevel to delete.
     * 
    **/
    where: StudentLevelWhereUniqueInput
  }


  /**
   * StudentLevel deleteMany
   */
  export type StudentLevelDeleteManyArgs = {
    where?: StudentLevelWhereInput
  }


  /**
   * StudentLevel without action
   */
  export type StudentLevelArgs = {
    /**
     * Select specific fields to fetch from the StudentLevel
     * 
    **/
    select?: StudentLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentLevelInclude | null
  }



  /**
   * Model StudentSchool
   */


  export type AggregateStudentSchool = {
    _count: StudentSchoolCountAggregateOutputType | null
    _avg: StudentSchoolAvgAggregateOutputType | null
    _sum: StudentSchoolSumAggregateOutputType | null
    _min: StudentSchoolMinAggregateOutputType | null
    _max: StudentSchoolMaxAggregateOutputType | null
  }

  export type StudentSchoolAvgAggregateOutputType = {
    idStudentSchool: number | null
    totalMarks: number | null
    average: number | null
    documentNumber: number | null
    lessonCount: number | null
    studySubCategoryId: number | null
    studentId: number | null
    certificateStatusId: number | null
  }

  export type StudentSchoolSumAggregateOutputType = {
    idStudentSchool: number | null
    totalMarks: number | null
    average: number | null
    documentNumber: number | null
    lessonCount: number | null
    studySubCategoryId: number | null
    studentId: number | null
    certificateStatusId: number | null
  }

  export type StudentSchoolMinAggregateOutputType = {
    idStudentSchool: number | null
    schoolName: string | null
    graduationDate: string | null
    documentDate: string | null
    totalMarks: number | null
    average: number | null
    documentNumber: number | null
    lessonCount: number | null
    Directorate: string | null
    studySubCategoryId: number | null
    studentId: number | null
    certificateStatusId: number | null
    certificateStatusDescription: string | null
    createdAt: Date | null
  }

  export type StudentSchoolMaxAggregateOutputType = {
    idStudentSchool: number | null
    schoolName: string | null
    graduationDate: string | null
    documentDate: string | null
    totalMarks: number | null
    average: number | null
    documentNumber: number | null
    lessonCount: number | null
    Directorate: string | null
    studySubCategoryId: number | null
    studentId: number | null
    certificateStatusId: number | null
    certificateStatusDescription: string | null
    createdAt: Date | null
  }

  export type StudentSchoolCountAggregateOutputType = {
    idStudentSchool: number
    schoolName: number
    graduationDate: number
    documentDate: number
    totalMarks: number
    average: number
    documentNumber: number
    lessonCount: number
    Directorate: number
    studySubCategoryId: number
    studentId: number
    certificateStatusId: number
    certificateStatusDescription: number
    createdAt: number
    _all: number
  }


  export type StudentSchoolAvgAggregateInputType = {
    idStudentSchool?: true
    totalMarks?: true
    average?: true
    documentNumber?: true
    lessonCount?: true
    studySubCategoryId?: true
    studentId?: true
    certificateStatusId?: true
  }

  export type StudentSchoolSumAggregateInputType = {
    idStudentSchool?: true
    totalMarks?: true
    average?: true
    documentNumber?: true
    lessonCount?: true
    studySubCategoryId?: true
    studentId?: true
    certificateStatusId?: true
  }

  export type StudentSchoolMinAggregateInputType = {
    idStudentSchool?: true
    schoolName?: true
    graduationDate?: true
    documentDate?: true
    totalMarks?: true
    average?: true
    documentNumber?: true
    lessonCount?: true
    Directorate?: true
    studySubCategoryId?: true
    studentId?: true
    certificateStatusId?: true
    certificateStatusDescription?: true
    createdAt?: true
  }

  export type StudentSchoolMaxAggregateInputType = {
    idStudentSchool?: true
    schoolName?: true
    graduationDate?: true
    documentDate?: true
    totalMarks?: true
    average?: true
    documentNumber?: true
    lessonCount?: true
    Directorate?: true
    studySubCategoryId?: true
    studentId?: true
    certificateStatusId?: true
    certificateStatusDescription?: true
    createdAt?: true
  }

  export type StudentSchoolCountAggregateInputType = {
    idStudentSchool?: true
    schoolName?: true
    graduationDate?: true
    documentDate?: true
    totalMarks?: true
    average?: true
    documentNumber?: true
    lessonCount?: true
    Directorate?: true
    studySubCategoryId?: true
    studentId?: true
    certificateStatusId?: true
    certificateStatusDescription?: true
    createdAt?: true
    _all?: true
  }

  export type StudentSchoolAggregateArgs = {
    /**
     * Filter which StudentSchool to aggregate.
     * 
    **/
    where?: StudentSchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSchools to fetch.
     * 
    **/
    orderBy?: Enumerable<StudentSchoolOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StudentSchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSchools from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSchools.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentSchools
    **/
    _count?: true | StudentSchoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentSchoolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSchoolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentSchoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentSchoolMaxAggregateInputType
  }

  export type GetStudentSchoolAggregateType<T extends StudentSchoolAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentSchool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentSchool[P]>
      : GetScalarType<T[P], AggregateStudentSchool[P]>
  }


    
    
  export type StudentSchoolGroupByArgs = {
    where?: StudentSchoolWhereInput
    orderBy?: Enumerable<StudentSchoolOrderByWithAggregationInput>
    by: Array<StudentSchoolScalarFieldEnum>
    having?: StudentSchoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentSchoolCountAggregateInputType | true
    _avg?: StudentSchoolAvgAggregateInputType
    _sum?: StudentSchoolSumAggregateInputType
    _min?: StudentSchoolMinAggregateInputType
    _max?: StudentSchoolMaxAggregateInputType
  }


  export type StudentSchoolGroupByOutputType = {
    idStudentSchool: number
    schoolName: string
    graduationDate: string
    documentDate: string
    totalMarks: number
    average: number
    documentNumber: number
    lessonCount: number
    Directorate: string
    studySubCategoryId: number
    studentId: number
    certificateStatusId: number
    certificateStatusDescription: string
    createdAt: Date
    _count: StudentSchoolCountAggregateOutputType | null
    _avg: StudentSchoolAvgAggregateOutputType | null
    _sum: StudentSchoolSumAggregateOutputType | null
    _min: StudentSchoolMinAggregateOutputType | null
    _max: StudentSchoolMaxAggregateOutputType | null
  }

  type GetStudentSchoolGroupByPayload<T extends StudentSchoolGroupByArgs> = Promise<
    Array<
      PickArray<StudentSchoolGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof StudentSchoolGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], StudentSchoolGroupByOutputType[P]> 
            : GetScalarType<T[P], StudentSchoolGroupByOutputType[P]>
        }
      > 
    >


  export type StudentSchoolSelect = {
    idStudentSchool?: boolean
    schoolName?: boolean
    graduationDate?: boolean
    documentDate?: boolean
    totalMarks?: boolean
    average?: boolean
    documentNumber?: boolean
    lessonCount?: boolean
    Directorate?: boolean
    studySubCategory?: boolean | StudySubCategoryArgs
    studySubCategoryId?: boolean
    student?: boolean | StudentArgs
    studentId?: boolean
    certificateStatus?: boolean | CertificateStatusArgs
    certificateStatusId?: boolean
    certificateStatusDescription?: boolean
    createdAt?: boolean
  }

  export type StudentSchoolInclude = {
    studySubCategory?: boolean | StudySubCategoryArgs
    student?: boolean | StudentArgs
    certificateStatus?: boolean | CertificateStatusArgs
  }

  export type StudentSchoolGetPayload<
    S extends boolean | null | undefined | StudentSchoolArgs,
    U = keyof S
      > = S extends true
        ? StudentSchool
    : S extends undefined
    ? never
    : S extends StudentSchoolArgs | StudentSchoolFindManyArgs
    ?'include' extends U
    ? StudentSchool  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'studySubCategory'
        ? StudySubCategoryGetPayload<S['include'][P]> :
        P extends 'student'
        ? StudentGetPayload<S['include'][P]> :
        P extends 'certificateStatus'
        ? CertificateStatusGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof StudentSchool ?StudentSchool [P]
  : 
          P extends 'studySubCategory'
        ? StudySubCategoryGetPayload<S['select'][P]> :
        P extends 'student'
        ? StudentGetPayload<S['select'][P]> :
        P extends 'certificateStatus'
        ? CertificateStatusGetPayload<S['select'][P]> : never
  } 
    : StudentSchool
  : StudentSchool


  type StudentSchoolCountArgs = Merge<
    Omit<StudentSchoolFindManyArgs, 'select' | 'include'> & {
      select?: StudentSchoolCountAggregateInputType | true
    }
  >

  export interface StudentSchoolDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one StudentSchool that matches the filter.
     * @param {StudentSchoolFindUniqueArgs} args - Arguments to find a StudentSchool
     * @example
     * // Get one StudentSchool
     * const studentSchool = await prisma.studentSchool.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentSchoolFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StudentSchoolFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'StudentSchool'> extends True ? CheckSelect<T, Prisma__StudentSchoolClient<StudentSchool>, Prisma__StudentSchoolClient<StudentSchoolGetPayload<T>>> : CheckSelect<T, Prisma__StudentSchoolClient<StudentSchool | null >, Prisma__StudentSchoolClient<StudentSchoolGetPayload<T> | null >>

    /**
     * Find the first StudentSchool that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSchoolFindFirstArgs} args - Arguments to find a StudentSchool
     * @example
     * // Get one StudentSchool
     * const studentSchool = await prisma.studentSchool.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentSchoolFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StudentSchoolFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'StudentSchool'> extends True ? CheckSelect<T, Prisma__StudentSchoolClient<StudentSchool>, Prisma__StudentSchoolClient<StudentSchoolGetPayload<T>>> : CheckSelect<T, Prisma__StudentSchoolClient<StudentSchool | null >, Prisma__StudentSchoolClient<StudentSchoolGetPayload<T> | null >>

    /**
     * Find zero or more StudentSchools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSchoolFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentSchools
     * const studentSchools = await prisma.studentSchool.findMany()
     * 
     * // Get first 10 StudentSchools
     * const studentSchools = await prisma.studentSchool.findMany({ take: 10 })
     * 
     * // Only select the `idStudentSchool`
     * const studentSchoolWithIdStudentSchoolOnly = await prisma.studentSchool.findMany({ select: { idStudentSchool: true } })
     * 
    **/
    findMany<T extends StudentSchoolFindManyArgs>(
      args?: SelectSubset<T, StudentSchoolFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<StudentSchool>>, PrismaPromise<Array<StudentSchoolGetPayload<T>>>>

    /**
     * Create a StudentSchool.
     * @param {StudentSchoolCreateArgs} args - Arguments to create a StudentSchool.
     * @example
     * // Create one StudentSchool
     * const StudentSchool = await prisma.studentSchool.create({
     *   data: {
     *     // ... data to create a StudentSchool
     *   }
     * })
     * 
    **/
    create<T extends StudentSchoolCreateArgs>(
      args: SelectSubset<T, StudentSchoolCreateArgs>
    ): CheckSelect<T, Prisma__StudentSchoolClient<StudentSchool>, Prisma__StudentSchoolClient<StudentSchoolGetPayload<T>>>

    /**
     * Create many StudentSchools.
     *     @param {StudentSchoolCreateManyArgs} args - Arguments to create many StudentSchools.
     *     @example
     *     // Create many StudentSchools
     *     const studentSchool = await prisma.studentSchool.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentSchoolCreateManyArgs>(
      args?: SelectSubset<T, StudentSchoolCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a StudentSchool.
     * @param {StudentSchoolDeleteArgs} args - Arguments to delete one StudentSchool.
     * @example
     * // Delete one StudentSchool
     * const StudentSchool = await prisma.studentSchool.delete({
     *   where: {
     *     // ... filter to delete one StudentSchool
     *   }
     * })
     * 
    **/
    delete<T extends StudentSchoolDeleteArgs>(
      args: SelectSubset<T, StudentSchoolDeleteArgs>
    ): CheckSelect<T, Prisma__StudentSchoolClient<StudentSchool>, Prisma__StudentSchoolClient<StudentSchoolGetPayload<T>>>

    /**
     * Update one StudentSchool.
     * @param {StudentSchoolUpdateArgs} args - Arguments to update one StudentSchool.
     * @example
     * // Update one StudentSchool
     * const studentSchool = await prisma.studentSchool.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentSchoolUpdateArgs>(
      args: SelectSubset<T, StudentSchoolUpdateArgs>
    ): CheckSelect<T, Prisma__StudentSchoolClient<StudentSchool>, Prisma__StudentSchoolClient<StudentSchoolGetPayload<T>>>

    /**
     * Delete zero or more StudentSchools.
     * @param {StudentSchoolDeleteManyArgs} args - Arguments to filter StudentSchools to delete.
     * @example
     * // Delete a few StudentSchools
     * const { count } = await prisma.studentSchool.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentSchoolDeleteManyArgs>(
      args?: SelectSubset<T, StudentSchoolDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentSchools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSchoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentSchools
     * const studentSchool = await prisma.studentSchool.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentSchoolUpdateManyArgs>(
      args: SelectSubset<T, StudentSchoolUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentSchool.
     * @param {StudentSchoolUpsertArgs} args - Arguments to update or create a StudentSchool.
     * @example
     * // Update or create a StudentSchool
     * const studentSchool = await prisma.studentSchool.upsert({
     *   create: {
     *     // ... data to create a StudentSchool
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentSchool we want to update
     *   }
     * })
    **/
    upsert<T extends StudentSchoolUpsertArgs>(
      args: SelectSubset<T, StudentSchoolUpsertArgs>
    ): CheckSelect<T, Prisma__StudentSchoolClient<StudentSchool>, Prisma__StudentSchoolClient<StudentSchoolGetPayload<T>>>

    /**
     * Count the number of StudentSchools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSchoolCountArgs} args - Arguments to filter StudentSchools to count.
     * @example
     * // Count the number of StudentSchools
     * const count = await prisma.studentSchool.count({
     *   where: {
     *     // ... the filter for the StudentSchools we want to count
     *   }
     * })
    **/
    count<T extends StudentSchoolCountArgs>(
      args?: Subset<T, StudentSchoolCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentSchoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentSchool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSchoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentSchoolAggregateArgs>(args: Subset<T, StudentSchoolAggregateArgs>): PrismaPromise<GetStudentSchoolAggregateType<T>>

    /**
     * Group by StudentSchool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSchoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentSchoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentSchoolGroupByArgs['orderBy'] }
        : { orderBy?: StudentSchoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentSchoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentSchoolGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentSchool.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StudentSchoolClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    studySubCategory<T extends StudySubCategoryArgs = {}>(args?: Subset<T, StudySubCategoryArgs>): CheckSelect<T, Prisma__StudySubCategoryClient<StudySubCategory | null >, Prisma__StudySubCategoryClient<StudySubCategoryGetPayload<T> | null >>;

    student<T extends StudentArgs = {}>(args?: Subset<T, StudentArgs>): CheckSelect<T, Prisma__StudentClient<Student | null >, Prisma__StudentClient<StudentGetPayload<T> | null >>;

    certificateStatus<T extends CertificateStatusArgs = {}>(args?: Subset<T, CertificateStatusArgs>): CheckSelect<T, Prisma__CertificateStatusClient<CertificateStatus | null >, Prisma__CertificateStatusClient<CertificateStatusGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * StudentSchool findUnique
   */
  export type StudentSchoolFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the StudentSchool
     * 
    **/
    select?: StudentSchoolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentSchoolInclude | null
    /**
     * Throw an Error if a StudentSchool can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which StudentSchool to fetch.
     * 
    **/
    where: StudentSchoolWhereUniqueInput
  }


  /**
   * StudentSchool findFirst
   */
  export type StudentSchoolFindFirstArgs = {
    /**
     * Select specific fields to fetch from the StudentSchool
     * 
    **/
    select?: StudentSchoolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentSchoolInclude | null
    /**
     * Throw an Error if a StudentSchool can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which StudentSchool to fetch.
     * 
    **/
    where?: StudentSchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSchools to fetch.
     * 
    **/
    orderBy?: Enumerable<StudentSchoolOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSchools.
     * 
    **/
    cursor?: StudentSchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSchools from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSchools.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSchools.
     * 
    **/
    distinct?: Enumerable<StudentSchoolScalarFieldEnum>
  }


  /**
   * StudentSchool findMany
   */
  export type StudentSchoolFindManyArgs = {
    /**
     * Select specific fields to fetch from the StudentSchool
     * 
    **/
    select?: StudentSchoolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentSchoolInclude | null
    /**
     * Filter, which StudentSchools to fetch.
     * 
    **/
    where?: StudentSchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSchools to fetch.
     * 
    **/
    orderBy?: Enumerable<StudentSchoolOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentSchools.
     * 
    **/
    cursor?: StudentSchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSchools from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSchools.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StudentSchoolScalarFieldEnum>
  }


  /**
   * StudentSchool create
   */
  export type StudentSchoolCreateArgs = {
    /**
     * Select specific fields to fetch from the StudentSchool
     * 
    **/
    select?: StudentSchoolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentSchoolInclude | null
    /**
     * The data needed to create a StudentSchool.
     * 
    **/
    data: XOR<StudentSchoolCreateInput, StudentSchoolUncheckedCreateInput>
  }


  /**
   * StudentSchool createMany
   */
  export type StudentSchoolCreateManyArgs = {
    data: Enumerable<StudentSchoolCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * StudentSchool update
   */
  export type StudentSchoolUpdateArgs = {
    /**
     * Select specific fields to fetch from the StudentSchool
     * 
    **/
    select?: StudentSchoolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentSchoolInclude | null
    /**
     * The data needed to update a StudentSchool.
     * 
    **/
    data: XOR<StudentSchoolUpdateInput, StudentSchoolUncheckedUpdateInput>
    /**
     * Choose, which StudentSchool to update.
     * 
    **/
    where: StudentSchoolWhereUniqueInput
  }


  /**
   * StudentSchool updateMany
   */
  export type StudentSchoolUpdateManyArgs = {
    data: XOR<StudentSchoolUpdateManyMutationInput, StudentSchoolUncheckedUpdateManyInput>
    where?: StudentSchoolWhereInput
  }


  /**
   * StudentSchool upsert
   */
  export type StudentSchoolUpsertArgs = {
    /**
     * Select specific fields to fetch from the StudentSchool
     * 
    **/
    select?: StudentSchoolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentSchoolInclude | null
    /**
     * The filter to search for the StudentSchool to update in case it exists.
     * 
    **/
    where: StudentSchoolWhereUniqueInput
    /**
     * In case the StudentSchool found by the `where` argument doesn't exist, create a new StudentSchool with this data.
     * 
    **/
    create: XOR<StudentSchoolCreateInput, StudentSchoolUncheckedCreateInput>
    /**
     * In case the StudentSchool was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StudentSchoolUpdateInput, StudentSchoolUncheckedUpdateInput>
  }


  /**
   * StudentSchool delete
   */
  export type StudentSchoolDeleteArgs = {
    /**
     * Select specific fields to fetch from the StudentSchool
     * 
    **/
    select?: StudentSchoolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentSchoolInclude | null
    /**
     * Filter which StudentSchool to delete.
     * 
    **/
    where: StudentSchoolWhereUniqueInput
  }


  /**
   * StudentSchool deleteMany
   */
  export type StudentSchoolDeleteManyArgs = {
    where?: StudentSchoolWhereInput
  }


  /**
   * StudentSchool without action
   */
  export type StudentSchoolArgs = {
    /**
     * Select specific fields to fetch from the StudentSchool
     * 
    **/
    select?: StudentSchoolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentSchoolInclude | null
  }



  /**
   * Model StudyCategory
   */


  export type AggregateStudyCategory = {
    _count: StudyCategoryCountAggregateOutputType | null
    _avg: StudyCategoryAvgAggregateOutputType | null
    _sum: StudyCategorySumAggregateOutputType | null
    _min: StudyCategoryMinAggregateOutputType | null
    _max: StudyCategoryMaxAggregateOutputType | null
  }

  export type StudyCategoryAvgAggregateOutputType = {
    idStudyCategory: number | null
  }

  export type StudyCategorySumAggregateOutputType = {
    idStudyCategory: number | null
  }

  export type StudyCategoryMinAggregateOutputType = {
    idStudyCategory: number | null
    categoryName: string | null
  }

  export type StudyCategoryMaxAggregateOutputType = {
    idStudyCategory: number | null
    categoryName: string | null
  }

  export type StudyCategoryCountAggregateOutputType = {
    idStudyCategory: number
    categoryName: number
    _all: number
  }


  export type StudyCategoryAvgAggregateInputType = {
    idStudyCategory?: true
  }

  export type StudyCategorySumAggregateInputType = {
    idStudyCategory?: true
  }

  export type StudyCategoryMinAggregateInputType = {
    idStudyCategory?: true
    categoryName?: true
  }

  export type StudyCategoryMaxAggregateInputType = {
    idStudyCategory?: true
    categoryName?: true
  }

  export type StudyCategoryCountAggregateInputType = {
    idStudyCategory?: true
    categoryName?: true
    _all?: true
  }

  export type StudyCategoryAggregateArgs = {
    /**
     * Filter which StudyCategory to aggregate.
     * 
    **/
    where?: StudyCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<StudyCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StudyCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyCategories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudyCategories
    **/
    _count?: true | StudyCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudyCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudyCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudyCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudyCategoryMaxAggregateInputType
  }

  export type GetStudyCategoryAggregateType<T extends StudyCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateStudyCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudyCategory[P]>
      : GetScalarType<T[P], AggregateStudyCategory[P]>
  }


    
    
  export type StudyCategoryGroupByArgs = {
    where?: StudyCategoryWhereInput
    orderBy?: Enumerable<StudyCategoryOrderByWithAggregationInput>
    by: Array<StudyCategoryScalarFieldEnum>
    having?: StudyCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudyCategoryCountAggregateInputType | true
    _avg?: StudyCategoryAvgAggregateInputType
    _sum?: StudyCategorySumAggregateInputType
    _min?: StudyCategoryMinAggregateInputType
    _max?: StudyCategoryMaxAggregateInputType
  }


  export type StudyCategoryGroupByOutputType = {
    idStudyCategory: number
    categoryName: string
    _count: StudyCategoryCountAggregateOutputType | null
    _avg: StudyCategoryAvgAggregateOutputType | null
    _sum: StudyCategorySumAggregateOutputType | null
    _min: StudyCategoryMinAggregateOutputType | null
    _max: StudyCategoryMaxAggregateOutputType | null
  }

  type GetStudyCategoryGroupByPayload<T extends StudyCategoryGroupByArgs> = Promise<
    Array<
      PickArray<StudyCategoryGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof StudyCategoryGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], StudyCategoryGroupByOutputType[P]> 
            : GetScalarType<T[P], StudyCategoryGroupByOutputType[P]>
        }
      > 
    >


  export type StudyCategorySelect = {
    idStudyCategory?: boolean
    categoryName?: boolean
    StudySubCategory?: boolean | StudySubCategoryFindManyArgs
    _count?: boolean | StudyCategoryCountOutputTypeArgs
  }

  export type StudyCategoryInclude = {
    StudySubCategory?: boolean | StudySubCategoryFindManyArgs
    _count?: boolean | StudyCategoryCountOutputTypeArgs
  }

  export type StudyCategoryGetPayload<
    S extends boolean | null | undefined | StudyCategoryArgs,
    U = keyof S
      > = S extends true
        ? StudyCategory
    : S extends undefined
    ? never
    : S extends StudyCategoryArgs | StudyCategoryFindManyArgs
    ?'include' extends U
    ? StudyCategory  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'StudySubCategory'
        ? Array < StudySubCategoryGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? StudyCategoryCountOutputTypeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof StudyCategory ?StudyCategory [P]
  : 
          P extends 'StudySubCategory'
        ? Array < StudySubCategoryGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? StudyCategoryCountOutputTypeGetPayload<S['select'][P]> | null : never
  } 
    : StudyCategory
  : StudyCategory


  type StudyCategoryCountArgs = Merge<
    Omit<StudyCategoryFindManyArgs, 'select' | 'include'> & {
      select?: StudyCategoryCountAggregateInputType | true
    }
  >

  export interface StudyCategoryDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one StudyCategory that matches the filter.
     * @param {StudyCategoryFindUniqueArgs} args - Arguments to find a StudyCategory
     * @example
     * // Get one StudyCategory
     * const studyCategory = await prisma.studyCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudyCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StudyCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'StudyCategory'> extends True ? CheckSelect<T, Prisma__StudyCategoryClient<StudyCategory>, Prisma__StudyCategoryClient<StudyCategoryGetPayload<T>>> : CheckSelect<T, Prisma__StudyCategoryClient<StudyCategory | null >, Prisma__StudyCategoryClient<StudyCategoryGetPayload<T> | null >>

    /**
     * Find the first StudyCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyCategoryFindFirstArgs} args - Arguments to find a StudyCategory
     * @example
     * // Get one StudyCategory
     * const studyCategory = await prisma.studyCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudyCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StudyCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'StudyCategory'> extends True ? CheckSelect<T, Prisma__StudyCategoryClient<StudyCategory>, Prisma__StudyCategoryClient<StudyCategoryGetPayload<T>>> : CheckSelect<T, Prisma__StudyCategoryClient<StudyCategory | null >, Prisma__StudyCategoryClient<StudyCategoryGetPayload<T> | null >>

    /**
     * Find zero or more StudyCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudyCategories
     * const studyCategories = await prisma.studyCategory.findMany()
     * 
     * // Get first 10 StudyCategories
     * const studyCategories = await prisma.studyCategory.findMany({ take: 10 })
     * 
     * // Only select the `idStudyCategory`
     * const studyCategoryWithIdStudyCategoryOnly = await prisma.studyCategory.findMany({ select: { idStudyCategory: true } })
     * 
    **/
    findMany<T extends StudyCategoryFindManyArgs>(
      args?: SelectSubset<T, StudyCategoryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<StudyCategory>>, PrismaPromise<Array<StudyCategoryGetPayload<T>>>>

    /**
     * Create a StudyCategory.
     * @param {StudyCategoryCreateArgs} args - Arguments to create a StudyCategory.
     * @example
     * // Create one StudyCategory
     * const StudyCategory = await prisma.studyCategory.create({
     *   data: {
     *     // ... data to create a StudyCategory
     *   }
     * })
     * 
    **/
    create<T extends StudyCategoryCreateArgs>(
      args: SelectSubset<T, StudyCategoryCreateArgs>
    ): CheckSelect<T, Prisma__StudyCategoryClient<StudyCategory>, Prisma__StudyCategoryClient<StudyCategoryGetPayload<T>>>

    /**
     * Create many StudyCategories.
     *     @param {StudyCategoryCreateManyArgs} args - Arguments to create many StudyCategories.
     *     @example
     *     // Create many StudyCategories
     *     const studyCategory = await prisma.studyCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudyCategoryCreateManyArgs>(
      args?: SelectSubset<T, StudyCategoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a StudyCategory.
     * @param {StudyCategoryDeleteArgs} args - Arguments to delete one StudyCategory.
     * @example
     * // Delete one StudyCategory
     * const StudyCategory = await prisma.studyCategory.delete({
     *   where: {
     *     // ... filter to delete one StudyCategory
     *   }
     * })
     * 
    **/
    delete<T extends StudyCategoryDeleteArgs>(
      args: SelectSubset<T, StudyCategoryDeleteArgs>
    ): CheckSelect<T, Prisma__StudyCategoryClient<StudyCategory>, Prisma__StudyCategoryClient<StudyCategoryGetPayload<T>>>

    /**
     * Update one StudyCategory.
     * @param {StudyCategoryUpdateArgs} args - Arguments to update one StudyCategory.
     * @example
     * // Update one StudyCategory
     * const studyCategory = await prisma.studyCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudyCategoryUpdateArgs>(
      args: SelectSubset<T, StudyCategoryUpdateArgs>
    ): CheckSelect<T, Prisma__StudyCategoryClient<StudyCategory>, Prisma__StudyCategoryClient<StudyCategoryGetPayload<T>>>

    /**
     * Delete zero or more StudyCategories.
     * @param {StudyCategoryDeleteManyArgs} args - Arguments to filter StudyCategories to delete.
     * @example
     * // Delete a few StudyCategories
     * const { count } = await prisma.studyCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudyCategoryDeleteManyArgs>(
      args?: SelectSubset<T, StudyCategoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudyCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudyCategories
     * const studyCategory = await prisma.studyCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudyCategoryUpdateManyArgs>(
      args: SelectSubset<T, StudyCategoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one StudyCategory.
     * @param {StudyCategoryUpsertArgs} args - Arguments to update or create a StudyCategory.
     * @example
     * // Update or create a StudyCategory
     * const studyCategory = await prisma.studyCategory.upsert({
     *   create: {
     *     // ... data to create a StudyCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudyCategory we want to update
     *   }
     * })
    **/
    upsert<T extends StudyCategoryUpsertArgs>(
      args: SelectSubset<T, StudyCategoryUpsertArgs>
    ): CheckSelect<T, Prisma__StudyCategoryClient<StudyCategory>, Prisma__StudyCategoryClient<StudyCategoryGetPayload<T>>>

    /**
     * Count the number of StudyCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyCategoryCountArgs} args - Arguments to filter StudyCategories to count.
     * @example
     * // Count the number of StudyCategories
     * const count = await prisma.studyCategory.count({
     *   where: {
     *     // ... the filter for the StudyCategories we want to count
     *   }
     * })
    **/
    count<T extends StudyCategoryCountArgs>(
      args?: Subset<T, StudyCategoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudyCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudyCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudyCategoryAggregateArgs>(args: Subset<T, StudyCategoryAggregateArgs>): PrismaPromise<GetStudyCategoryAggregateType<T>>

    /**
     * Group by StudyCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudyCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudyCategoryGroupByArgs['orderBy'] }
        : { orderBy?: StudyCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudyCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudyCategoryGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudyCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StudyCategoryClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    StudySubCategory<T extends StudySubCategoryFindManyArgs = {}>(args?: Subset<T, StudySubCategoryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<StudySubCategory>>, PrismaPromise<Array<StudySubCategoryGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * StudyCategory findUnique
   */
  export type StudyCategoryFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the StudyCategory
     * 
    **/
    select?: StudyCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudyCategoryInclude | null
    /**
     * Throw an Error if a StudyCategory can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which StudyCategory to fetch.
     * 
    **/
    where: StudyCategoryWhereUniqueInput
  }


  /**
   * StudyCategory findFirst
   */
  export type StudyCategoryFindFirstArgs = {
    /**
     * Select specific fields to fetch from the StudyCategory
     * 
    **/
    select?: StudyCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudyCategoryInclude | null
    /**
     * Throw an Error if a StudyCategory can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which StudyCategory to fetch.
     * 
    **/
    where?: StudyCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<StudyCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudyCategories.
     * 
    **/
    cursor?: StudyCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyCategories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudyCategories.
     * 
    **/
    distinct?: Enumerable<StudyCategoryScalarFieldEnum>
  }


  /**
   * StudyCategory findMany
   */
  export type StudyCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the StudyCategory
     * 
    **/
    select?: StudyCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudyCategoryInclude | null
    /**
     * Filter, which StudyCategories to fetch.
     * 
    **/
    where?: StudyCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<StudyCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudyCategories.
     * 
    **/
    cursor?: StudyCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyCategories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StudyCategoryScalarFieldEnum>
  }


  /**
   * StudyCategory create
   */
  export type StudyCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the StudyCategory
     * 
    **/
    select?: StudyCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudyCategoryInclude | null
    /**
     * The data needed to create a StudyCategory.
     * 
    **/
    data: XOR<StudyCategoryCreateInput, StudyCategoryUncheckedCreateInput>
  }


  /**
   * StudyCategory createMany
   */
  export type StudyCategoryCreateManyArgs = {
    data: Enumerable<StudyCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * StudyCategory update
   */
  export type StudyCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the StudyCategory
     * 
    **/
    select?: StudyCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudyCategoryInclude | null
    /**
     * The data needed to update a StudyCategory.
     * 
    **/
    data: XOR<StudyCategoryUpdateInput, StudyCategoryUncheckedUpdateInput>
    /**
     * Choose, which StudyCategory to update.
     * 
    **/
    where: StudyCategoryWhereUniqueInput
  }


  /**
   * StudyCategory updateMany
   */
  export type StudyCategoryUpdateManyArgs = {
    data: XOR<StudyCategoryUpdateManyMutationInput, StudyCategoryUncheckedUpdateManyInput>
    where?: StudyCategoryWhereInput
  }


  /**
   * StudyCategory upsert
   */
  export type StudyCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the StudyCategory
     * 
    **/
    select?: StudyCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudyCategoryInclude | null
    /**
     * The filter to search for the StudyCategory to update in case it exists.
     * 
    **/
    where: StudyCategoryWhereUniqueInput
    /**
     * In case the StudyCategory found by the `where` argument doesn't exist, create a new StudyCategory with this data.
     * 
    **/
    create: XOR<StudyCategoryCreateInput, StudyCategoryUncheckedCreateInput>
    /**
     * In case the StudyCategory was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StudyCategoryUpdateInput, StudyCategoryUncheckedUpdateInput>
  }


  /**
   * StudyCategory delete
   */
  export type StudyCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the StudyCategory
     * 
    **/
    select?: StudyCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudyCategoryInclude | null
    /**
     * Filter which StudyCategory to delete.
     * 
    **/
    where: StudyCategoryWhereUniqueInput
  }


  /**
   * StudyCategory deleteMany
   */
  export type StudyCategoryDeleteManyArgs = {
    where?: StudyCategoryWhereInput
  }


  /**
   * StudyCategory without action
   */
  export type StudyCategoryArgs = {
    /**
     * Select specific fields to fetch from the StudyCategory
     * 
    **/
    select?: StudyCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudyCategoryInclude | null
  }



  /**
   * Model StudySubCategory
   */


  export type AggregateStudySubCategory = {
    _count: StudySubCategoryCountAggregateOutputType | null
    _avg: StudySubCategoryAvgAggregateOutputType | null
    _sum: StudySubCategorySumAggregateOutputType | null
    _min: StudySubCategoryMinAggregateOutputType | null
    _max: StudySubCategoryMaxAggregateOutputType | null
  }

  export type StudySubCategoryAvgAggregateOutputType = {
    idStudySubCategory: number | null
    studyCategoryId: number | null
  }

  export type StudySubCategorySumAggregateOutputType = {
    idStudySubCategory: number | null
    studyCategoryId: number | null
  }

  export type StudySubCategoryMinAggregateOutputType = {
    idStudySubCategory: number | null
    subCategoryName: string | null
    studyCategoryId: number | null
  }

  export type StudySubCategoryMaxAggregateOutputType = {
    idStudySubCategory: number | null
    subCategoryName: string | null
    studyCategoryId: number | null
  }

  export type StudySubCategoryCountAggregateOutputType = {
    idStudySubCategory: number
    subCategoryName: number
    studyCategoryId: number
    _all: number
  }


  export type StudySubCategoryAvgAggregateInputType = {
    idStudySubCategory?: true
    studyCategoryId?: true
  }

  export type StudySubCategorySumAggregateInputType = {
    idStudySubCategory?: true
    studyCategoryId?: true
  }

  export type StudySubCategoryMinAggregateInputType = {
    idStudySubCategory?: true
    subCategoryName?: true
    studyCategoryId?: true
  }

  export type StudySubCategoryMaxAggregateInputType = {
    idStudySubCategory?: true
    subCategoryName?: true
    studyCategoryId?: true
  }

  export type StudySubCategoryCountAggregateInputType = {
    idStudySubCategory?: true
    subCategoryName?: true
    studyCategoryId?: true
    _all?: true
  }

  export type StudySubCategoryAggregateArgs = {
    /**
     * Filter which StudySubCategory to aggregate.
     * 
    **/
    where?: StudySubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudySubCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<StudySubCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StudySubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudySubCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudySubCategories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudySubCategories
    **/
    _count?: true | StudySubCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudySubCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudySubCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudySubCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudySubCategoryMaxAggregateInputType
  }

  export type GetStudySubCategoryAggregateType<T extends StudySubCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateStudySubCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudySubCategory[P]>
      : GetScalarType<T[P], AggregateStudySubCategory[P]>
  }


    
    
  export type StudySubCategoryGroupByArgs = {
    where?: StudySubCategoryWhereInput
    orderBy?: Enumerable<StudySubCategoryOrderByWithAggregationInput>
    by: Array<StudySubCategoryScalarFieldEnum>
    having?: StudySubCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudySubCategoryCountAggregateInputType | true
    _avg?: StudySubCategoryAvgAggregateInputType
    _sum?: StudySubCategorySumAggregateInputType
    _min?: StudySubCategoryMinAggregateInputType
    _max?: StudySubCategoryMaxAggregateInputType
  }


  export type StudySubCategoryGroupByOutputType = {
    idStudySubCategory: number
    subCategoryName: string
    studyCategoryId: number
    _count: StudySubCategoryCountAggregateOutputType | null
    _avg: StudySubCategoryAvgAggregateOutputType | null
    _sum: StudySubCategorySumAggregateOutputType | null
    _min: StudySubCategoryMinAggregateOutputType | null
    _max: StudySubCategoryMaxAggregateOutputType | null
  }

  type GetStudySubCategoryGroupByPayload<T extends StudySubCategoryGroupByArgs> = Promise<
    Array<
      PickArray<StudySubCategoryGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof StudySubCategoryGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], StudySubCategoryGroupByOutputType[P]> 
            : GetScalarType<T[P], StudySubCategoryGroupByOutputType[P]>
        }
      > 
    >


  export type StudySubCategorySelect = {
    idStudySubCategory?: boolean
    subCategoryName?: boolean
    studyCategory?: boolean | StudyCategoryArgs
    studyCategoryId?: boolean
    StudentSchool?: boolean | StudentSchoolFindManyArgs
    _count?: boolean | StudySubCategoryCountOutputTypeArgs
  }

  export type StudySubCategoryInclude = {
    studyCategory?: boolean | StudyCategoryArgs
    StudentSchool?: boolean | StudentSchoolFindManyArgs
    _count?: boolean | StudySubCategoryCountOutputTypeArgs
  }

  export type StudySubCategoryGetPayload<
    S extends boolean | null | undefined | StudySubCategoryArgs,
    U = keyof S
      > = S extends true
        ? StudySubCategory
    : S extends undefined
    ? never
    : S extends StudySubCategoryArgs | StudySubCategoryFindManyArgs
    ?'include' extends U
    ? StudySubCategory  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'studyCategory'
        ? StudyCategoryGetPayload<S['include'][P]> :
        P extends 'StudentSchool'
        ? Array < StudentSchoolGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? StudySubCategoryCountOutputTypeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof StudySubCategory ?StudySubCategory [P]
  : 
          P extends 'studyCategory'
        ? StudyCategoryGetPayload<S['select'][P]> :
        P extends 'StudentSchool'
        ? Array < StudentSchoolGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? StudySubCategoryCountOutputTypeGetPayload<S['select'][P]> | null : never
  } 
    : StudySubCategory
  : StudySubCategory


  type StudySubCategoryCountArgs = Merge<
    Omit<StudySubCategoryFindManyArgs, 'select' | 'include'> & {
      select?: StudySubCategoryCountAggregateInputType | true
    }
  >

  export interface StudySubCategoryDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one StudySubCategory that matches the filter.
     * @param {StudySubCategoryFindUniqueArgs} args - Arguments to find a StudySubCategory
     * @example
     * // Get one StudySubCategory
     * const studySubCategory = await prisma.studySubCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudySubCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StudySubCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'StudySubCategory'> extends True ? CheckSelect<T, Prisma__StudySubCategoryClient<StudySubCategory>, Prisma__StudySubCategoryClient<StudySubCategoryGetPayload<T>>> : CheckSelect<T, Prisma__StudySubCategoryClient<StudySubCategory | null >, Prisma__StudySubCategoryClient<StudySubCategoryGetPayload<T> | null >>

    /**
     * Find the first StudySubCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudySubCategoryFindFirstArgs} args - Arguments to find a StudySubCategory
     * @example
     * // Get one StudySubCategory
     * const studySubCategory = await prisma.studySubCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudySubCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StudySubCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'StudySubCategory'> extends True ? CheckSelect<T, Prisma__StudySubCategoryClient<StudySubCategory>, Prisma__StudySubCategoryClient<StudySubCategoryGetPayload<T>>> : CheckSelect<T, Prisma__StudySubCategoryClient<StudySubCategory | null >, Prisma__StudySubCategoryClient<StudySubCategoryGetPayload<T> | null >>

    /**
     * Find zero or more StudySubCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudySubCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudySubCategories
     * const studySubCategories = await prisma.studySubCategory.findMany()
     * 
     * // Get first 10 StudySubCategories
     * const studySubCategories = await prisma.studySubCategory.findMany({ take: 10 })
     * 
     * // Only select the `idStudySubCategory`
     * const studySubCategoryWithIdStudySubCategoryOnly = await prisma.studySubCategory.findMany({ select: { idStudySubCategory: true } })
     * 
    **/
    findMany<T extends StudySubCategoryFindManyArgs>(
      args?: SelectSubset<T, StudySubCategoryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<StudySubCategory>>, PrismaPromise<Array<StudySubCategoryGetPayload<T>>>>

    /**
     * Create a StudySubCategory.
     * @param {StudySubCategoryCreateArgs} args - Arguments to create a StudySubCategory.
     * @example
     * // Create one StudySubCategory
     * const StudySubCategory = await prisma.studySubCategory.create({
     *   data: {
     *     // ... data to create a StudySubCategory
     *   }
     * })
     * 
    **/
    create<T extends StudySubCategoryCreateArgs>(
      args: SelectSubset<T, StudySubCategoryCreateArgs>
    ): CheckSelect<T, Prisma__StudySubCategoryClient<StudySubCategory>, Prisma__StudySubCategoryClient<StudySubCategoryGetPayload<T>>>

    /**
     * Create many StudySubCategories.
     *     @param {StudySubCategoryCreateManyArgs} args - Arguments to create many StudySubCategories.
     *     @example
     *     // Create many StudySubCategories
     *     const studySubCategory = await prisma.studySubCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudySubCategoryCreateManyArgs>(
      args?: SelectSubset<T, StudySubCategoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a StudySubCategory.
     * @param {StudySubCategoryDeleteArgs} args - Arguments to delete one StudySubCategory.
     * @example
     * // Delete one StudySubCategory
     * const StudySubCategory = await prisma.studySubCategory.delete({
     *   where: {
     *     // ... filter to delete one StudySubCategory
     *   }
     * })
     * 
    **/
    delete<T extends StudySubCategoryDeleteArgs>(
      args: SelectSubset<T, StudySubCategoryDeleteArgs>
    ): CheckSelect<T, Prisma__StudySubCategoryClient<StudySubCategory>, Prisma__StudySubCategoryClient<StudySubCategoryGetPayload<T>>>

    /**
     * Update one StudySubCategory.
     * @param {StudySubCategoryUpdateArgs} args - Arguments to update one StudySubCategory.
     * @example
     * // Update one StudySubCategory
     * const studySubCategory = await prisma.studySubCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudySubCategoryUpdateArgs>(
      args: SelectSubset<T, StudySubCategoryUpdateArgs>
    ): CheckSelect<T, Prisma__StudySubCategoryClient<StudySubCategory>, Prisma__StudySubCategoryClient<StudySubCategoryGetPayload<T>>>

    /**
     * Delete zero or more StudySubCategories.
     * @param {StudySubCategoryDeleteManyArgs} args - Arguments to filter StudySubCategories to delete.
     * @example
     * // Delete a few StudySubCategories
     * const { count } = await prisma.studySubCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudySubCategoryDeleteManyArgs>(
      args?: SelectSubset<T, StudySubCategoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudySubCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudySubCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudySubCategories
     * const studySubCategory = await prisma.studySubCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudySubCategoryUpdateManyArgs>(
      args: SelectSubset<T, StudySubCategoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one StudySubCategory.
     * @param {StudySubCategoryUpsertArgs} args - Arguments to update or create a StudySubCategory.
     * @example
     * // Update or create a StudySubCategory
     * const studySubCategory = await prisma.studySubCategory.upsert({
     *   create: {
     *     // ... data to create a StudySubCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudySubCategory we want to update
     *   }
     * })
    **/
    upsert<T extends StudySubCategoryUpsertArgs>(
      args: SelectSubset<T, StudySubCategoryUpsertArgs>
    ): CheckSelect<T, Prisma__StudySubCategoryClient<StudySubCategory>, Prisma__StudySubCategoryClient<StudySubCategoryGetPayload<T>>>

    /**
     * Count the number of StudySubCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudySubCategoryCountArgs} args - Arguments to filter StudySubCategories to count.
     * @example
     * // Count the number of StudySubCategories
     * const count = await prisma.studySubCategory.count({
     *   where: {
     *     // ... the filter for the StudySubCategories we want to count
     *   }
     * })
    **/
    count<T extends StudySubCategoryCountArgs>(
      args?: Subset<T, StudySubCategoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudySubCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudySubCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudySubCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudySubCategoryAggregateArgs>(args: Subset<T, StudySubCategoryAggregateArgs>): PrismaPromise<GetStudySubCategoryAggregateType<T>>

    /**
     * Group by StudySubCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudySubCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudySubCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudySubCategoryGroupByArgs['orderBy'] }
        : { orderBy?: StudySubCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudySubCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudySubCategoryGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudySubCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StudySubCategoryClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    studyCategory<T extends StudyCategoryArgs = {}>(args?: Subset<T, StudyCategoryArgs>): CheckSelect<T, Prisma__StudyCategoryClient<StudyCategory | null >, Prisma__StudyCategoryClient<StudyCategoryGetPayload<T> | null >>;

    StudentSchool<T extends StudentSchoolFindManyArgs = {}>(args?: Subset<T, StudentSchoolFindManyArgs>): CheckSelect<T, PrismaPromise<Array<StudentSchool>>, PrismaPromise<Array<StudentSchoolGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * StudySubCategory findUnique
   */
  export type StudySubCategoryFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the StudySubCategory
     * 
    **/
    select?: StudySubCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudySubCategoryInclude | null
    /**
     * Throw an Error if a StudySubCategory can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which StudySubCategory to fetch.
     * 
    **/
    where: StudySubCategoryWhereUniqueInput
  }


  /**
   * StudySubCategory findFirst
   */
  export type StudySubCategoryFindFirstArgs = {
    /**
     * Select specific fields to fetch from the StudySubCategory
     * 
    **/
    select?: StudySubCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudySubCategoryInclude | null
    /**
     * Throw an Error if a StudySubCategory can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which StudySubCategory to fetch.
     * 
    **/
    where?: StudySubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudySubCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<StudySubCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudySubCategories.
     * 
    **/
    cursor?: StudySubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudySubCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudySubCategories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudySubCategories.
     * 
    **/
    distinct?: Enumerable<StudySubCategoryScalarFieldEnum>
  }


  /**
   * StudySubCategory findMany
   */
  export type StudySubCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the StudySubCategory
     * 
    **/
    select?: StudySubCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudySubCategoryInclude | null
    /**
     * Filter, which StudySubCategories to fetch.
     * 
    **/
    where?: StudySubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudySubCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<StudySubCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudySubCategories.
     * 
    **/
    cursor?: StudySubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudySubCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudySubCategories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StudySubCategoryScalarFieldEnum>
  }


  /**
   * StudySubCategory create
   */
  export type StudySubCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the StudySubCategory
     * 
    **/
    select?: StudySubCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudySubCategoryInclude | null
    /**
     * The data needed to create a StudySubCategory.
     * 
    **/
    data: XOR<StudySubCategoryCreateInput, StudySubCategoryUncheckedCreateInput>
  }


  /**
   * StudySubCategory createMany
   */
  export type StudySubCategoryCreateManyArgs = {
    data: Enumerable<StudySubCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * StudySubCategory update
   */
  export type StudySubCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the StudySubCategory
     * 
    **/
    select?: StudySubCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudySubCategoryInclude | null
    /**
     * The data needed to update a StudySubCategory.
     * 
    **/
    data: XOR<StudySubCategoryUpdateInput, StudySubCategoryUncheckedUpdateInput>
    /**
     * Choose, which StudySubCategory to update.
     * 
    **/
    where: StudySubCategoryWhereUniqueInput
  }


  /**
   * StudySubCategory updateMany
   */
  export type StudySubCategoryUpdateManyArgs = {
    data: XOR<StudySubCategoryUpdateManyMutationInput, StudySubCategoryUncheckedUpdateManyInput>
    where?: StudySubCategoryWhereInput
  }


  /**
   * StudySubCategory upsert
   */
  export type StudySubCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the StudySubCategory
     * 
    **/
    select?: StudySubCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudySubCategoryInclude | null
    /**
     * The filter to search for the StudySubCategory to update in case it exists.
     * 
    **/
    where: StudySubCategoryWhereUniqueInput
    /**
     * In case the StudySubCategory found by the `where` argument doesn't exist, create a new StudySubCategory with this data.
     * 
    **/
    create: XOR<StudySubCategoryCreateInput, StudySubCategoryUncheckedCreateInput>
    /**
     * In case the StudySubCategory was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StudySubCategoryUpdateInput, StudySubCategoryUncheckedUpdateInput>
  }


  /**
   * StudySubCategory delete
   */
  export type StudySubCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the StudySubCategory
     * 
    **/
    select?: StudySubCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudySubCategoryInclude | null
    /**
     * Filter which StudySubCategory to delete.
     * 
    **/
    where: StudySubCategoryWhereUniqueInput
  }


  /**
   * StudySubCategory deleteMany
   */
  export type StudySubCategoryDeleteManyArgs = {
    where?: StudySubCategoryWhereInput
  }


  /**
   * StudySubCategory without action
   */
  export type StudySubCategoryArgs = {
    /**
     * Select specific fields to fetch from the StudySubCategory
     * 
    **/
    select?: StudySubCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudySubCategoryInclude | null
  }



  /**
   * Model CertificateStatus
   */


  export type AggregateCertificateStatus = {
    _count: CertificateStatusCountAggregateOutputType | null
    _avg: CertificateStatusAvgAggregateOutputType | null
    _sum: CertificateStatusSumAggregateOutputType | null
    _min: CertificateStatusMinAggregateOutputType | null
    _max: CertificateStatusMaxAggregateOutputType | null
  }

  export type CertificateStatusAvgAggregateOutputType = {
    idCertificateStatus: number | null
  }

  export type CertificateStatusSumAggregateOutputType = {
    idCertificateStatus: number | null
  }

  export type CertificateStatusMinAggregateOutputType = {
    idCertificateStatus: number | null
    certificateStatusName: string | null
  }

  export type CertificateStatusMaxAggregateOutputType = {
    idCertificateStatus: number | null
    certificateStatusName: string | null
  }

  export type CertificateStatusCountAggregateOutputType = {
    idCertificateStatus: number
    certificateStatusName: number
    _all: number
  }


  export type CertificateStatusAvgAggregateInputType = {
    idCertificateStatus?: true
  }

  export type CertificateStatusSumAggregateInputType = {
    idCertificateStatus?: true
  }

  export type CertificateStatusMinAggregateInputType = {
    idCertificateStatus?: true
    certificateStatusName?: true
  }

  export type CertificateStatusMaxAggregateInputType = {
    idCertificateStatus?: true
    certificateStatusName?: true
  }

  export type CertificateStatusCountAggregateInputType = {
    idCertificateStatus?: true
    certificateStatusName?: true
    _all?: true
  }

  export type CertificateStatusAggregateArgs = {
    /**
     * Filter which CertificateStatus to aggregate.
     * 
    **/
    where?: CertificateStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CertificateStatuses to fetch.
     * 
    **/
    orderBy?: Enumerable<CertificateStatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CertificateStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CertificateStatuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CertificateStatuses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CertificateStatuses
    **/
    _count?: true | CertificateStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CertificateStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CertificateStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificateStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificateStatusMaxAggregateInputType
  }

  export type GetCertificateStatusAggregateType<T extends CertificateStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificateStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificateStatus[P]>
      : GetScalarType<T[P], AggregateCertificateStatus[P]>
  }


    
    
  export type CertificateStatusGroupByArgs = {
    where?: CertificateStatusWhereInput
    orderBy?: Enumerable<CertificateStatusOrderByWithAggregationInput>
    by: Array<CertificateStatusScalarFieldEnum>
    having?: CertificateStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificateStatusCountAggregateInputType | true
    _avg?: CertificateStatusAvgAggregateInputType
    _sum?: CertificateStatusSumAggregateInputType
    _min?: CertificateStatusMinAggregateInputType
    _max?: CertificateStatusMaxAggregateInputType
  }


  export type CertificateStatusGroupByOutputType = {
    idCertificateStatus: number
    certificateStatusName: string
    _count: CertificateStatusCountAggregateOutputType | null
    _avg: CertificateStatusAvgAggregateOutputType | null
    _sum: CertificateStatusSumAggregateOutputType | null
    _min: CertificateStatusMinAggregateOutputType | null
    _max: CertificateStatusMaxAggregateOutputType | null
  }

  type GetCertificateStatusGroupByPayload<T extends CertificateStatusGroupByArgs> = Promise<
    Array<
      PickArray<CertificateStatusGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof CertificateStatusGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], CertificateStatusGroupByOutputType[P]> 
            : GetScalarType<T[P], CertificateStatusGroupByOutputType[P]>
        }
      > 
    >


  export type CertificateStatusSelect = {
    idCertificateStatus?: boolean
    certificateStatusName?: boolean
    studentSchool?: boolean | StudentSchoolFindManyArgs
    _count?: boolean | CertificateStatusCountOutputTypeArgs
  }

  export type CertificateStatusInclude = {
    studentSchool?: boolean | StudentSchoolFindManyArgs
    _count?: boolean | CertificateStatusCountOutputTypeArgs
  }

  export type CertificateStatusGetPayload<
    S extends boolean | null | undefined | CertificateStatusArgs,
    U = keyof S
      > = S extends true
        ? CertificateStatus
    : S extends undefined
    ? never
    : S extends CertificateStatusArgs | CertificateStatusFindManyArgs
    ?'include' extends U
    ? CertificateStatus  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'studentSchool'
        ? Array < StudentSchoolGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? CertificateStatusCountOutputTypeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CertificateStatus ?CertificateStatus [P]
  : 
          P extends 'studentSchool'
        ? Array < StudentSchoolGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? CertificateStatusCountOutputTypeGetPayload<S['select'][P]> | null : never
  } 
    : CertificateStatus
  : CertificateStatus


  type CertificateStatusCountArgs = Merge<
    Omit<CertificateStatusFindManyArgs, 'select' | 'include'> & {
      select?: CertificateStatusCountAggregateInputType | true
    }
  >

  export interface CertificateStatusDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CertificateStatus that matches the filter.
     * @param {CertificateStatusFindUniqueArgs} args - Arguments to find a CertificateStatus
     * @example
     * // Get one CertificateStatus
     * const certificateStatus = await prisma.certificateStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CertificateStatusFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CertificateStatusFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CertificateStatus'> extends True ? CheckSelect<T, Prisma__CertificateStatusClient<CertificateStatus>, Prisma__CertificateStatusClient<CertificateStatusGetPayload<T>>> : CheckSelect<T, Prisma__CertificateStatusClient<CertificateStatus | null >, Prisma__CertificateStatusClient<CertificateStatusGetPayload<T> | null >>

    /**
     * Find the first CertificateStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateStatusFindFirstArgs} args - Arguments to find a CertificateStatus
     * @example
     * // Get one CertificateStatus
     * const certificateStatus = await prisma.certificateStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CertificateStatusFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CertificateStatusFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CertificateStatus'> extends True ? CheckSelect<T, Prisma__CertificateStatusClient<CertificateStatus>, Prisma__CertificateStatusClient<CertificateStatusGetPayload<T>>> : CheckSelect<T, Prisma__CertificateStatusClient<CertificateStatus | null >, Prisma__CertificateStatusClient<CertificateStatusGetPayload<T> | null >>

    /**
     * Find zero or more CertificateStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateStatusFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CertificateStatuses
     * const certificateStatuses = await prisma.certificateStatus.findMany()
     * 
     * // Get first 10 CertificateStatuses
     * const certificateStatuses = await prisma.certificateStatus.findMany({ take: 10 })
     * 
     * // Only select the `idCertificateStatus`
     * const certificateStatusWithIdCertificateStatusOnly = await prisma.certificateStatus.findMany({ select: { idCertificateStatus: true } })
     * 
    **/
    findMany<T extends CertificateStatusFindManyArgs>(
      args?: SelectSubset<T, CertificateStatusFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CertificateStatus>>, PrismaPromise<Array<CertificateStatusGetPayload<T>>>>

    /**
     * Create a CertificateStatus.
     * @param {CertificateStatusCreateArgs} args - Arguments to create a CertificateStatus.
     * @example
     * // Create one CertificateStatus
     * const CertificateStatus = await prisma.certificateStatus.create({
     *   data: {
     *     // ... data to create a CertificateStatus
     *   }
     * })
     * 
    **/
    create<T extends CertificateStatusCreateArgs>(
      args: SelectSubset<T, CertificateStatusCreateArgs>
    ): CheckSelect<T, Prisma__CertificateStatusClient<CertificateStatus>, Prisma__CertificateStatusClient<CertificateStatusGetPayload<T>>>

    /**
     * Create many CertificateStatuses.
     *     @param {CertificateStatusCreateManyArgs} args - Arguments to create many CertificateStatuses.
     *     @example
     *     // Create many CertificateStatuses
     *     const certificateStatus = await prisma.certificateStatus.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CertificateStatusCreateManyArgs>(
      args?: SelectSubset<T, CertificateStatusCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CertificateStatus.
     * @param {CertificateStatusDeleteArgs} args - Arguments to delete one CertificateStatus.
     * @example
     * // Delete one CertificateStatus
     * const CertificateStatus = await prisma.certificateStatus.delete({
     *   where: {
     *     // ... filter to delete one CertificateStatus
     *   }
     * })
     * 
    **/
    delete<T extends CertificateStatusDeleteArgs>(
      args: SelectSubset<T, CertificateStatusDeleteArgs>
    ): CheckSelect<T, Prisma__CertificateStatusClient<CertificateStatus>, Prisma__CertificateStatusClient<CertificateStatusGetPayload<T>>>

    /**
     * Update one CertificateStatus.
     * @param {CertificateStatusUpdateArgs} args - Arguments to update one CertificateStatus.
     * @example
     * // Update one CertificateStatus
     * const certificateStatus = await prisma.certificateStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CertificateStatusUpdateArgs>(
      args: SelectSubset<T, CertificateStatusUpdateArgs>
    ): CheckSelect<T, Prisma__CertificateStatusClient<CertificateStatus>, Prisma__CertificateStatusClient<CertificateStatusGetPayload<T>>>

    /**
     * Delete zero or more CertificateStatuses.
     * @param {CertificateStatusDeleteManyArgs} args - Arguments to filter CertificateStatuses to delete.
     * @example
     * // Delete a few CertificateStatuses
     * const { count } = await prisma.certificateStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CertificateStatusDeleteManyArgs>(
      args?: SelectSubset<T, CertificateStatusDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CertificateStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CertificateStatuses
     * const certificateStatus = await prisma.certificateStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CertificateStatusUpdateManyArgs>(
      args: SelectSubset<T, CertificateStatusUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CertificateStatus.
     * @param {CertificateStatusUpsertArgs} args - Arguments to update or create a CertificateStatus.
     * @example
     * // Update or create a CertificateStatus
     * const certificateStatus = await prisma.certificateStatus.upsert({
     *   create: {
     *     // ... data to create a CertificateStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CertificateStatus we want to update
     *   }
     * })
    **/
    upsert<T extends CertificateStatusUpsertArgs>(
      args: SelectSubset<T, CertificateStatusUpsertArgs>
    ): CheckSelect<T, Prisma__CertificateStatusClient<CertificateStatus>, Prisma__CertificateStatusClient<CertificateStatusGetPayload<T>>>

    /**
     * Count the number of CertificateStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateStatusCountArgs} args - Arguments to filter CertificateStatuses to count.
     * @example
     * // Count the number of CertificateStatuses
     * const count = await prisma.certificateStatus.count({
     *   where: {
     *     // ... the filter for the CertificateStatuses we want to count
     *   }
     * })
    **/
    count<T extends CertificateStatusCountArgs>(
      args?: Subset<T, CertificateStatusCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificateStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CertificateStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificateStatusAggregateArgs>(args: Subset<T, CertificateStatusAggregateArgs>): PrismaPromise<GetCertificateStatusAggregateType<T>>

    /**
     * Group by CertificateStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificateStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificateStatusGroupByArgs['orderBy'] }
        : { orderBy?: CertificateStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificateStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificateStatusGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CertificateStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CertificateStatusClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    studentSchool<T extends StudentSchoolFindManyArgs = {}>(args?: Subset<T, StudentSchoolFindManyArgs>): CheckSelect<T, PrismaPromise<Array<StudentSchool>>, PrismaPromise<Array<StudentSchoolGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CertificateStatus findUnique
   */
  export type CertificateStatusFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CertificateStatus
     * 
    **/
    select?: CertificateStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CertificateStatusInclude | null
    /**
     * Throw an Error if a CertificateStatus can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CertificateStatus to fetch.
     * 
    **/
    where: CertificateStatusWhereUniqueInput
  }


  /**
   * CertificateStatus findFirst
   */
  export type CertificateStatusFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CertificateStatus
     * 
    **/
    select?: CertificateStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CertificateStatusInclude | null
    /**
     * Throw an Error if a CertificateStatus can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CertificateStatus to fetch.
     * 
    **/
    where?: CertificateStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CertificateStatuses to fetch.
     * 
    **/
    orderBy?: Enumerable<CertificateStatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CertificateStatuses.
     * 
    **/
    cursor?: CertificateStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CertificateStatuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CertificateStatuses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CertificateStatuses.
     * 
    **/
    distinct?: Enumerable<CertificateStatusScalarFieldEnum>
  }


  /**
   * CertificateStatus findMany
   */
  export type CertificateStatusFindManyArgs = {
    /**
     * Select specific fields to fetch from the CertificateStatus
     * 
    **/
    select?: CertificateStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CertificateStatusInclude | null
    /**
     * Filter, which CertificateStatuses to fetch.
     * 
    **/
    where?: CertificateStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CertificateStatuses to fetch.
     * 
    **/
    orderBy?: Enumerable<CertificateStatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CertificateStatuses.
     * 
    **/
    cursor?: CertificateStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CertificateStatuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CertificateStatuses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CertificateStatusScalarFieldEnum>
  }


  /**
   * CertificateStatus create
   */
  export type CertificateStatusCreateArgs = {
    /**
     * Select specific fields to fetch from the CertificateStatus
     * 
    **/
    select?: CertificateStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CertificateStatusInclude | null
    /**
     * The data needed to create a CertificateStatus.
     * 
    **/
    data: XOR<CertificateStatusCreateInput, CertificateStatusUncheckedCreateInput>
  }


  /**
   * CertificateStatus createMany
   */
  export type CertificateStatusCreateManyArgs = {
    data: Enumerable<CertificateStatusCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CertificateStatus update
   */
  export type CertificateStatusUpdateArgs = {
    /**
     * Select specific fields to fetch from the CertificateStatus
     * 
    **/
    select?: CertificateStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CertificateStatusInclude | null
    /**
     * The data needed to update a CertificateStatus.
     * 
    **/
    data: XOR<CertificateStatusUpdateInput, CertificateStatusUncheckedUpdateInput>
    /**
     * Choose, which CertificateStatus to update.
     * 
    **/
    where: CertificateStatusWhereUniqueInput
  }


  /**
   * CertificateStatus updateMany
   */
  export type CertificateStatusUpdateManyArgs = {
    data: XOR<CertificateStatusUpdateManyMutationInput, CertificateStatusUncheckedUpdateManyInput>
    where?: CertificateStatusWhereInput
  }


  /**
   * CertificateStatus upsert
   */
  export type CertificateStatusUpsertArgs = {
    /**
     * Select specific fields to fetch from the CertificateStatus
     * 
    **/
    select?: CertificateStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CertificateStatusInclude | null
    /**
     * The filter to search for the CertificateStatus to update in case it exists.
     * 
    **/
    where: CertificateStatusWhereUniqueInput
    /**
     * In case the CertificateStatus found by the `where` argument doesn't exist, create a new CertificateStatus with this data.
     * 
    **/
    create: XOR<CertificateStatusCreateInput, CertificateStatusUncheckedCreateInput>
    /**
     * In case the CertificateStatus was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CertificateStatusUpdateInput, CertificateStatusUncheckedUpdateInput>
  }


  /**
   * CertificateStatus delete
   */
  export type CertificateStatusDeleteArgs = {
    /**
     * Select specific fields to fetch from the CertificateStatus
     * 
    **/
    select?: CertificateStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CertificateStatusInclude | null
    /**
     * Filter which CertificateStatus to delete.
     * 
    **/
    where: CertificateStatusWhereUniqueInput
  }


  /**
   * CertificateStatus deleteMany
   */
  export type CertificateStatusDeleteManyArgs = {
    where?: CertificateStatusWhereInput
  }


  /**
   * CertificateStatus without action
   */
  export type CertificateStatusArgs = {
    /**
     * Select specific fields to fetch from the CertificateStatus
     * 
    **/
    select?: CertificateStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CertificateStatusInclude | null
  }



  /**
   * Model StudentStatus
   */


  export type AggregateStudentStatus = {
    _count: StudentStatusCountAggregateOutputType | null
    _avg: StudentStatusAvgAggregateOutputType | null
    _sum: StudentStatusSumAggregateOutputType | null
    _min: StudentStatusMinAggregateOutputType | null
    _max: StudentStatusMaxAggregateOutputType | null
  }

  export type StudentStatusAvgAggregateOutputType = {
    idStudentStatus: number | null
  }

  export type StudentStatusSumAggregateOutputType = {
    idStudentStatus: number | null
  }

  export type StudentStatusMinAggregateOutputType = {
    idStudentStatus: number | null
    statusName: string | null
  }

  export type StudentStatusMaxAggregateOutputType = {
    idStudentStatus: number | null
    statusName: string | null
  }

  export type StudentStatusCountAggregateOutputType = {
    idStudentStatus: number
    statusName: number
    _all: number
  }


  export type StudentStatusAvgAggregateInputType = {
    idStudentStatus?: true
  }

  export type StudentStatusSumAggregateInputType = {
    idStudentStatus?: true
  }

  export type StudentStatusMinAggregateInputType = {
    idStudentStatus?: true
    statusName?: true
  }

  export type StudentStatusMaxAggregateInputType = {
    idStudentStatus?: true
    statusName?: true
  }

  export type StudentStatusCountAggregateInputType = {
    idStudentStatus?: true
    statusName?: true
    _all?: true
  }

  export type StudentStatusAggregateArgs = {
    /**
     * Filter which StudentStatus to aggregate.
     * 
    **/
    where?: StudentStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentStatuses to fetch.
     * 
    **/
    orderBy?: Enumerable<StudentStatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StudentStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentStatuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentStatuses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentStatuses
    **/
    _count?: true | StudentStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentStatusMaxAggregateInputType
  }

  export type GetStudentStatusAggregateType<T extends StudentStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentStatus[P]>
      : GetScalarType<T[P], AggregateStudentStatus[P]>
  }


    
    
  export type StudentStatusGroupByArgs = {
    where?: StudentStatusWhereInput
    orderBy?: Enumerable<StudentStatusOrderByWithAggregationInput>
    by: Array<StudentStatusScalarFieldEnum>
    having?: StudentStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentStatusCountAggregateInputType | true
    _avg?: StudentStatusAvgAggregateInputType
    _sum?: StudentStatusSumAggregateInputType
    _min?: StudentStatusMinAggregateInputType
    _max?: StudentStatusMaxAggregateInputType
  }


  export type StudentStatusGroupByOutputType = {
    idStudentStatus: number
    statusName: string
    _count: StudentStatusCountAggregateOutputType | null
    _avg: StudentStatusAvgAggregateOutputType | null
    _sum: StudentStatusSumAggregateOutputType | null
    _min: StudentStatusMinAggregateOutputType | null
    _max: StudentStatusMaxAggregateOutputType | null
  }

  type GetStudentStatusGroupByPayload<T extends StudentStatusGroupByArgs> = Promise<
    Array<
      PickArray<StudentStatusGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof StudentStatusGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], StudentStatusGroupByOutputType[P]> 
            : GetScalarType<T[P], StudentStatusGroupByOutputType[P]>
        }
      > 
    >


  export type StudentStatusSelect = {
    idStudentStatus?: boolean
    statusName?: boolean
    students?: boolean | StudentFindManyArgs
    _count?: boolean | StudentStatusCountOutputTypeArgs
  }

  export type StudentStatusInclude = {
    students?: boolean | StudentFindManyArgs
    _count?: boolean | StudentStatusCountOutputTypeArgs
  }

  export type StudentStatusGetPayload<
    S extends boolean | null | undefined | StudentStatusArgs,
    U = keyof S
      > = S extends true
        ? StudentStatus
    : S extends undefined
    ? never
    : S extends StudentStatusArgs | StudentStatusFindManyArgs
    ?'include' extends U
    ? StudentStatus  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'students'
        ? Array < StudentGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? StudentStatusCountOutputTypeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof StudentStatus ?StudentStatus [P]
  : 
          P extends 'students'
        ? Array < StudentGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? StudentStatusCountOutputTypeGetPayload<S['select'][P]> | null : never
  } 
    : StudentStatus
  : StudentStatus


  type StudentStatusCountArgs = Merge<
    Omit<StudentStatusFindManyArgs, 'select' | 'include'> & {
      select?: StudentStatusCountAggregateInputType | true
    }
  >

  export interface StudentStatusDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one StudentStatus that matches the filter.
     * @param {StudentStatusFindUniqueArgs} args - Arguments to find a StudentStatus
     * @example
     * // Get one StudentStatus
     * const studentStatus = await prisma.studentStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentStatusFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StudentStatusFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'StudentStatus'> extends True ? CheckSelect<T, Prisma__StudentStatusClient<StudentStatus>, Prisma__StudentStatusClient<StudentStatusGetPayload<T>>> : CheckSelect<T, Prisma__StudentStatusClient<StudentStatus | null >, Prisma__StudentStatusClient<StudentStatusGetPayload<T> | null >>

    /**
     * Find the first StudentStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentStatusFindFirstArgs} args - Arguments to find a StudentStatus
     * @example
     * // Get one StudentStatus
     * const studentStatus = await prisma.studentStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentStatusFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StudentStatusFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'StudentStatus'> extends True ? CheckSelect<T, Prisma__StudentStatusClient<StudentStatus>, Prisma__StudentStatusClient<StudentStatusGetPayload<T>>> : CheckSelect<T, Prisma__StudentStatusClient<StudentStatus | null >, Prisma__StudentStatusClient<StudentStatusGetPayload<T> | null >>

    /**
     * Find zero or more StudentStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentStatusFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentStatuses
     * const studentStatuses = await prisma.studentStatus.findMany()
     * 
     * // Get first 10 StudentStatuses
     * const studentStatuses = await prisma.studentStatus.findMany({ take: 10 })
     * 
     * // Only select the `idStudentStatus`
     * const studentStatusWithIdStudentStatusOnly = await prisma.studentStatus.findMany({ select: { idStudentStatus: true } })
     * 
    **/
    findMany<T extends StudentStatusFindManyArgs>(
      args?: SelectSubset<T, StudentStatusFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<StudentStatus>>, PrismaPromise<Array<StudentStatusGetPayload<T>>>>

    /**
     * Create a StudentStatus.
     * @param {StudentStatusCreateArgs} args - Arguments to create a StudentStatus.
     * @example
     * // Create one StudentStatus
     * const StudentStatus = await prisma.studentStatus.create({
     *   data: {
     *     // ... data to create a StudentStatus
     *   }
     * })
     * 
    **/
    create<T extends StudentStatusCreateArgs>(
      args: SelectSubset<T, StudentStatusCreateArgs>
    ): CheckSelect<T, Prisma__StudentStatusClient<StudentStatus>, Prisma__StudentStatusClient<StudentStatusGetPayload<T>>>

    /**
     * Create many StudentStatuses.
     *     @param {StudentStatusCreateManyArgs} args - Arguments to create many StudentStatuses.
     *     @example
     *     // Create many StudentStatuses
     *     const studentStatus = await prisma.studentStatus.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentStatusCreateManyArgs>(
      args?: SelectSubset<T, StudentStatusCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a StudentStatus.
     * @param {StudentStatusDeleteArgs} args - Arguments to delete one StudentStatus.
     * @example
     * // Delete one StudentStatus
     * const StudentStatus = await prisma.studentStatus.delete({
     *   where: {
     *     // ... filter to delete one StudentStatus
     *   }
     * })
     * 
    **/
    delete<T extends StudentStatusDeleteArgs>(
      args: SelectSubset<T, StudentStatusDeleteArgs>
    ): CheckSelect<T, Prisma__StudentStatusClient<StudentStatus>, Prisma__StudentStatusClient<StudentStatusGetPayload<T>>>

    /**
     * Update one StudentStatus.
     * @param {StudentStatusUpdateArgs} args - Arguments to update one StudentStatus.
     * @example
     * // Update one StudentStatus
     * const studentStatus = await prisma.studentStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentStatusUpdateArgs>(
      args: SelectSubset<T, StudentStatusUpdateArgs>
    ): CheckSelect<T, Prisma__StudentStatusClient<StudentStatus>, Prisma__StudentStatusClient<StudentStatusGetPayload<T>>>

    /**
     * Delete zero or more StudentStatuses.
     * @param {StudentStatusDeleteManyArgs} args - Arguments to filter StudentStatuses to delete.
     * @example
     * // Delete a few StudentStatuses
     * const { count } = await prisma.studentStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentStatusDeleteManyArgs>(
      args?: SelectSubset<T, StudentStatusDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentStatuses
     * const studentStatus = await prisma.studentStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentStatusUpdateManyArgs>(
      args: SelectSubset<T, StudentStatusUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentStatus.
     * @param {StudentStatusUpsertArgs} args - Arguments to update or create a StudentStatus.
     * @example
     * // Update or create a StudentStatus
     * const studentStatus = await prisma.studentStatus.upsert({
     *   create: {
     *     // ... data to create a StudentStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentStatus we want to update
     *   }
     * })
    **/
    upsert<T extends StudentStatusUpsertArgs>(
      args: SelectSubset<T, StudentStatusUpsertArgs>
    ): CheckSelect<T, Prisma__StudentStatusClient<StudentStatus>, Prisma__StudentStatusClient<StudentStatusGetPayload<T>>>

    /**
     * Count the number of StudentStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentStatusCountArgs} args - Arguments to filter StudentStatuses to count.
     * @example
     * // Count the number of StudentStatuses
     * const count = await prisma.studentStatus.count({
     *   where: {
     *     // ... the filter for the StudentStatuses we want to count
     *   }
     * })
    **/
    count<T extends StudentStatusCountArgs>(
      args?: Subset<T, StudentStatusCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentStatusAggregateArgs>(args: Subset<T, StudentStatusAggregateArgs>): PrismaPromise<GetStudentStatusAggregateType<T>>

    /**
     * Group by StudentStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentStatusGroupByArgs['orderBy'] }
        : { orderBy?: StudentStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentStatusGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StudentStatusClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    students<T extends StudentFindManyArgs = {}>(args?: Subset<T, StudentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Student>>, PrismaPromise<Array<StudentGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * StudentStatus findUnique
   */
  export type StudentStatusFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the StudentStatus
     * 
    **/
    select?: StudentStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentStatusInclude | null
    /**
     * Throw an Error if a StudentStatus can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which StudentStatus to fetch.
     * 
    **/
    where: StudentStatusWhereUniqueInput
  }


  /**
   * StudentStatus findFirst
   */
  export type StudentStatusFindFirstArgs = {
    /**
     * Select specific fields to fetch from the StudentStatus
     * 
    **/
    select?: StudentStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentStatusInclude | null
    /**
     * Throw an Error if a StudentStatus can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which StudentStatus to fetch.
     * 
    **/
    where?: StudentStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentStatuses to fetch.
     * 
    **/
    orderBy?: Enumerable<StudentStatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentStatuses.
     * 
    **/
    cursor?: StudentStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentStatuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentStatuses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentStatuses.
     * 
    **/
    distinct?: Enumerable<StudentStatusScalarFieldEnum>
  }


  /**
   * StudentStatus findMany
   */
  export type StudentStatusFindManyArgs = {
    /**
     * Select specific fields to fetch from the StudentStatus
     * 
    **/
    select?: StudentStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentStatusInclude | null
    /**
     * Filter, which StudentStatuses to fetch.
     * 
    **/
    where?: StudentStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentStatuses to fetch.
     * 
    **/
    orderBy?: Enumerable<StudentStatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentStatuses.
     * 
    **/
    cursor?: StudentStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentStatuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentStatuses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StudentStatusScalarFieldEnum>
  }


  /**
   * StudentStatus create
   */
  export type StudentStatusCreateArgs = {
    /**
     * Select specific fields to fetch from the StudentStatus
     * 
    **/
    select?: StudentStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentStatusInclude | null
    /**
     * The data needed to create a StudentStatus.
     * 
    **/
    data: XOR<StudentStatusCreateInput, StudentStatusUncheckedCreateInput>
  }


  /**
   * StudentStatus createMany
   */
  export type StudentStatusCreateManyArgs = {
    data: Enumerable<StudentStatusCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * StudentStatus update
   */
  export type StudentStatusUpdateArgs = {
    /**
     * Select specific fields to fetch from the StudentStatus
     * 
    **/
    select?: StudentStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentStatusInclude | null
    /**
     * The data needed to update a StudentStatus.
     * 
    **/
    data: XOR<StudentStatusUpdateInput, StudentStatusUncheckedUpdateInput>
    /**
     * Choose, which StudentStatus to update.
     * 
    **/
    where: StudentStatusWhereUniqueInput
  }


  /**
   * StudentStatus updateMany
   */
  export type StudentStatusUpdateManyArgs = {
    data: XOR<StudentStatusUpdateManyMutationInput, StudentStatusUncheckedUpdateManyInput>
    where?: StudentStatusWhereInput
  }


  /**
   * StudentStatus upsert
   */
  export type StudentStatusUpsertArgs = {
    /**
     * Select specific fields to fetch from the StudentStatus
     * 
    **/
    select?: StudentStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentStatusInclude | null
    /**
     * The filter to search for the StudentStatus to update in case it exists.
     * 
    **/
    where: StudentStatusWhereUniqueInput
    /**
     * In case the StudentStatus found by the `where` argument doesn't exist, create a new StudentStatus with this data.
     * 
    **/
    create: XOR<StudentStatusCreateInput, StudentStatusUncheckedCreateInput>
    /**
     * In case the StudentStatus was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StudentStatusUpdateInput, StudentStatusUncheckedUpdateInput>
  }


  /**
   * StudentStatus delete
   */
  export type StudentStatusDeleteArgs = {
    /**
     * Select specific fields to fetch from the StudentStatus
     * 
    **/
    select?: StudentStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentStatusInclude | null
    /**
     * Filter which StudentStatus to delete.
     * 
    **/
    where: StudentStatusWhereUniqueInput
  }


  /**
   * StudentStatus deleteMany
   */
  export type StudentStatusDeleteManyArgs = {
    where?: StudentStatusWhereInput
  }


  /**
   * StudentStatus without action
   */
  export type StudentStatusArgs = {
    /**
     * Select specific fields to fetch from the StudentStatus
     * 
    **/
    select?: StudentStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentStatusInclude | null
  }



  /**
   * Model AcceptedType
   */


  export type AggregateAcceptedType = {
    _count: AcceptedTypeCountAggregateOutputType | null
    _avg: AcceptedTypeAvgAggregateOutputType | null
    _sum: AcceptedTypeSumAggregateOutputType | null
    _min: AcceptedTypeMinAggregateOutputType | null
    _max: AcceptedTypeMaxAggregateOutputType | null
  }

  export type AcceptedTypeAvgAggregateOutputType = {
    idAcceptedType: number | null
  }

  export type AcceptedTypeSumAggregateOutputType = {
    idAcceptedType: number | null
  }

  export type AcceptedTypeMinAggregateOutputType = {
    idAcceptedType: number | null
    acceptedName: string | null
  }

  export type AcceptedTypeMaxAggregateOutputType = {
    idAcceptedType: number | null
    acceptedName: string | null
  }

  export type AcceptedTypeCountAggregateOutputType = {
    idAcceptedType: number
    acceptedName: number
    _all: number
  }


  export type AcceptedTypeAvgAggregateInputType = {
    idAcceptedType?: true
  }

  export type AcceptedTypeSumAggregateInputType = {
    idAcceptedType?: true
  }

  export type AcceptedTypeMinAggregateInputType = {
    idAcceptedType?: true
    acceptedName?: true
  }

  export type AcceptedTypeMaxAggregateInputType = {
    idAcceptedType?: true
    acceptedName?: true
  }

  export type AcceptedTypeCountAggregateInputType = {
    idAcceptedType?: true
    acceptedName?: true
    _all?: true
  }

  export type AcceptedTypeAggregateArgs = {
    /**
     * Filter which AcceptedType to aggregate.
     * 
    **/
    where?: AcceptedTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcceptedTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<AcceptedTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AcceptedTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcceptedTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcceptedTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcceptedTypes
    **/
    _count?: true | AcceptedTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AcceptedTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AcceptedTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcceptedTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcceptedTypeMaxAggregateInputType
  }

  export type GetAcceptedTypeAggregateType<T extends AcceptedTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateAcceptedType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcceptedType[P]>
      : GetScalarType<T[P], AggregateAcceptedType[P]>
  }


    
    
  export type AcceptedTypeGroupByArgs = {
    where?: AcceptedTypeWhereInput
    orderBy?: Enumerable<AcceptedTypeOrderByWithAggregationInput>
    by: Array<AcceptedTypeScalarFieldEnum>
    having?: AcceptedTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcceptedTypeCountAggregateInputType | true
    _avg?: AcceptedTypeAvgAggregateInputType
    _sum?: AcceptedTypeSumAggregateInputType
    _min?: AcceptedTypeMinAggregateInputType
    _max?: AcceptedTypeMaxAggregateInputType
  }


  export type AcceptedTypeGroupByOutputType = {
    idAcceptedType: number
    acceptedName: string
    _count: AcceptedTypeCountAggregateOutputType | null
    _avg: AcceptedTypeAvgAggregateOutputType | null
    _sum: AcceptedTypeSumAggregateOutputType | null
    _min: AcceptedTypeMinAggregateOutputType | null
    _max: AcceptedTypeMaxAggregateOutputType | null
  }

  type GetAcceptedTypeGroupByPayload<T extends AcceptedTypeGroupByArgs> = Promise<
    Array<
      PickArray<AcceptedTypeGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof AcceptedTypeGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], AcceptedTypeGroupByOutputType[P]> 
            : GetScalarType<T[P], AcceptedTypeGroupByOutputType[P]>
        }
      > 
    >


  export type AcceptedTypeSelect = {
    idAcceptedType?: boolean
    acceptedName?: boolean
    students?: boolean | StudentFindManyArgs
    _count?: boolean | AcceptedTypeCountOutputTypeArgs
  }

  export type AcceptedTypeInclude = {
    students?: boolean | StudentFindManyArgs
    _count?: boolean | AcceptedTypeCountOutputTypeArgs
  }

  export type AcceptedTypeGetPayload<
    S extends boolean | null | undefined | AcceptedTypeArgs,
    U = keyof S
      > = S extends true
        ? AcceptedType
    : S extends undefined
    ? never
    : S extends AcceptedTypeArgs | AcceptedTypeFindManyArgs
    ?'include' extends U
    ? AcceptedType  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'students'
        ? Array < StudentGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? AcceptedTypeCountOutputTypeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof AcceptedType ?AcceptedType [P]
  : 
          P extends 'students'
        ? Array < StudentGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? AcceptedTypeCountOutputTypeGetPayload<S['select'][P]> | null : never
  } 
    : AcceptedType
  : AcceptedType


  type AcceptedTypeCountArgs = Merge<
    Omit<AcceptedTypeFindManyArgs, 'select' | 'include'> & {
      select?: AcceptedTypeCountAggregateInputType | true
    }
  >

  export interface AcceptedTypeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one AcceptedType that matches the filter.
     * @param {AcceptedTypeFindUniqueArgs} args - Arguments to find a AcceptedType
     * @example
     * // Get one AcceptedType
     * const acceptedType = await prisma.acceptedType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AcceptedTypeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AcceptedTypeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AcceptedType'> extends True ? CheckSelect<T, Prisma__AcceptedTypeClient<AcceptedType>, Prisma__AcceptedTypeClient<AcceptedTypeGetPayload<T>>> : CheckSelect<T, Prisma__AcceptedTypeClient<AcceptedType | null >, Prisma__AcceptedTypeClient<AcceptedTypeGetPayload<T> | null >>

    /**
     * Find the first AcceptedType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcceptedTypeFindFirstArgs} args - Arguments to find a AcceptedType
     * @example
     * // Get one AcceptedType
     * const acceptedType = await prisma.acceptedType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AcceptedTypeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AcceptedTypeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AcceptedType'> extends True ? CheckSelect<T, Prisma__AcceptedTypeClient<AcceptedType>, Prisma__AcceptedTypeClient<AcceptedTypeGetPayload<T>>> : CheckSelect<T, Prisma__AcceptedTypeClient<AcceptedType | null >, Prisma__AcceptedTypeClient<AcceptedTypeGetPayload<T> | null >>

    /**
     * Find zero or more AcceptedTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcceptedTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcceptedTypes
     * const acceptedTypes = await prisma.acceptedType.findMany()
     * 
     * // Get first 10 AcceptedTypes
     * const acceptedTypes = await prisma.acceptedType.findMany({ take: 10 })
     * 
     * // Only select the `idAcceptedType`
     * const acceptedTypeWithIdAcceptedTypeOnly = await prisma.acceptedType.findMany({ select: { idAcceptedType: true } })
     * 
    **/
    findMany<T extends AcceptedTypeFindManyArgs>(
      args?: SelectSubset<T, AcceptedTypeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AcceptedType>>, PrismaPromise<Array<AcceptedTypeGetPayload<T>>>>

    /**
     * Create a AcceptedType.
     * @param {AcceptedTypeCreateArgs} args - Arguments to create a AcceptedType.
     * @example
     * // Create one AcceptedType
     * const AcceptedType = await prisma.acceptedType.create({
     *   data: {
     *     // ... data to create a AcceptedType
     *   }
     * })
     * 
    **/
    create<T extends AcceptedTypeCreateArgs>(
      args: SelectSubset<T, AcceptedTypeCreateArgs>
    ): CheckSelect<T, Prisma__AcceptedTypeClient<AcceptedType>, Prisma__AcceptedTypeClient<AcceptedTypeGetPayload<T>>>

    /**
     * Create many AcceptedTypes.
     *     @param {AcceptedTypeCreateManyArgs} args - Arguments to create many AcceptedTypes.
     *     @example
     *     // Create many AcceptedTypes
     *     const acceptedType = await prisma.acceptedType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AcceptedTypeCreateManyArgs>(
      args?: SelectSubset<T, AcceptedTypeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AcceptedType.
     * @param {AcceptedTypeDeleteArgs} args - Arguments to delete one AcceptedType.
     * @example
     * // Delete one AcceptedType
     * const AcceptedType = await prisma.acceptedType.delete({
     *   where: {
     *     // ... filter to delete one AcceptedType
     *   }
     * })
     * 
    **/
    delete<T extends AcceptedTypeDeleteArgs>(
      args: SelectSubset<T, AcceptedTypeDeleteArgs>
    ): CheckSelect<T, Prisma__AcceptedTypeClient<AcceptedType>, Prisma__AcceptedTypeClient<AcceptedTypeGetPayload<T>>>

    /**
     * Update one AcceptedType.
     * @param {AcceptedTypeUpdateArgs} args - Arguments to update one AcceptedType.
     * @example
     * // Update one AcceptedType
     * const acceptedType = await prisma.acceptedType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AcceptedTypeUpdateArgs>(
      args: SelectSubset<T, AcceptedTypeUpdateArgs>
    ): CheckSelect<T, Prisma__AcceptedTypeClient<AcceptedType>, Prisma__AcceptedTypeClient<AcceptedTypeGetPayload<T>>>

    /**
     * Delete zero or more AcceptedTypes.
     * @param {AcceptedTypeDeleteManyArgs} args - Arguments to filter AcceptedTypes to delete.
     * @example
     * // Delete a few AcceptedTypes
     * const { count } = await prisma.acceptedType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AcceptedTypeDeleteManyArgs>(
      args?: SelectSubset<T, AcceptedTypeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcceptedTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcceptedTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcceptedTypes
     * const acceptedType = await prisma.acceptedType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AcceptedTypeUpdateManyArgs>(
      args: SelectSubset<T, AcceptedTypeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AcceptedType.
     * @param {AcceptedTypeUpsertArgs} args - Arguments to update or create a AcceptedType.
     * @example
     * // Update or create a AcceptedType
     * const acceptedType = await prisma.acceptedType.upsert({
     *   create: {
     *     // ... data to create a AcceptedType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcceptedType we want to update
     *   }
     * })
    **/
    upsert<T extends AcceptedTypeUpsertArgs>(
      args: SelectSubset<T, AcceptedTypeUpsertArgs>
    ): CheckSelect<T, Prisma__AcceptedTypeClient<AcceptedType>, Prisma__AcceptedTypeClient<AcceptedTypeGetPayload<T>>>

    /**
     * Count the number of AcceptedTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcceptedTypeCountArgs} args - Arguments to filter AcceptedTypes to count.
     * @example
     * // Count the number of AcceptedTypes
     * const count = await prisma.acceptedType.count({
     *   where: {
     *     // ... the filter for the AcceptedTypes we want to count
     *   }
     * })
    **/
    count<T extends AcceptedTypeCountArgs>(
      args?: Subset<T, AcceptedTypeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcceptedTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcceptedType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcceptedTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcceptedTypeAggregateArgs>(args: Subset<T, AcceptedTypeAggregateArgs>): PrismaPromise<GetAcceptedTypeAggregateType<T>>

    /**
     * Group by AcceptedType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcceptedTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcceptedTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcceptedTypeGroupByArgs['orderBy'] }
        : { orderBy?: AcceptedTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcceptedTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcceptedTypeGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcceptedType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AcceptedTypeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    students<T extends StudentFindManyArgs = {}>(args?: Subset<T, StudentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Student>>, PrismaPromise<Array<StudentGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * AcceptedType findUnique
   */
  export type AcceptedTypeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the AcceptedType
     * 
    **/
    select?: AcceptedTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AcceptedTypeInclude | null
    /**
     * Throw an Error if a AcceptedType can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AcceptedType to fetch.
     * 
    **/
    where: AcceptedTypeWhereUniqueInput
  }


  /**
   * AcceptedType findFirst
   */
  export type AcceptedTypeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the AcceptedType
     * 
    **/
    select?: AcceptedTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AcceptedTypeInclude | null
    /**
     * Throw an Error if a AcceptedType can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AcceptedType to fetch.
     * 
    **/
    where?: AcceptedTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcceptedTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<AcceptedTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcceptedTypes.
     * 
    **/
    cursor?: AcceptedTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcceptedTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcceptedTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcceptedTypes.
     * 
    **/
    distinct?: Enumerable<AcceptedTypeScalarFieldEnum>
  }


  /**
   * AcceptedType findMany
   */
  export type AcceptedTypeFindManyArgs = {
    /**
     * Select specific fields to fetch from the AcceptedType
     * 
    **/
    select?: AcceptedTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AcceptedTypeInclude | null
    /**
     * Filter, which AcceptedTypes to fetch.
     * 
    **/
    where?: AcceptedTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcceptedTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<AcceptedTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcceptedTypes.
     * 
    **/
    cursor?: AcceptedTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcceptedTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcceptedTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AcceptedTypeScalarFieldEnum>
  }


  /**
   * AcceptedType create
   */
  export type AcceptedTypeCreateArgs = {
    /**
     * Select specific fields to fetch from the AcceptedType
     * 
    **/
    select?: AcceptedTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AcceptedTypeInclude | null
    /**
     * The data needed to create a AcceptedType.
     * 
    **/
    data: XOR<AcceptedTypeCreateInput, AcceptedTypeUncheckedCreateInput>
  }


  /**
   * AcceptedType createMany
   */
  export type AcceptedTypeCreateManyArgs = {
    data: Enumerable<AcceptedTypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AcceptedType update
   */
  export type AcceptedTypeUpdateArgs = {
    /**
     * Select specific fields to fetch from the AcceptedType
     * 
    **/
    select?: AcceptedTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AcceptedTypeInclude | null
    /**
     * The data needed to update a AcceptedType.
     * 
    **/
    data: XOR<AcceptedTypeUpdateInput, AcceptedTypeUncheckedUpdateInput>
    /**
     * Choose, which AcceptedType to update.
     * 
    **/
    where: AcceptedTypeWhereUniqueInput
  }


  /**
   * AcceptedType updateMany
   */
  export type AcceptedTypeUpdateManyArgs = {
    data: XOR<AcceptedTypeUpdateManyMutationInput, AcceptedTypeUncheckedUpdateManyInput>
    where?: AcceptedTypeWhereInput
  }


  /**
   * AcceptedType upsert
   */
  export type AcceptedTypeUpsertArgs = {
    /**
     * Select specific fields to fetch from the AcceptedType
     * 
    **/
    select?: AcceptedTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AcceptedTypeInclude | null
    /**
     * The filter to search for the AcceptedType to update in case it exists.
     * 
    **/
    where: AcceptedTypeWhereUniqueInput
    /**
     * In case the AcceptedType found by the `where` argument doesn't exist, create a new AcceptedType with this data.
     * 
    **/
    create: XOR<AcceptedTypeCreateInput, AcceptedTypeUncheckedCreateInput>
    /**
     * In case the AcceptedType was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AcceptedTypeUpdateInput, AcceptedTypeUncheckedUpdateInput>
  }


  /**
   * AcceptedType delete
   */
  export type AcceptedTypeDeleteArgs = {
    /**
     * Select specific fields to fetch from the AcceptedType
     * 
    **/
    select?: AcceptedTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AcceptedTypeInclude | null
    /**
     * Filter which AcceptedType to delete.
     * 
    **/
    where: AcceptedTypeWhereUniqueInput
  }


  /**
   * AcceptedType deleteMany
   */
  export type AcceptedTypeDeleteManyArgs = {
    where?: AcceptedTypeWhereInput
  }


  /**
   * AcceptedType without action
   */
  export type AcceptedTypeArgs = {
    /**
     * Select specific fields to fetch from the AcceptedType
     * 
    **/
    select?: AcceptedTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AcceptedTypeInclude | null
  }



  /**
   * Model StudentImage
   */


  export type AggregateStudentImage = {
    _count: StudentImageCountAggregateOutputType | null
    _avg: StudentImageAvgAggregateOutputType | null
    _sum: StudentImageSumAggregateOutputType | null
    _min: StudentImageMinAggregateOutputType | null
    _max: StudentImageMaxAggregateOutputType | null
  }

  export type StudentImageAvgAggregateOutputType = {
    idStudentImage: number | null
    studentId: number | null
  }

  export type StudentImageSumAggregateOutputType = {
    idStudentImage: number | null
    studentId: number | null
  }

  export type StudentImageMinAggregateOutputType = {
    idStudentImage: number | null
    imagePath: string | null
    studentId: number | null
  }

  export type StudentImageMaxAggregateOutputType = {
    idStudentImage: number | null
    imagePath: string | null
    studentId: number | null
  }

  export type StudentImageCountAggregateOutputType = {
    idStudentImage: number
    imagePath: number
    studentId: number
    _all: number
  }


  export type StudentImageAvgAggregateInputType = {
    idStudentImage?: true
    studentId?: true
  }

  export type StudentImageSumAggregateInputType = {
    idStudentImage?: true
    studentId?: true
  }

  export type StudentImageMinAggregateInputType = {
    idStudentImage?: true
    imagePath?: true
    studentId?: true
  }

  export type StudentImageMaxAggregateInputType = {
    idStudentImage?: true
    imagePath?: true
    studentId?: true
  }

  export type StudentImageCountAggregateInputType = {
    idStudentImage?: true
    imagePath?: true
    studentId?: true
    _all?: true
  }

  export type StudentImageAggregateArgs = {
    /**
     * Filter which StudentImage to aggregate.
     * 
    **/
    where?: StudentImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentImages to fetch.
     * 
    **/
    orderBy?: Enumerable<StudentImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StudentImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentImages
    **/
    _count?: true | StudentImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentImageMaxAggregateInputType
  }

  export type GetStudentImageAggregateType<T extends StudentImageAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentImage[P]>
      : GetScalarType<T[P], AggregateStudentImage[P]>
  }


    
    
  export type StudentImageGroupByArgs = {
    where?: StudentImageWhereInput
    orderBy?: Enumerable<StudentImageOrderByWithAggregationInput>
    by: Array<StudentImageScalarFieldEnum>
    having?: StudentImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentImageCountAggregateInputType | true
    _avg?: StudentImageAvgAggregateInputType
    _sum?: StudentImageSumAggregateInputType
    _min?: StudentImageMinAggregateInputType
    _max?: StudentImageMaxAggregateInputType
  }


  export type StudentImageGroupByOutputType = {
    idStudentImage: number
    imagePath: string
    studentId: number
    _count: StudentImageCountAggregateOutputType | null
    _avg: StudentImageAvgAggregateOutputType | null
    _sum: StudentImageSumAggregateOutputType | null
    _min: StudentImageMinAggregateOutputType | null
    _max: StudentImageMaxAggregateOutputType | null
  }

  type GetStudentImageGroupByPayload<T extends StudentImageGroupByArgs> = Promise<
    Array<
      PickArray<StudentImageGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof StudentImageGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], StudentImageGroupByOutputType[P]> 
            : GetScalarType<T[P], StudentImageGroupByOutputType[P]>
        }
      > 
    >


  export type StudentImageSelect = {
    idStudentImage?: boolean
    imagePath?: boolean
    student?: boolean | StudentArgs
    studentId?: boolean
  }

  export type StudentImageInclude = {
    student?: boolean | StudentArgs
  }

  export type StudentImageGetPayload<
    S extends boolean | null | undefined | StudentImageArgs,
    U = keyof S
      > = S extends true
        ? StudentImage
    : S extends undefined
    ? never
    : S extends StudentImageArgs | StudentImageFindManyArgs
    ?'include' extends U
    ? StudentImage  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'student'
        ? StudentGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof StudentImage ?StudentImage [P]
  : 
          P extends 'student'
        ? StudentGetPayload<S['select'][P]> : never
  } 
    : StudentImage
  : StudentImage


  type StudentImageCountArgs = Merge<
    Omit<StudentImageFindManyArgs, 'select' | 'include'> & {
      select?: StudentImageCountAggregateInputType | true
    }
  >

  export interface StudentImageDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one StudentImage that matches the filter.
     * @param {StudentImageFindUniqueArgs} args - Arguments to find a StudentImage
     * @example
     * // Get one StudentImage
     * const studentImage = await prisma.studentImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentImageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StudentImageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'StudentImage'> extends True ? CheckSelect<T, Prisma__StudentImageClient<StudentImage>, Prisma__StudentImageClient<StudentImageGetPayload<T>>> : CheckSelect<T, Prisma__StudentImageClient<StudentImage | null >, Prisma__StudentImageClient<StudentImageGetPayload<T> | null >>

    /**
     * Find the first StudentImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentImageFindFirstArgs} args - Arguments to find a StudentImage
     * @example
     * // Get one StudentImage
     * const studentImage = await prisma.studentImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentImageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StudentImageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'StudentImage'> extends True ? CheckSelect<T, Prisma__StudentImageClient<StudentImage>, Prisma__StudentImageClient<StudentImageGetPayload<T>>> : CheckSelect<T, Prisma__StudentImageClient<StudentImage | null >, Prisma__StudentImageClient<StudentImageGetPayload<T> | null >>

    /**
     * Find zero or more StudentImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentImageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentImages
     * const studentImages = await prisma.studentImage.findMany()
     * 
     * // Get first 10 StudentImages
     * const studentImages = await prisma.studentImage.findMany({ take: 10 })
     * 
     * // Only select the `idStudentImage`
     * const studentImageWithIdStudentImageOnly = await prisma.studentImage.findMany({ select: { idStudentImage: true } })
     * 
    **/
    findMany<T extends StudentImageFindManyArgs>(
      args?: SelectSubset<T, StudentImageFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<StudentImage>>, PrismaPromise<Array<StudentImageGetPayload<T>>>>

    /**
     * Create a StudentImage.
     * @param {StudentImageCreateArgs} args - Arguments to create a StudentImage.
     * @example
     * // Create one StudentImage
     * const StudentImage = await prisma.studentImage.create({
     *   data: {
     *     // ... data to create a StudentImage
     *   }
     * })
     * 
    **/
    create<T extends StudentImageCreateArgs>(
      args: SelectSubset<T, StudentImageCreateArgs>
    ): CheckSelect<T, Prisma__StudentImageClient<StudentImage>, Prisma__StudentImageClient<StudentImageGetPayload<T>>>

    /**
     * Create many StudentImages.
     *     @param {StudentImageCreateManyArgs} args - Arguments to create many StudentImages.
     *     @example
     *     // Create many StudentImages
     *     const studentImage = await prisma.studentImage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentImageCreateManyArgs>(
      args?: SelectSubset<T, StudentImageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a StudentImage.
     * @param {StudentImageDeleteArgs} args - Arguments to delete one StudentImage.
     * @example
     * // Delete one StudentImage
     * const StudentImage = await prisma.studentImage.delete({
     *   where: {
     *     // ... filter to delete one StudentImage
     *   }
     * })
     * 
    **/
    delete<T extends StudentImageDeleteArgs>(
      args: SelectSubset<T, StudentImageDeleteArgs>
    ): CheckSelect<T, Prisma__StudentImageClient<StudentImage>, Prisma__StudentImageClient<StudentImageGetPayload<T>>>

    /**
     * Update one StudentImage.
     * @param {StudentImageUpdateArgs} args - Arguments to update one StudentImage.
     * @example
     * // Update one StudentImage
     * const studentImage = await prisma.studentImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentImageUpdateArgs>(
      args: SelectSubset<T, StudentImageUpdateArgs>
    ): CheckSelect<T, Prisma__StudentImageClient<StudentImage>, Prisma__StudentImageClient<StudentImageGetPayload<T>>>

    /**
     * Delete zero or more StudentImages.
     * @param {StudentImageDeleteManyArgs} args - Arguments to filter StudentImages to delete.
     * @example
     * // Delete a few StudentImages
     * const { count } = await prisma.studentImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentImageDeleteManyArgs>(
      args?: SelectSubset<T, StudentImageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentImages
     * const studentImage = await prisma.studentImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentImageUpdateManyArgs>(
      args: SelectSubset<T, StudentImageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentImage.
     * @param {StudentImageUpsertArgs} args - Arguments to update or create a StudentImage.
     * @example
     * // Update or create a StudentImage
     * const studentImage = await prisma.studentImage.upsert({
     *   create: {
     *     // ... data to create a StudentImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentImage we want to update
     *   }
     * })
    **/
    upsert<T extends StudentImageUpsertArgs>(
      args: SelectSubset<T, StudentImageUpsertArgs>
    ): CheckSelect<T, Prisma__StudentImageClient<StudentImage>, Prisma__StudentImageClient<StudentImageGetPayload<T>>>

    /**
     * Count the number of StudentImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentImageCountArgs} args - Arguments to filter StudentImages to count.
     * @example
     * // Count the number of StudentImages
     * const count = await prisma.studentImage.count({
     *   where: {
     *     // ... the filter for the StudentImages we want to count
     *   }
     * })
    **/
    count<T extends StudentImageCountArgs>(
      args?: Subset<T, StudentImageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentImageAggregateArgs>(args: Subset<T, StudentImageAggregateArgs>): PrismaPromise<GetStudentImageAggregateType<T>>

    /**
     * Group by StudentImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentImageGroupByArgs['orderBy'] }
        : { orderBy?: StudentImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentImageGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StudentImageClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    student<T extends StudentArgs = {}>(args?: Subset<T, StudentArgs>): CheckSelect<T, Prisma__StudentClient<Student | null >, Prisma__StudentClient<StudentGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * StudentImage findUnique
   */
  export type StudentImageFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the StudentImage
     * 
    **/
    select?: StudentImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentImageInclude | null
    /**
     * Throw an Error if a StudentImage can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which StudentImage to fetch.
     * 
    **/
    where: StudentImageWhereUniqueInput
  }


  /**
   * StudentImage findFirst
   */
  export type StudentImageFindFirstArgs = {
    /**
     * Select specific fields to fetch from the StudentImage
     * 
    **/
    select?: StudentImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentImageInclude | null
    /**
     * Throw an Error if a StudentImage can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which StudentImage to fetch.
     * 
    **/
    where?: StudentImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentImages to fetch.
     * 
    **/
    orderBy?: Enumerable<StudentImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentImages.
     * 
    **/
    cursor?: StudentImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentImages.
     * 
    **/
    distinct?: Enumerable<StudentImageScalarFieldEnum>
  }


  /**
   * StudentImage findMany
   */
  export type StudentImageFindManyArgs = {
    /**
     * Select specific fields to fetch from the StudentImage
     * 
    **/
    select?: StudentImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentImageInclude | null
    /**
     * Filter, which StudentImages to fetch.
     * 
    **/
    where?: StudentImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentImages to fetch.
     * 
    **/
    orderBy?: Enumerable<StudentImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentImages.
     * 
    **/
    cursor?: StudentImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentImages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StudentImageScalarFieldEnum>
  }


  /**
   * StudentImage create
   */
  export type StudentImageCreateArgs = {
    /**
     * Select specific fields to fetch from the StudentImage
     * 
    **/
    select?: StudentImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentImageInclude | null
    /**
     * The data needed to create a StudentImage.
     * 
    **/
    data: XOR<StudentImageCreateInput, StudentImageUncheckedCreateInput>
  }


  /**
   * StudentImage createMany
   */
  export type StudentImageCreateManyArgs = {
    data: Enumerable<StudentImageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * StudentImage update
   */
  export type StudentImageUpdateArgs = {
    /**
     * Select specific fields to fetch from the StudentImage
     * 
    **/
    select?: StudentImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentImageInclude | null
    /**
     * The data needed to update a StudentImage.
     * 
    **/
    data: XOR<StudentImageUpdateInput, StudentImageUncheckedUpdateInput>
    /**
     * Choose, which StudentImage to update.
     * 
    **/
    where: StudentImageWhereUniqueInput
  }


  /**
   * StudentImage updateMany
   */
  export type StudentImageUpdateManyArgs = {
    data: XOR<StudentImageUpdateManyMutationInput, StudentImageUncheckedUpdateManyInput>
    where?: StudentImageWhereInput
  }


  /**
   * StudentImage upsert
   */
  export type StudentImageUpsertArgs = {
    /**
     * Select specific fields to fetch from the StudentImage
     * 
    **/
    select?: StudentImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentImageInclude | null
    /**
     * The filter to search for the StudentImage to update in case it exists.
     * 
    **/
    where: StudentImageWhereUniqueInput
    /**
     * In case the StudentImage found by the `where` argument doesn't exist, create a new StudentImage with this data.
     * 
    **/
    create: XOR<StudentImageCreateInput, StudentImageUncheckedCreateInput>
    /**
     * In case the StudentImage was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StudentImageUpdateInput, StudentImageUncheckedUpdateInput>
  }


  /**
   * StudentImage delete
   */
  export type StudentImageDeleteArgs = {
    /**
     * Select specific fields to fetch from the StudentImage
     * 
    **/
    select?: StudentImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentImageInclude | null
    /**
     * Filter which StudentImage to delete.
     * 
    **/
    where: StudentImageWhereUniqueInput
  }


  /**
   * StudentImage deleteMany
   */
  export type StudentImageDeleteManyArgs = {
    where?: StudentImageWhereInput
  }


  /**
   * StudentImage without action
   */
  export type StudentImageArgs = {
    /**
     * Select specific fields to fetch from the StudentImage
     * 
    **/
    select?: StudentImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StudentImageInclude | null
  }



  /**
   * Model Province
   */


  export type AggregateProvince = {
    _count: ProvinceCountAggregateOutputType | null
    _avg: ProvinceAvgAggregateOutputType | null
    _sum: ProvinceSumAggregateOutputType | null
    _min: ProvinceMinAggregateOutputType | null
    _max: ProvinceMaxAggregateOutputType | null
  }

  export type ProvinceAvgAggregateOutputType = {
    idProvince: number | null
  }

  export type ProvinceSumAggregateOutputType = {
    idProvince: number | null
  }

  export type ProvinceMinAggregateOutputType = {
    idProvince: number | null
    provinceName: string | null
    provinceNameEn: string | null
  }

  export type ProvinceMaxAggregateOutputType = {
    idProvince: number | null
    provinceName: string | null
    provinceNameEn: string | null
  }

  export type ProvinceCountAggregateOutputType = {
    idProvince: number
    provinceName: number
    provinceNameEn: number
    _all: number
  }


  export type ProvinceAvgAggregateInputType = {
    idProvince?: true
  }

  export type ProvinceSumAggregateInputType = {
    idProvince?: true
  }

  export type ProvinceMinAggregateInputType = {
    idProvince?: true
    provinceName?: true
    provinceNameEn?: true
  }

  export type ProvinceMaxAggregateInputType = {
    idProvince?: true
    provinceName?: true
    provinceNameEn?: true
  }

  export type ProvinceCountAggregateInputType = {
    idProvince?: true
    provinceName?: true
    provinceNameEn?: true
    _all?: true
  }

  export type ProvinceAggregateArgs = {
    /**
     * Filter which Province to aggregate.
     * 
    **/
    where?: ProvinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provinces to fetch.
     * 
    **/
    orderBy?: Enumerable<ProvinceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProvinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provinces from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provinces.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Provinces
    **/
    _count?: true | ProvinceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProvinceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProvinceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProvinceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProvinceMaxAggregateInputType
  }

  export type GetProvinceAggregateType<T extends ProvinceAggregateArgs> = {
        [P in keyof T & keyof AggregateProvince]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvince[P]>
      : GetScalarType<T[P], AggregateProvince[P]>
  }


    
    
  export type ProvinceGroupByArgs = {
    where?: ProvinceWhereInput
    orderBy?: Enumerable<ProvinceOrderByWithAggregationInput>
    by: Array<ProvinceScalarFieldEnum>
    having?: ProvinceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProvinceCountAggregateInputType | true
    _avg?: ProvinceAvgAggregateInputType
    _sum?: ProvinceSumAggregateInputType
    _min?: ProvinceMinAggregateInputType
    _max?: ProvinceMaxAggregateInputType
  }


  export type ProvinceGroupByOutputType = {
    idProvince: number
    provinceName: string
    provinceNameEn: string
    _count: ProvinceCountAggregateOutputType | null
    _avg: ProvinceAvgAggregateOutputType | null
    _sum: ProvinceSumAggregateOutputType | null
    _min: ProvinceMinAggregateOutputType | null
    _max: ProvinceMaxAggregateOutputType | null
  }

  type GetProvinceGroupByPayload<T extends ProvinceGroupByArgs> = Promise<
    Array<
      PickArray<ProvinceGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ProvinceGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ProvinceGroupByOutputType[P]> 
            : GetScalarType<T[P], ProvinceGroupByOutputType[P]>
        }
      > 
    >


  export type ProvinceSelect = {
    idProvince?: boolean
    provinceName?: boolean
    provinceNameEn?: boolean
    addresses?: boolean | AddressFindManyArgs
    _count?: boolean | ProvinceCountOutputTypeArgs
  }

  export type ProvinceInclude = {
    addresses?: boolean | AddressFindManyArgs
    _count?: boolean | ProvinceCountOutputTypeArgs
  }

  export type ProvinceGetPayload<
    S extends boolean | null | undefined | ProvinceArgs,
    U = keyof S
      > = S extends true
        ? Province
    : S extends undefined
    ? never
    : S extends ProvinceArgs | ProvinceFindManyArgs
    ?'include' extends U
    ? Province  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'addresses'
        ? Array < AddressGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? ProvinceCountOutputTypeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Province ?Province [P]
  : 
          P extends 'addresses'
        ? Array < AddressGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? ProvinceCountOutputTypeGetPayload<S['select'][P]> | null : never
  } 
    : Province
  : Province


  type ProvinceCountArgs = Merge<
    Omit<ProvinceFindManyArgs, 'select' | 'include'> & {
      select?: ProvinceCountAggregateInputType | true
    }
  >

  export interface ProvinceDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Province that matches the filter.
     * @param {ProvinceFindUniqueArgs} args - Arguments to find a Province
     * @example
     * // Get one Province
     * const province = await prisma.province.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProvinceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProvinceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Province'> extends True ? CheckSelect<T, Prisma__ProvinceClient<Province>, Prisma__ProvinceClient<ProvinceGetPayload<T>>> : CheckSelect<T, Prisma__ProvinceClient<Province | null >, Prisma__ProvinceClient<ProvinceGetPayload<T> | null >>

    /**
     * Find the first Province that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceFindFirstArgs} args - Arguments to find a Province
     * @example
     * // Get one Province
     * const province = await prisma.province.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProvinceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProvinceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Province'> extends True ? CheckSelect<T, Prisma__ProvinceClient<Province>, Prisma__ProvinceClient<ProvinceGetPayload<T>>> : CheckSelect<T, Prisma__ProvinceClient<Province | null >, Prisma__ProvinceClient<ProvinceGetPayload<T> | null >>

    /**
     * Find zero or more Provinces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Provinces
     * const provinces = await prisma.province.findMany()
     * 
     * // Get first 10 Provinces
     * const provinces = await prisma.province.findMany({ take: 10 })
     * 
     * // Only select the `idProvince`
     * const provinceWithIdProvinceOnly = await prisma.province.findMany({ select: { idProvince: true } })
     * 
    **/
    findMany<T extends ProvinceFindManyArgs>(
      args?: SelectSubset<T, ProvinceFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Province>>, PrismaPromise<Array<ProvinceGetPayload<T>>>>

    /**
     * Create a Province.
     * @param {ProvinceCreateArgs} args - Arguments to create a Province.
     * @example
     * // Create one Province
     * const Province = await prisma.province.create({
     *   data: {
     *     // ... data to create a Province
     *   }
     * })
     * 
    **/
    create<T extends ProvinceCreateArgs>(
      args: SelectSubset<T, ProvinceCreateArgs>
    ): CheckSelect<T, Prisma__ProvinceClient<Province>, Prisma__ProvinceClient<ProvinceGetPayload<T>>>

    /**
     * Create many Provinces.
     *     @param {ProvinceCreateManyArgs} args - Arguments to create many Provinces.
     *     @example
     *     // Create many Provinces
     *     const province = await prisma.province.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProvinceCreateManyArgs>(
      args?: SelectSubset<T, ProvinceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Province.
     * @param {ProvinceDeleteArgs} args - Arguments to delete one Province.
     * @example
     * // Delete one Province
     * const Province = await prisma.province.delete({
     *   where: {
     *     // ... filter to delete one Province
     *   }
     * })
     * 
    **/
    delete<T extends ProvinceDeleteArgs>(
      args: SelectSubset<T, ProvinceDeleteArgs>
    ): CheckSelect<T, Prisma__ProvinceClient<Province>, Prisma__ProvinceClient<ProvinceGetPayload<T>>>

    /**
     * Update one Province.
     * @param {ProvinceUpdateArgs} args - Arguments to update one Province.
     * @example
     * // Update one Province
     * const province = await prisma.province.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProvinceUpdateArgs>(
      args: SelectSubset<T, ProvinceUpdateArgs>
    ): CheckSelect<T, Prisma__ProvinceClient<Province>, Prisma__ProvinceClient<ProvinceGetPayload<T>>>

    /**
     * Delete zero or more Provinces.
     * @param {ProvinceDeleteManyArgs} args - Arguments to filter Provinces to delete.
     * @example
     * // Delete a few Provinces
     * const { count } = await prisma.province.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProvinceDeleteManyArgs>(
      args?: SelectSubset<T, ProvinceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provinces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Provinces
     * const province = await prisma.province.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProvinceUpdateManyArgs>(
      args: SelectSubset<T, ProvinceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Province.
     * @param {ProvinceUpsertArgs} args - Arguments to update or create a Province.
     * @example
     * // Update or create a Province
     * const province = await prisma.province.upsert({
     *   create: {
     *     // ... data to create a Province
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Province we want to update
     *   }
     * })
    **/
    upsert<T extends ProvinceUpsertArgs>(
      args: SelectSubset<T, ProvinceUpsertArgs>
    ): CheckSelect<T, Prisma__ProvinceClient<Province>, Prisma__ProvinceClient<ProvinceGetPayload<T>>>

    /**
     * Count the number of Provinces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceCountArgs} args - Arguments to filter Provinces to count.
     * @example
     * // Count the number of Provinces
     * const count = await prisma.province.count({
     *   where: {
     *     // ... the filter for the Provinces we want to count
     *   }
     * })
    **/
    count<T extends ProvinceCountArgs>(
      args?: Subset<T, ProvinceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProvinceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Province.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProvinceAggregateArgs>(args: Subset<T, ProvinceAggregateArgs>): PrismaPromise<GetProvinceAggregateType<T>>

    /**
     * Group by Province.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProvinceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProvinceGroupByArgs['orderBy'] }
        : { orderBy?: ProvinceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProvinceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProvinceGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Province.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProvinceClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    addresses<T extends AddressFindManyArgs = {}>(args?: Subset<T, AddressFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Address>>, PrismaPromise<Array<AddressGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Province findUnique
   */
  export type ProvinceFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Province
     * 
    **/
    select?: ProvinceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProvinceInclude | null
    /**
     * Throw an Error if a Province can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Province to fetch.
     * 
    **/
    where: ProvinceWhereUniqueInput
  }


  /**
   * Province findFirst
   */
  export type ProvinceFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Province
     * 
    **/
    select?: ProvinceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProvinceInclude | null
    /**
     * Throw an Error if a Province can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Province to fetch.
     * 
    **/
    where?: ProvinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provinces to fetch.
     * 
    **/
    orderBy?: Enumerable<ProvinceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Provinces.
     * 
    **/
    cursor?: ProvinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provinces from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provinces.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Provinces.
     * 
    **/
    distinct?: Enumerable<ProvinceScalarFieldEnum>
  }


  /**
   * Province findMany
   */
  export type ProvinceFindManyArgs = {
    /**
     * Select specific fields to fetch from the Province
     * 
    **/
    select?: ProvinceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProvinceInclude | null
    /**
     * Filter, which Provinces to fetch.
     * 
    **/
    where?: ProvinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provinces to fetch.
     * 
    **/
    orderBy?: Enumerable<ProvinceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Provinces.
     * 
    **/
    cursor?: ProvinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provinces from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provinces.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProvinceScalarFieldEnum>
  }


  /**
   * Province create
   */
  export type ProvinceCreateArgs = {
    /**
     * Select specific fields to fetch from the Province
     * 
    **/
    select?: ProvinceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProvinceInclude | null
    /**
     * The data needed to create a Province.
     * 
    **/
    data: XOR<ProvinceCreateInput, ProvinceUncheckedCreateInput>
  }


  /**
   * Province createMany
   */
  export type ProvinceCreateManyArgs = {
    data: Enumerable<ProvinceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Province update
   */
  export type ProvinceUpdateArgs = {
    /**
     * Select specific fields to fetch from the Province
     * 
    **/
    select?: ProvinceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProvinceInclude | null
    /**
     * The data needed to update a Province.
     * 
    **/
    data: XOR<ProvinceUpdateInput, ProvinceUncheckedUpdateInput>
    /**
     * Choose, which Province to update.
     * 
    **/
    where: ProvinceWhereUniqueInput
  }


  /**
   * Province updateMany
   */
  export type ProvinceUpdateManyArgs = {
    data: XOR<ProvinceUpdateManyMutationInput, ProvinceUncheckedUpdateManyInput>
    where?: ProvinceWhereInput
  }


  /**
   * Province upsert
   */
  export type ProvinceUpsertArgs = {
    /**
     * Select specific fields to fetch from the Province
     * 
    **/
    select?: ProvinceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProvinceInclude | null
    /**
     * The filter to search for the Province to update in case it exists.
     * 
    **/
    where: ProvinceWhereUniqueInput
    /**
     * In case the Province found by the `where` argument doesn't exist, create a new Province with this data.
     * 
    **/
    create: XOR<ProvinceCreateInput, ProvinceUncheckedCreateInput>
    /**
     * In case the Province was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProvinceUpdateInput, ProvinceUncheckedUpdateInput>
  }


  /**
   * Province delete
   */
  export type ProvinceDeleteArgs = {
    /**
     * Select specific fields to fetch from the Province
     * 
    **/
    select?: ProvinceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProvinceInclude | null
    /**
     * Filter which Province to delete.
     * 
    **/
    where: ProvinceWhereUniqueInput
  }


  /**
   * Province deleteMany
   */
  export type ProvinceDeleteManyArgs = {
    where?: ProvinceWhereInput
  }


  /**
   * Province without action
   */
  export type ProvinceArgs = {
    /**
     * Select specific fields to fetch from the Province
     * 
    **/
    select?: ProvinceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProvinceInclude | null
  }



  /**
   * Model Address
   */


  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressAvgAggregateOutputType = {
    idAddress: number | null
    provinceId: number | null
    studentId: number | null
  }

  export type AddressSumAggregateOutputType = {
    idAddress: number | null
    provinceId: number | null
    studentId: number | null
  }

  export type AddressMinAggregateOutputType = {
    idAddress: number | null
    provinceId: number | null
    district: string | null
    avenue: string | null
    houseNumber: string | null
    streetNumber: string | null
    studentId: number | null
  }

  export type AddressMaxAggregateOutputType = {
    idAddress: number | null
    provinceId: number | null
    district: string | null
    avenue: string | null
    houseNumber: string | null
    streetNumber: string | null
    studentId: number | null
  }

  export type AddressCountAggregateOutputType = {
    idAddress: number
    provinceId: number
    district: number
    avenue: number
    houseNumber: number
    streetNumber: number
    studentId: number
    _all: number
  }


  export type AddressAvgAggregateInputType = {
    idAddress?: true
    provinceId?: true
    studentId?: true
  }

  export type AddressSumAggregateInputType = {
    idAddress?: true
    provinceId?: true
    studentId?: true
  }

  export type AddressMinAggregateInputType = {
    idAddress?: true
    provinceId?: true
    district?: true
    avenue?: true
    houseNumber?: true
    streetNumber?: true
    studentId?: true
  }

  export type AddressMaxAggregateInputType = {
    idAddress?: true
    provinceId?: true
    district?: true
    avenue?: true
    houseNumber?: true
    streetNumber?: true
    studentId?: true
  }

  export type AddressCountAggregateInputType = {
    idAddress?: true
    provinceId?: true
    district?: true
    avenue?: true
    houseNumber?: true
    streetNumber?: true
    studentId?: true
    _all?: true
  }

  export type AddressAggregateArgs = {
    /**
     * Filter which Address to aggregate.
     * 
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     * 
    **/
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }


    
    
  export type AddressGroupByArgs = {
    where?: AddressWhereInput
    orderBy?: Enumerable<AddressOrderByWithAggregationInput>
    by: Array<AddressScalarFieldEnum>
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _avg?: AddressAvgAggregateInputType
    _sum?: AddressSumAggregateInputType
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }


  export type AddressGroupByOutputType = {
    idAddress: number
    provinceId: number
    district: string
    avenue: string
    houseNumber: string
    streetNumber: string
    studentId: number
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Promise<
    Array<
      PickArray<AddressGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], AddressGroupByOutputType[P]> 
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      > 
    >


  export type AddressSelect = {
    idAddress?: boolean
    province?: boolean | ProvinceArgs
    provinceId?: boolean
    district?: boolean
    avenue?: boolean
    houseNumber?: boolean
    streetNumber?: boolean
    student?: boolean | StudentArgs
    studentId?: boolean
  }

  export type AddressInclude = {
    province?: boolean | ProvinceArgs
    student?: boolean | StudentArgs
  }

  export type AddressGetPayload<
    S extends boolean | null | undefined | AddressArgs,
    U = keyof S
      > = S extends true
        ? Address
    : S extends undefined
    ? never
    : S extends AddressArgs | AddressFindManyArgs
    ?'include' extends U
    ? Address  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'province'
        ? ProvinceGetPayload<S['include'][P]> :
        P extends 'student'
        ? StudentGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Address ?Address [P]
  : 
          P extends 'province'
        ? ProvinceGetPayload<S['select'][P]> :
        P extends 'student'
        ? StudentGetPayload<S['select'][P]> : never
  } 
    : Address
  : Address


  type AddressCountArgs = Merge<
    Omit<AddressFindManyArgs, 'select' | 'include'> & {
      select?: AddressCountAggregateInputType | true
    }
  >

  export interface AddressDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AddressFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AddressFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Address'> extends True ? CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>> : CheckSelect<T, Prisma__AddressClient<Address | null >, Prisma__AddressClient<AddressGetPayload<T> | null >>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AddressFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AddressFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Address'> extends True ? CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>> : CheckSelect<T, Prisma__AddressClient<Address | null >, Prisma__AddressClient<AddressGetPayload<T> | null >>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `idAddress`
     * const addressWithIdAddressOnly = await prisma.address.findMany({ select: { idAddress: true } })
     * 
    **/
    findMany<T extends AddressFindManyArgs>(
      args?: SelectSubset<T, AddressFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Address>>, PrismaPromise<Array<AddressGetPayload<T>>>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
    **/
    create<T extends AddressCreateArgs>(
      args: SelectSubset<T, AddressCreateArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Create many Addresses.
     *     @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     *     @example
     *     // Create many Addresses
     *     const address = await prisma.address.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AddressCreateManyArgs>(
      args?: SelectSubset<T, AddressCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
    **/
    delete<T extends AddressDeleteArgs>(
      args: SelectSubset<T, AddressDeleteArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AddressUpdateArgs>(
      args: SelectSubset<T, AddressUpdateArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AddressDeleteManyArgs>(
      args?: SelectSubset<T, AddressDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AddressUpdateManyArgs>(
      args: SelectSubset<T, AddressUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
    **/
    upsert<T extends AddressUpsertArgs>(
      args: SelectSubset<T, AddressUpsertArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AddressClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    province<T extends ProvinceArgs = {}>(args?: Subset<T, ProvinceArgs>): CheckSelect<T, Prisma__ProvinceClient<Province | null >, Prisma__ProvinceClient<ProvinceGetPayload<T> | null >>;

    student<T extends StudentArgs = {}>(args?: Subset<T, StudentArgs>): CheckSelect<T, Prisma__StudentClient<Student | null >, Prisma__StudentClient<StudentGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Throw an Error if a Address can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Address to fetch.
     * 
    **/
    where: AddressWhereUniqueInput
  }


  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Throw an Error if a Address can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Address to fetch.
     * 
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     * 
    **/
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     * 
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     * 
    **/
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * Address findMany
   */
  export type AddressFindManyArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Filter, which Addresses to fetch.
     * 
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     * 
    **/
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     * 
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * Address create
   */
  export type AddressCreateArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * The data needed to create a Address.
     * 
    **/
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }


  /**
   * Address createMany
   */
  export type AddressCreateManyArgs = {
    data: Enumerable<AddressCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Address update
   */
  export type AddressUpdateArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * The data needed to update a Address.
     * 
    **/
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     * 
    **/
    where: AddressWhereUniqueInput
  }


  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs = {
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    where?: AddressWhereInput
  }


  /**
   * Address upsert
   */
  export type AddressUpsertArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * The filter to search for the Address to update in case it exists.
     * 
    **/
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     * 
    **/
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }


  /**
   * Address delete
   */
  export type AddressDeleteArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Filter which Address to delete.
     * 
    **/
    where: AddressWhereUniqueInput
  }


  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs = {
    where?: AddressWhereInput
  }


  /**
   * Address without action
   */
  export type AddressArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AdministrativeOrderScalarFieldEnum: {
    idAdministrative: 'idAdministrative',
    orderTitleId: 'orderTitleId',
    orderNumber: 'orderNumber',
    orderDescription: 'orderDescription',
    orderYear: 'orderYear',
    orderLevel: 'orderLevel',
    studentId: 'studentId',
    orderDate: 'orderDate',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type AdministrativeOrderScalarFieldEnum = (typeof AdministrativeOrderScalarFieldEnum)[keyof typeof AdministrativeOrderScalarFieldEnum]


  export const OrderTitleScalarFieldEnum: {
    idOrderTitle: 'idOrderTitle',
    title: 'title',
    createdAt: 'createdAt',
    createdBy: 'createdBy'
  };

  export type OrderTitleScalarFieldEnum = (typeof OrderTitleScalarFieldEnum)[keyof typeof OrderTitleScalarFieldEnum]


  export const ExitCausesScalarFieldEnum: {
    idExitCauses: 'idExitCauses',
    exitCausesTitle: 'exitCausesTitle',
    createdAt: 'createdAt',
    createdBy: 'createdBy'
  };

  export type ExitCausesScalarFieldEnum = (typeof ExitCausesScalarFieldEnum)[keyof typeof ExitCausesScalarFieldEnum]


  export const PassTypeScalarFieldEnum: {
    idPassType: 'idPassType',
    passName: 'passName',
    createdAt: 'createdAt',
    createdBy: 'createdBy'
  };

  export type PassTypeScalarFieldEnum = (typeof PassTypeScalarFieldEnum)[keyof typeof PassTypeScalarFieldEnum]


  export const UserScalarFieldEnum: {
    idUser: 'idUser',
    userName: 'userName',
    password: 'password',
    roleId: 'roleId',
    sectionId: 'sectionId',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    idRole: 'idRole',
    roleName: 'roleName',
    createdAt: 'createdAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const SectionScalarFieldEnum: {
    idSection: 'idSection',
    sectionName: 'sectionName',
    code: 'code',
    englishName: 'englishName'
  };

  export type SectionScalarFieldEnum = (typeof SectionScalarFieldEnum)[keyof typeof SectionScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    idStudent: 'idStudent',
    studentName: 'studentName',
    englishName: 'englishName',
    mail: 'mail',
    password: 'password',
    dob: 'dob',
    sectionId: 'sectionId',
    nationality: 'nationality',
    phone: 'phone',
    gender: 'gender',
    studyType: 'studyType',
    relationships: 'relationships',
    note: 'note',
    religion: 'religion',
    motherName: 'motherName',
    collegeNumber: 'collegeNumber',
    registerYearId: 'registerYearId',
    studentStatusId: 'studentStatusId',
    acceptedTypeId: 'acceptedTypeId'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const YearStudyScalarFieldEnum: {
    idYearStudy: 'idYearStudy',
    year: 'year',
    currentYear: 'currentYear'
  };

  export type YearStudyScalarFieldEnum = (typeof YearStudyScalarFieldEnum)[keyof typeof YearStudyScalarFieldEnum]


  export const StudentResponsibleScalarFieldEnum: {
    idStudentResponsible: 'idStudentResponsible',
    responsibleName: 'responsibleName',
    responsiblePhone: 'responsiblePhone',
    studentId: 'studentId'
  };

  export type StudentResponsibleScalarFieldEnum = (typeof StudentResponsibleScalarFieldEnum)[keyof typeof StudentResponsibleScalarFieldEnum]


  export const NationalityCertificateScalarFieldEnum: {
    idNationalityCertificate: 'idNationalityCertificate',
    nationalityNumber: 'nationalityNumber',
    nationalityIssue: 'nationalityIssue',
    nationalityPlace: 'nationalityPlace',
    studentId: 'studentId'
  };

  export type NationalityCertificateScalarFieldEnum = (typeof NationalityCertificateScalarFieldEnum)[keyof typeof NationalityCertificateScalarFieldEnum]


  export const NationalInfoScalarFieldEnum: {
    idNationalInfo: 'idNationalInfo',
    nationalNumber: 'nationalNumber',
    issueNumber: 'issueNumber',
    issuePlace: 'issuePlace',
    studentId: 'studentId'
  };

  export type NationalInfoScalarFieldEnum = (typeof NationalInfoScalarFieldEnum)[keyof typeof NationalInfoScalarFieldEnum]


  export const StudentGraduationScalarFieldEnum: {
    idStudentGraduation: 'idStudentGraduation',
    graduationDate: 'graduationDate',
    studentId: 'studentId'
  };

  export type StudentGraduationScalarFieldEnum = (typeof StudentGraduationScalarFieldEnum)[keyof typeof StudentGraduationScalarFieldEnum]


  export const StudentLevelScalarFieldEnum: {
    idStudentLevel: 'idStudentLevel',
    level: 'level',
    class: 'class',
    yearStudyId: 'yearStudyId',
    studentId: 'studentId'
  };

  export type StudentLevelScalarFieldEnum = (typeof StudentLevelScalarFieldEnum)[keyof typeof StudentLevelScalarFieldEnum]


  export const StudentSchoolScalarFieldEnum: {
    idStudentSchool: 'idStudentSchool',
    schoolName: 'schoolName',
    graduationDate: 'graduationDate',
    documentDate: 'documentDate',
    totalMarks: 'totalMarks',
    average: 'average',
    documentNumber: 'documentNumber',
    lessonCount: 'lessonCount',
    Directorate: 'Directorate',
    studySubCategoryId: 'studySubCategoryId',
    studentId: 'studentId',
    certificateStatusId: 'certificateStatusId',
    certificateStatusDescription: 'certificateStatusDescription',
    createdAt: 'createdAt'
  };

  export type StudentSchoolScalarFieldEnum = (typeof StudentSchoolScalarFieldEnum)[keyof typeof StudentSchoolScalarFieldEnum]


  export const StudyCategoryScalarFieldEnum: {
    idStudyCategory: 'idStudyCategory',
    categoryName: 'categoryName'
  };

  export type StudyCategoryScalarFieldEnum = (typeof StudyCategoryScalarFieldEnum)[keyof typeof StudyCategoryScalarFieldEnum]


  export const StudySubCategoryScalarFieldEnum: {
    idStudySubCategory: 'idStudySubCategory',
    subCategoryName: 'subCategoryName',
    studyCategoryId: 'studyCategoryId'
  };

  export type StudySubCategoryScalarFieldEnum = (typeof StudySubCategoryScalarFieldEnum)[keyof typeof StudySubCategoryScalarFieldEnum]


  export const CertificateStatusScalarFieldEnum: {
    idCertificateStatus: 'idCertificateStatus',
    certificateStatusName: 'certificateStatusName'
  };

  export type CertificateStatusScalarFieldEnum = (typeof CertificateStatusScalarFieldEnum)[keyof typeof CertificateStatusScalarFieldEnum]


  export const StudentStatusScalarFieldEnum: {
    idStudentStatus: 'idStudentStatus',
    statusName: 'statusName'
  };

  export type StudentStatusScalarFieldEnum = (typeof StudentStatusScalarFieldEnum)[keyof typeof StudentStatusScalarFieldEnum]


  export const AcceptedTypeScalarFieldEnum: {
    idAcceptedType: 'idAcceptedType',
    acceptedName: 'acceptedName'
  };

  export type AcceptedTypeScalarFieldEnum = (typeof AcceptedTypeScalarFieldEnum)[keyof typeof AcceptedTypeScalarFieldEnum]


  export const StudentImageScalarFieldEnum: {
    idStudentImage: 'idStudentImage',
    imagePath: 'imagePath',
    studentId: 'studentId'
  };

  export type StudentImageScalarFieldEnum = (typeof StudentImageScalarFieldEnum)[keyof typeof StudentImageScalarFieldEnum]


  export const ProvinceScalarFieldEnum: {
    idProvince: 'idProvince',
    provinceName: 'provinceName',
    provinceNameEn: 'provinceNameEn'
  };

  export type ProvinceScalarFieldEnum = (typeof ProvinceScalarFieldEnum)[keyof typeof ProvinceScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    idAddress: 'idAddress',
    provinceId: 'provinceId',
    district: 'district',
    avenue: 'avenue',
    houseNumber: 'houseNumber',
    streetNumber: 'streetNumber',
    studentId: 'studentId'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type AdministrativeOrderWhereInput = {
    AND?: Enumerable<AdministrativeOrderWhereInput>
    OR?: Enumerable<AdministrativeOrderWhereInput>
    NOT?: Enumerable<AdministrativeOrderWhereInput>
    idAdministrative?: IntFilter | number
    orderTitle?: XOR<OrderTitleRelationFilter, OrderTitleWhereInput>
    orderTitleId?: IntFilter | number
    orderNumber?: IntFilter | number
    orderDescription?: StringFilter | string
    orderYear?: StringFilter | string
    orderLevel?: IntFilter | number
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    studentId?: IntFilter | number
    orderDate?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    createdBy?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
  }

  export type AdministrativeOrderOrderByWithRelationInput = {
    idAdministrative?: SortOrder
    orderTitle?: OrderTitleOrderByWithRelationInput
    orderTitleId?: SortOrder
    orderNumber?: SortOrder
    orderDescription?: SortOrder
    orderYear?: SortOrder
    orderLevel?: SortOrder
    student?: StudentOrderByWithRelationInput
    studentId?: SortOrder
    orderDate?: SortOrder
    user?: UserOrderByWithRelationInput
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type AdministrativeOrderWhereUniqueInput = {
    idAdministrative?: number
  }

  export type AdministrativeOrderOrderByWithAggregationInput = {
    idAdministrative?: SortOrder
    orderTitleId?: SortOrder
    orderNumber?: SortOrder
    orderDescription?: SortOrder
    orderYear?: SortOrder
    orderLevel?: SortOrder
    studentId?: SortOrder
    orderDate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    _count?: AdministrativeOrderCountOrderByAggregateInput
    _avg?: AdministrativeOrderAvgOrderByAggregateInput
    _max?: AdministrativeOrderMaxOrderByAggregateInput
    _min?: AdministrativeOrderMinOrderByAggregateInput
    _sum?: AdministrativeOrderSumOrderByAggregateInput
  }

  export type AdministrativeOrderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AdministrativeOrderScalarWhereWithAggregatesInput>
    OR?: Enumerable<AdministrativeOrderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AdministrativeOrderScalarWhereWithAggregatesInput>
    idAdministrative?: IntWithAggregatesFilter | number
    orderTitleId?: IntWithAggregatesFilter | number
    orderNumber?: IntWithAggregatesFilter | number
    orderDescription?: StringWithAggregatesFilter | string
    orderYear?: StringWithAggregatesFilter | string
    orderLevel?: IntWithAggregatesFilter | number
    studentId?: IntWithAggregatesFilter | number
    orderDate?: DateTimeWithAggregatesFilter | Date | string
    createdBy?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type OrderTitleWhereInput = {
    AND?: Enumerable<OrderTitleWhereInput>
    OR?: Enumerable<OrderTitleWhereInput>
    NOT?: Enumerable<OrderTitleWhereInput>
    idOrderTitle?: IntFilter | number
    title?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    createdBy?: IntFilter | number
    administrativeOrders?: AdministrativeOrderListRelationFilter
  }

  export type OrderTitleOrderByWithRelationInput = {
    idOrderTitle?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    createdBy?: SortOrder
    administrativeOrders?: AdministrativeOrderOrderByRelationAggregateInput
  }

  export type OrderTitleWhereUniqueInput = {
    idOrderTitle?: number
  }

  export type OrderTitleOrderByWithAggregationInput = {
    idOrderTitle?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    _count?: OrderTitleCountOrderByAggregateInput
    _avg?: OrderTitleAvgOrderByAggregateInput
    _max?: OrderTitleMaxOrderByAggregateInput
    _min?: OrderTitleMinOrderByAggregateInput
    _sum?: OrderTitleSumOrderByAggregateInput
  }

  export type OrderTitleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrderTitleScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrderTitleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrderTitleScalarWhereWithAggregatesInput>
    idOrderTitle?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    createdBy?: IntWithAggregatesFilter | number
  }

  export type ExitCausesWhereInput = {
    AND?: Enumerable<ExitCausesWhereInput>
    OR?: Enumerable<ExitCausesWhereInput>
    NOT?: Enumerable<ExitCausesWhereInput>
    idExitCauses?: IntFilter | number
    exitCausesTitle?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    createdBy?: IntFilter | number
  }

  export type ExitCausesOrderByWithRelationInput = {
    idExitCauses?: SortOrder
    exitCausesTitle?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    createdBy?: SortOrder
  }

  export type ExitCausesWhereUniqueInput = {
    idExitCauses?: number
  }

  export type ExitCausesOrderByWithAggregationInput = {
    idExitCauses?: SortOrder
    exitCausesTitle?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    _count?: ExitCausesCountOrderByAggregateInput
    _avg?: ExitCausesAvgOrderByAggregateInput
    _max?: ExitCausesMaxOrderByAggregateInput
    _min?: ExitCausesMinOrderByAggregateInput
    _sum?: ExitCausesSumOrderByAggregateInput
  }

  export type ExitCausesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ExitCausesScalarWhereWithAggregatesInput>
    OR?: Enumerable<ExitCausesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ExitCausesScalarWhereWithAggregatesInput>
    idExitCauses?: IntWithAggregatesFilter | number
    exitCausesTitle?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    createdBy?: IntWithAggregatesFilter | number
  }

  export type PassTypeWhereInput = {
    AND?: Enumerable<PassTypeWhereInput>
    OR?: Enumerable<PassTypeWhereInput>
    NOT?: Enumerable<PassTypeWhereInput>
    idPassType?: IntFilter | number
    passName?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    createdBy?: IntFilter | number
  }

  export type PassTypeOrderByWithRelationInput = {
    idPassType?: SortOrder
    passName?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    createdBy?: SortOrder
  }

  export type PassTypeWhereUniqueInput = {
    idPassType?: number
  }

  export type PassTypeOrderByWithAggregationInput = {
    idPassType?: SortOrder
    passName?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    _count?: PassTypeCountOrderByAggregateInput
    _avg?: PassTypeAvgOrderByAggregateInput
    _max?: PassTypeMaxOrderByAggregateInput
    _min?: PassTypeMinOrderByAggregateInput
    _sum?: PassTypeSumOrderByAggregateInput
  }

  export type PassTypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PassTypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<PassTypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PassTypeScalarWhereWithAggregatesInput>
    idPassType?: IntWithAggregatesFilter | number
    passName?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    createdBy?: IntWithAggregatesFilter | number
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    idUser?: IntFilter | number
    userName?: StringFilter | string
    password?: StringFilter | string
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    roleId?: IntFilter | number
    section?: XOR<SectionRelationFilter, SectionWhereInput>
    sectionId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    passTypes?: PassTypeListRelationFilter
    administrativeOrders?: AdministrativeOrderListRelationFilter
    OrderTitles?: OrderTitleListRelationFilter
    ExitCauses?: ExitCausesListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    idUser?: SortOrder
    userName?: SortOrder
    password?: SortOrder
    role?: RoleOrderByWithRelationInput
    roleId?: SortOrder
    section?: SectionOrderByWithRelationInput
    sectionId?: SortOrder
    createdAt?: SortOrder
    passTypes?: PassTypeOrderByRelationAggregateInput
    administrativeOrders?: AdministrativeOrderOrderByRelationAggregateInput
    OrderTitles?: OrderTitleOrderByRelationAggregateInput
    ExitCauses?: ExitCausesOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    idUser?: number
  }

  export type UserOrderByWithAggregationInput = {
    idUser?: SortOrder
    userName?: SortOrder
    password?: SortOrder
    roleId?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    idUser?: IntWithAggregatesFilter | number
    userName?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    roleId?: IntWithAggregatesFilter | number
    sectionId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RoleWhereInput = {
    AND?: Enumerable<RoleWhereInput>
    OR?: Enumerable<RoleWhereInput>
    NOT?: Enumerable<RoleWhereInput>
    idRole?: IntFilter | number
    roleName?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    users?: UserListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    idRole?: SortOrder
    roleName?: SortOrder
    createdAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = {
    idRole?: number
  }

  export type RoleOrderByWithAggregationInput = {
    idRole?: SortOrder
    roleName?: SortOrder
    createdAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RoleScalarWhereWithAggregatesInput>
    OR?: Enumerable<RoleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RoleScalarWhereWithAggregatesInput>
    idRole?: IntWithAggregatesFilter | number
    roleName?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SectionWhereInput = {
    AND?: Enumerable<SectionWhereInput>
    OR?: Enumerable<SectionWhereInput>
    NOT?: Enumerable<SectionWhereInput>
    idSection?: IntFilter | number
    sectionName?: StringFilter | string
    code?: StringFilter | string
    englishName?: StringFilter | string
    students?: StudentListRelationFilter
    User?: UserListRelationFilter
  }

  export type SectionOrderByWithRelationInput = {
    idSection?: SortOrder
    sectionName?: SortOrder
    code?: SortOrder
    englishName?: SortOrder
    students?: StudentOrderByRelationAggregateInput
    User?: UserOrderByRelationAggregateInput
  }

  export type SectionWhereUniqueInput = {
    idSection?: number
  }

  export type SectionOrderByWithAggregationInput = {
    idSection?: SortOrder
    sectionName?: SortOrder
    code?: SortOrder
    englishName?: SortOrder
    _count?: SectionCountOrderByAggregateInput
    _avg?: SectionAvgOrderByAggregateInput
    _max?: SectionMaxOrderByAggregateInput
    _min?: SectionMinOrderByAggregateInput
    _sum?: SectionSumOrderByAggregateInput
  }

  export type SectionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SectionScalarWhereWithAggregatesInput>
    OR?: Enumerable<SectionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SectionScalarWhereWithAggregatesInput>
    idSection?: IntWithAggregatesFilter | number
    sectionName?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    englishName?: StringWithAggregatesFilter | string
  }

  export type StudentWhereInput = {
    AND?: Enumerable<StudentWhereInput>
    OR?: Enumerable<StudentWhereInput>
    NOT?: Enumerable<StudentWhereInput>
    idStudent?: IntFilter | number
    studentName?: StringFilter | string
    englishName?: StringFilter | string
    mail?: StringFilter | string
    password?: StringFilter | string
    dob?: StringFilter | string
    section?: XOR<SectionRelationFilter, SectionWhereInput>
    sectionId?: IntFilter | number
    nationality?: StringFilter | string
    phone?: StringFilter | string
    gender?: BoolFilter | boolean
    studyType?: BoolFilter | boolean
    relationships?: BoolFilter | boolean
    note?: StringFilter | string
    religion?: StringFilter | string
    motherName?: StringFilter | string
    collegeNumber?: StringFilter | string
    yearStudy?: XOR<YearStudyRelationFilter, YearStudyWhereInput>
    registerYearId?: IntFilter | number
    studentStatus?: XOR<StudentStatusRelationFilter, StudentStatusWhereInput>
    studentStatusId?: IntFilter | number
    acceptedType?: XOR<AcceptedTypeRelationFilter, AcceptedTypeWhereInput>
    acceptedTypeId?: IntFilter | number
    administrativeOrders?: AdministrativeOrderListRelationFilter
    studentSchool?: XOR<StudentSchoolRelationFilter, StudentSchoolWhereInput> | null
    studentLevel?: StudentLevelListRelationFilter
    studentGraduation?: XOR<StudentGraduationRelationFilter, StudentGraduationWhereInput> | null
    nationalInfo?: XOR<NationalInfoRelationFilter, NationalInfoWhereInput> | null
    studentResponsables?: StudentResponsibleListRelationFilter
    nationalityCertificate?: NationalityCertificateListRelationFilter
    studentImage?: StudentImageListRelationFilter
    address?: XOR<AddressRelationFilter, AddressWhereInput> | null
  }

  export type StudentOrderByWithRelationInput = {
    idStudent?: SortOrder
    studentName?: SortOrder
    englishName?: SortOrder
    mail?: SortOrder
    password?: SortOrder
    dob?: SortOrder
    section?: SectionOrderByWithRelationInput
    sectionId?: SortOrder
    nationality?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    studyType?: SortOrder
    relationships?: SortOrder
    note?: SortOrder
    religion?: SortOrder
    motherName?: SortOrder
    collegeNumber?: SortOrder
    yearStudy?: YearStudyOrderByWithRelationInput
    registerYearId?: SortOrder
    studentStatus?: StudentStatusOrderByWithRelationInput
    studentStatusId?: SortOrder
    acceptedType?: AcceptedTypeOrderByWithRelationInput
    acceptedTypeId?: SortOrder
    administrativeOrders?: AdministrativeOrderOrderByRelationAggregateInput
    studentSchool?: StudentSchoolOrderByWithRelationInput
    studentLevel?: StudentLevelOrderByRelationAggregateInput
    studentGraduation?: StudentGraduationOrderByWithRelationInput
    nationalInfo?: NationalInfoOrderByWithRelationInput
    studentResponsables?: StudentResponsibleOrderByRelationAggregateInput
    nationalityCertificate?: NationalityCertificateOrderByRelationAggregateInput
    studentImage?: StudentImageOrderByRelationAggregateInput
    address?: AddressOrderByWithRelationInput
  }

  export type StudentWhereUniqueInput = {
    idStudent?: number
    mail?: string
  }

  export type StudentOrderByWithAggregationInput = {
    idStudent?: SortOrder
    studentName?: SortOrder
    englishName?: SortOrder
    mail?: SortOrder
    password?: SortOrder
    dob?: SortOrder
    sectionId?: SortOrder
    nationality?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    studyType?: SortOrder
    relationships?: SortOrder
    note?: SortOrder
    religion?: SortOrder
    motherName?: SortOrder
    collegeNumber?: SortOrder
    registerYearId?: SortOrder
    studentStatusId?: SortOrder
    acceptedTypeId?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _avg?: StudentAvgOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
    _sum?: StudentSumOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StudentScalarWhereWithAggregatesInput>
    OR?: Enumerable<StudentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StudentScalarWhereWithAggregatesInput>
    idStudent?: IntWithAggregatesFilter | number
    studentName?: StringWithAggregatesFilter | string
    englishName?: StringWithAggregatesFilter | string
    mail?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    dob?: StringWithAggregatesFilter | string
    sectionId?: IntWithAggregatesFilter | number
    nationality?: StringWithAggregatesFilter | string
    phone?: StringWithAggregatesFilter | string
    gender?: BoolWithAggregatesFilter | boolean
    studyType?: BoolWithAggregatesFilter | boolean
    relationships?: BoolWithAggregatesFilter | boolean
    note?: StringWithAggregatesFilter | string
    religion?: StringWithAggregatesFilter | string
    motherName?: StringWithAggregatesFilter | string
    collegeNumber?: StringWithAggregatesFilter | string
    registerYearId?: IntWithAggregatesFilter | number
    studentStatusId?: IntWithAggregatesFilter | number
    acceptedTypeId?: IntWithAggregatesFilter | number
  }

  export type YearStudyWhereInput = {
    AND?: Enumerable<YearStudyWhereInput>
    OR?: Enumerable<YearStudyWhereInput>
    NOT?: Enumerable<YearStudyWhereInput>
    idYearStudy?: IntFilter | number
    year?: StringFilter | string
    currentYear?: BoolFilter | boolean
    StudentLevel?: StudentLevelListRelationFilter
    Student?: StudentListRelationFilter
  }

  export type YearStudyOrderByWithRelationInput = {
    idYearStudy?: SortOrder
    year?: SortOrder
    currentYear?: SortOrder
    StudentLevel?: StudentLevelOrderByRelationAggregateInput
    Student?: StudentOrderByRelationAggregateInput
  }

  export type YearStudyWhereUniqueInput = {
    idYearStudy?: number
  }

  export type YearStudyOrderByWithAggregationInput = {
    idYearStudy?: SortOrder
    year?: SortOrder
    currentYear?: SortOrder
    _count?: YearStudyCountOrderByAggregateInput
    _avg?: YearStudyAvgOrderByAggregateInput
    _max?: YearStudyMaxOrderByAggregateInput
    _min?: YearStudyMinOrderByAggregateInput
    _sum?: YearStudySumOrderByAggregateInput
  }

  export type YearStudyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YearStudyScalarWhereWithAggregatesInput>
    OR?: Enumerable<YearStudyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YearStudyScalarWhereWithAggregatesInput>
    idYearStudy?: IntWithAggregatesFilter | number
    year?: StringWithAggregatesFilter | string
    currentYear?: BoolWithAggregatesFilter | boolean
  }

  export type StudentResponsibleWhereInput = {
    AND?: Enumerable<StudentResponsibleWhereInput>
    OR?: Enumerable<StudentResponsibleWhereInput>
    NOT?: Enumerable<StudentResponsibleWhereInput>
    idStudentResponsible?: IntFilter | number
    responsibleName?: StringFilter | string
    responsiblePhone?: StringFilter | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    studentId?: IntFilter | number
  }

  export type StudentResponsibleOrderByWithRelationInput = {
    idStudentResponsible?: SortOrder
    responsibleName?: SortOrder
    responsiblePhone?: SortOrder
    student?: StudentOrderByWithRelationInput
    studentId?: SortOrder
  }

  export type StudentResponsibleWhereUniqueInput = {
    idStudentResponsible?: number
  }

  export type StudentResponsibleOrderByWithAggregationInput = {
    idStudentResponsible?: SortOrder
    responsibleName?: SortOrder
    responsiblePhone?: SortOrder
    studentId?: SortOrder
    _count?: StudentResponsibleCountOrderByAggregateInput
    _avg?: StudentResponsibleAvgOrderByAggregateInput
    _max?: StudentResponsibleMaxOrderByAggregateInput
    _min?: StudentResponsibleMinOrderByAggregateInput
    _sum?: StudentResponsibleSumOrderByAggregateInput
  }

  export type StudentResponsibleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StudentResponsibleScalarWhereWithAggregatesInput>
    OR?: Enumerable<StudentResponsibleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StudentResponsibleScalarWhereWithAggregatesInput>
    idStudentResponsible?: IntWithAggregatesFilter | number
    responsibleName?: StringWithAggregatesFilter | string
    responsiblePhone?: StringWithAggregatesFilter | string
    studentId?: IntWithAggregatesFilter | number
  }

  export type NationalityCertificateWhereInput = {
    AND?: Enumerable<NationalityCertificateWhereInput>
    OR?: Enumerable<NationalityCertificateWhereInput>
    NOT?: Enumerable<NationalityCertificateWhereInput>
    idNationalityCertificate?: IntFilter | number
    nationalityNumber?: StringFilter | string
    nationalityIssue?: StringFilter | string
    nationalityPlace?: StringFilter | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    studentId?: IntFilter | number
  }

  export type NationalityCertificateOrderByWithRelationInput = {
    idNationalityCertificate?: SortOrder
    nationalityNumber?: SortOrder
    nationalityIssue?: SortOrder
    nationalityPlace?: SortOrder
    student?: StudentOrderByWithRelationInput
    studentId?: SortOrder
  }

  export type NationalityCertificateWhereUniqueInput = {
    idNationalityCertificate?: number
  }

  export type NationalityCertificateOrderByWithAggregationInput = {
    idNationalityCertificate?: SortOrder
    nationalityNumber?: SortOrder
    nationalityIssue?: SortOrder
    nationalityPlace?: SortOrder
    studentId?: SortOrder
    _count?: NationalityCertificateCountOrderByAggregateInput
    _avg?: NationalityCertificateAvgOrderByAggregateInput
    _max?: NationalityCertificateMaxOrderByAggregateInput
    _min?: NationalityCertificateMinOrderByAggregateInput
    _sum?: NationalityCertificateSumOrderByAggregateInput
  }

  export type NationalityCertificateScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NationalityCertificateScalarWhereWithAggregatesInput>
    OR?: Enumerable<NationalityCertificateScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NationalityCertificateScalarWhereWithAggregatesInput>
    idNationalityCertificate?: IntWithAggregatesFilter | number
    nationalityNumber?: StringWithAggregatesFilter | string
    nationalityIssue?: StringWithAggregatesFilter | string
    nationalityPlace?: StringWithAggregatesFilter | string
    studentId?: IntWithAggregatesFilter | number
  }

  export type NationalInfoWhereInput = {
    AND?: Enumerable<NationalInfoWhereInput>
    OR?: Enumerable<NationalInfoWhereInput>
    NOT?: Enumerable<NationalInfoWhereInput>
    idNationalInfo?: IntFilter | number
    nationalNumber?: StringFilter | string
    issueNumber?: StringFilter | string
    issuePlace?: StringFilter | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    studentId?: IntFilter | number
  }

  export type NationalInfoOrderByWithRelationInput = {
    idNationalInfo?: SortOrder
    nationalNumber?: SortOrder
    issueNumber?: SortOrder
    issuePlace?: SortOrder
    student?: StudentOrderByWithRelationInput
    studentId?: SortOrder
  }

  export type NationalInfoWhereUniqueInput = {
    idNationalInfo?: number
  }

  export type NationalInfoOrderByWithAggregationInput = {
    idNationalInfo?: SortOrder
    nationalNumber?: SortOrder
    issueNumber?: SortOrder
    issuePlace?: SortOrder
    studentId?: SortOrder
    _count?: NationalInfoCountOrderByAggregateInput
    _avg?: NationalInfoAvgOrderByAggregateInput
    _max?: NationalInfoMaxOrderByAggregateInput
    _min?: NationalInfoMinOrderByAggregateInput
    _sum?: NationalInfoSumOrderByAggregateInput
  }

  export type NationalInfoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NationalInfoScalarWhereWithAggregatesInput>
    OR?: Enumerable<NationalInfoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NationalInfoScalarWhereWithAggregatesInput>
    idNationalInfo?: IntWithAggregatesFilter | number
    nationalNumber?: StringWithAggregatesFilter | string
    issueNumber?: StringWithAggregatesFilter | string
    issuePlace?: StringWithAggregatesFilter | string
    studentId?: IntWithAggregatesFilter | number
  }

  export type StudentGraduationWhereInput = {
    AND?: Enumerable<StudentGraduationWhereInput>
    OR?: Enumerable<StudentGraduationWhereInput>
    NOT?: Enumerable<StudentGraduationWhereInput>
    idStudentGraduation?: IntFilter | number
    graduationDate?: StringFilter | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    studentId?: IntFilter | number
  }

  export type StudentGraduationOrderByWithRelationInput = {
    idStudentGraduation?: SortOrder
    graduationDate?: SortOrder
    student?: StudentOrderByWithRelationInput
    studentId?: SortOrder
  }

  export type StudentGraduationWhereUniqueInput = {
    idStudentGraduation?: number
  }

  export type StudentGraduationOrderByWithAggregationInput = {
    idStudentGraduation?: SortOrder
    graduationDate?: SortOrder
    studentId?: SortOrder
    _count?: StudentGraduationCountOrderByAggregateInput
    _avg?: StudentGraduationAvgOrderByAggregateInput
    _max?: StudentGraduationMaxOrderByAggregateInput
    _min?: StudentGraduationMinOrderByAggregateInput
    _sum?: StudentGraduationSumOrderByAggregateInput
  }

  export type StudentGraduationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StudentGraduationScalarWhereWithAggregatesInput>
    OR?: Enumerable<StudentGraduationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StudentGraduationScalarWhereWithAggregatesInput>
    idStudentGraduation?: IntWithAggregatesFilter | number
    graduationDate?: StringWithAggregatesFilter | string
    studentId?: IntWithAggregatesFilter | number
  }

  export type StudentLevelWhereInput = {
    AND?: Enumerable<StudentLevelWhereInput>
    OR?: Enumerable<StudentLevelWhereInput>
    NOT?: Enumerable<StudentLevelWhereInput>
    idStudentLevel?: IntFilter | number
    level?: IntFilter | number
    class?: StringFilter | string
    yearStudy?: XOR<YearStudyRelationFilter, YearStudyWhereInput>
    yearStudyId?: IntFilter | number
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    studentId?: IntFilter | number
  }

  export type StudentLevelOrderByWithRelationInput = {
    idStudentLevel?: SortOrder
    level?: SortOrder
    class?: SortOrder
    yearStudy?: YearStudyOrderByWithRelationInput
    yearStudyId?: SortOrder
    student?: StudentOrderByWithRelationInput
    studentId?: SortOrder
  }

  export type StudentLevelWhereUniqueInput = {
    idStudentLevel?: number
  }

  export type StudentLevelOrderByWithAggregationInput = {
    idStudentLevel?: SortOrder
    level?: SortOrder
    class?: SortOrder
    yearStudyId?: SortOrder
    studentId?: SortOrder
    _count?: StudentLevelCountOrderByAggregateInput
    _avg?: StudentLevelAvgOrderByAggregateInput
    _max?: StudentLevelMaxOrderByAggregateInput
    _min?: StudentLevelMinOrderByAggregateInput
    _sum?: StudentLevelSumOrderByAggregateInput
  }

  export type StudentLevelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StudentLevelScalarWhereWithAggregatesInput>
    OR?: Enumerable<StudentLevelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StudentLevelScalarWhereWithAggregatesInput>
    idStudentLevel?: IntWithAggregatesFilter | number
    level?: IntWithAggregatesFilter | number
    class?: StringWithAggregatesFilter | string
    yearStudyId?: IntWithAggregatesFilter | number
    studentId?: IntWithAggregatesFilter | number
  }

  export type StudentSchoolWhereInput = {
    AND?: Enumerable<StudentSchoolWhereInput>
    OR?: Enumerable<StudentSchoolWhereInput>
    NOT?: Enumerable<StudentSchoolWhereInput>
    idStudentSchool?: IntFilter | number
    schoolName?: StringFilter | string
    graduationDate?: StringFilter | string
    documentDate?: StringFilter | string
    totalMarks?: IntFilter | number
    average?: FloatFilter | number
    documentNumber?: IntFilter | number
    lessonCount?: IntFilter | number
    Directorate?: StringFilter | string
    studySubCategory?: XOR<StudySubCategoryRelationFilter, StudySubCategoryWhereInput>
    studySubCategoryId?: IntFilter | number
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    studentId?: IntFilter | number
    certificateStatus?: XOR<CertificateStatusRelationFilter, CertificateStatusWhereInput>
    certificateStatusId?: IntFilter | number
    certificateStatusDescription?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type StudentSchoolOrderByWithRelationInput = {
    idStudentSchool?: SortOrder
    schoolName?: SortOrder
    graduationDate?: SortOrder
    documentDate?: SortOrder
    totalMarks?: SortOrder
    average?: SortOrder
    documentNumber?: SortOrder
    lessonCount?: SortOrder
    Directorate?: SortOrder
    studySubCategory?: StudySubCategoryOrderByWithRelationInput
    studySubCategoryId?: SortOrder
    student?: StudentOrderByWithRelationInput
    studentId?: SortOrder
    certificateStatus?: CertificateStatusOrderByWithRelationInput
    certificateStatusId?: SortOrder
    certificateStatusDescription?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentSchoolWhereUniqueInput = {
    idStudentSchool?: number
  }

  export type StudentSchoolOrderByWithAggregationInput = {
    idStudentSchool?: SortOrder
    schoolName?: SortOrder
    graduationDate?: SortOrder
    documentDate?: SortOrder
    totalMarks?: SortOrder
    average?: SortOrder
    documentNumber?: SortOrder
    lessonCount?: SortOrder
    Directorate?: SortOrder
    studySubCategoryId?: SortOrder
    studentId?: SortOrder
    certificateStatusId?: SortOrder
    certificateStatusDescription?: SortOrder
    createdAt?: SortOrder
    _count?: StudentSchoolCountOrderByAggregateInput
    _avg?: StudentSchoolAvgOrderByAggregateInput
    _max?: StudentSchoolMaxOrderByAggregateInput
    _min?: StudentSchoolMinOrderByAggregateInput
    _sum?: StudentSchoolSumOrderByAggregateInput
  }

  export type StudentSchoolScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StudentSchoolScalarWhereWithAggregatesInput>
    OR?: Enumerable<StudentSchoolScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StudentSchoolScalarWhereWithAggregatesInput>
    idStudentSchool?: IntWithAggregatesFilter | number
    schoolName?: StringWithAggregatesFilter | string
    graduationDate?: StringWithAggregatesFilter | string
    documentDate?: StringWithAggregatesFilter | string
    totalMarks?: IntWithAggregatesFilter | number
    average?: FloatWithAggregatesFilter | number
    documentNumber?: IntWithAggregatesFilter | number
    lessonCount?: IntWithAggregatesFilter | number
    Directorate?: StringWithAggregatesFilter | string
    studySubCategoryId?: IntWithAggregatesFilter | number
    studentId?: IntWithAggregatesFilter | number
    certificateStatusId?: IntWithAggregatesFilter | number
    certificateStatusDescription?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type StudyCategoryWhereInput = {
    AND?: Enumerable<StudyCategoryWhereInput>
    OR?: Enumerable<StudyCategoryWhereInput>
    NOT?: Enumerable<StudyCategoryWhereInput>
    idStudyCategory?: IntFilter | number
    categoryName?: StringFilter | string
    StudySubCategory?: StudySubCategoryListRelationFilter
  }

  export type StudyCategoryOrderByWithRelationInput = {
    idStudyCategory?: SortOrder
    categoryName?: SortOrder
    StudySubCategory?: StudySubCategoryOrderByRelationAggregateInput
  }

  export type StudyCategoryWhereUniqueInput = {
    idStudyCategory?: number
  }

  export type StudyCategoryOrderByWithAggregationInput = {
    idStudyCategory?: SortOrder
    categoryName?: SortOrder
    _count?: StudyCategoryCountOrderByAggregateInput
    _avg?: StudyCategoryAvgOrderByAggregateInput
    _max?: StudyCategoryMaxOrderByAggregateInput
    _min?: StudyCategoryMinOrderByAggregateInput
    _sum?: StudyCategorySumOrderByAggregateInput
  }

  export type StudyCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StudyCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<StudyCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StudyCategoryScalarWhereWithAggregatesInput>
    idStudyCategory?: IntWithAggregatesFilter | number
    categoryName?: StringWithAggregatesFilter | string
  }

  export type StudySubCategoryWhereInput = {
    AND?: Enumerable<StudySubCategoryWhereInput>
    OR?: Enumerable<StudySubCategoryWhereInput>
    NOT?: Enumerable<StudySubCategoryWhereInput>
    idStudySubCategory?: IntFilter | number
    subCategoryName?: StringFilter | string
    studyCategory?: XOR<StudyCategoryRelationFilter, StudyCategoryWhereInput>
    studyCategoryId?: IntFilter | number
    StudentSchool?: StudentSchoolListRelationFilter
  }

  export type StudySubCategoryOrderByWithRelationInput = {
    idStudySubCategory?: SortOrder
    subCategoryName?: SortOrder
    studyCategory?: StudyCategoryOrderByWithRelationInput
    studyCategoryId?: SortOrder
    StudentSchool?: StudentSchoolOrderByRelationAggregateInput
  }

  export type StudySubCategoryWhereUniqueInput = {
    idStudySubCategory?: number
  }

  export type StudySubCategoryOrderByWithAggregationInput = {
    idStudySubCategory?: SortOrder
    subCategoryName?: SortOrder
    studyCategoryId?: SortOrder
    _count?: StudySubCategoryCountOrderByAggregateInput
    _avg?: StudySubCategoryAvgOrderByAggregateInput
    _max?: StudySubCategoryMaxOrderByAggregateInput
    _min?: StudySubCategoryMinOrderByAggregateInput
    _sum?: StudySubCategorySumOrderByAggregateInput
  }

  export type StudySubCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StudySubCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<StudySubCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StudySubCategoryScalarWhereWithAggregatesInput>
    idStudySubCategory?: IntWithAggregatesFilter | number
    subCategoryName?: StringWithAggregatesFilter | string
    studyCategoryId?: IntWithAggregatesFilter | number
  }

  export type CertificateStatusWhereInput = {
    AND?: Enumerable<CertificateStatusWhereInput>
    OR?: Enumerable<CertificateStatusWhereInput>
    NOT?: Enumerable<CertificateStatusWhereInput>
    idCertificateStatus?: IntFilter | number
    certificateStatusName?: StringFilter | string
    studentSchool?: StudentSchoolListRelationFilter
  }

  export type CertificateStatusOrderByWithRelationInput = {
    idCertificateStatus?: SortOrder
    certificateStatusName?: SortOrder
    studentSchool?: StudentSchoolOrderByRelationAggregateInput
  }

  export type CertificateStatusWhereUniqueInput = {
    idCertificateStatus?: number
  }

  export type CertificateStatusOrderByWithAggregationInput = {
    idCertificateStatus?: SortOrder
    certificateStatusName?: SortOrder
    _count?: CertificateStatusCountOrderByAggregateInput
    _avg?: CertificateStatusAvgOrderByAggregateInput
    _max?: CertificateStatusMaxOrderByAggregateInput
    _min?: CertificateStatusMinOrderByAggregateInput
    _sum?: CertificateStatusSumOrderByAggregateInput
  }

  export type CertificateStatusScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CertificateStatusScalarWhereWithAggregatesInput>
    OR?: Enumerable<CertificateStatusScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CertificateStatusScalarWhereWithAggregatesInput>
    idCertificateStatus?: IntWithAggregatesFilter | number
    certificateStatusName?: StringWithAggregatesFilter | string
  }

  export type StudentStatusWhereInput = {
    AND?: Enumerable<StudentStatusWhereInput>
    OR?: Enumerable<StudentStatusWhereInput>
    NOT?: Enumerable<StudentStatusWhereInput>
    idStudentStatus?: IntFilter | number
    statusName?: StringFilter | string
    students?: StudentListRelationFilter
  }

  export type StudentStatusOrderByWithRelationInput = {
    idStudentStatus?: SortOrder
    statusName?: SortOrder
    students?: StudentOrderByRelationAggregateInput
  }

  export type StudentStatusWhereUniqueInput = {
    idStudentStatus?: number
  }

  export type StudentStatusOrderByWithAggregationInput = {
    idStudentStatus?: SortOrder
    statusName?: SortOrder
    _count?: StudentStatusCountOrderByAggregateInput
    _avg?: StudentStatusAvgOrderByAggregateInput
    _max?: StudentStatusMaxOrderByAggregateInput
    _min?: StudentStatusMinOrderByAggregateInput
    _sum?: StudentStatusSumOrderByAggregateInput
  }

  export type StudentStatusScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StudentStatusScalarWhereWithAggregatesInput>
    OR?: Enumerable<StudentStatusScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StudentStatusScalarWhereWithAggregatesInput>
    idStudentStatus?: IntWithAggregatesFilter | number
    statusName?: StringWithAggregatesFilter | string
  }

  export type AcceptedTypeWhereInput = {
    AND?: Enumerable<AcceptedTypeWhereInput>
    OR?: Enumerable<AcceptedTypeWhereInput>
    NOT?: Enumerable<AcceptedTypeWhereInput>
    idAcceptedType?: IntFilter | number
    acceptedName?: StringFilter | string
    students?: StudentListRelationFilter
  }

  export type AcceptedTypeOrderByWithRelationInput = {
    idAcceptedType?: SortOrder
    acceptedName?: SortOrder
    students?: StudentOrderByRelationAggregateInput
  }

  export type AcceptedTypeWhereUniqueInput = {
    idAcceptedType?: number
  }

  export type AcceptedTypeOrderByWithAggregationInput = {
    idAcceptedType?: SortOrder
    acceptedName?: SortOrder
    _count?: AcceptedTypeCountOrderByAggregateInput
    _avg?: AcceptedTypeAvgOrderByAggregateInput
    _max?: AcceptedTypeMaxOrderByAggregateInput
    _min?: AcceptedTypeMinOrderByAggregateInput
    _sum?: AcceptedTypeSumOrderByAggregateInput
  }

  export type AcceptedTypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AcceptedTypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<AcceptedTypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AcceptedTypeScalarWhereWithAggregatesInput>
    idAcceptedType?: IntWithAggregatesFilter | number
    acceptedName?: StringWithAggregatesFilter | string
  }

  export type StudentImageWhereInput = {
    AND?: Enumerable<StudentImageWhereInput>
    OR?: Enumerable<StudentImageWhereInput>
    NOT?: Enumerable<StudentImageWhereInput>
    idStudentImage?: IntFilter | number
    imagePath?: StringFilter | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    studentId?: IntFilter | number
  }

  export type StudentImageOrderByWithRelationInput = {
    idStudentImage?: SortOrder
    imagePath?: SortOrder
    student?: StudentOrderByWithRelationInput
    studentId?: SortOrder
  }

  export type StudentImageWhereUniqueInput = {
    idStudentImage?: number
  }

  export type StudentImageOrderByWithAggregationInput = {
    idStudentImage?: SortOrder
    imagePath?: SortOrder
    studentId?: SortOrder
    _count?: StudentImageCountOrderByAggregateInput
    _avg?: StudentImageAvgOrderByAggregateInput
    _max?: StudentImageMaxOrderByAggregateInput
    _min?: StudentImageMinOrderByAggregateInput
    _sum?: StudentImageSumOrderByAggregateInput
  }

  export type StudentImageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StudentImageScalarWhereWithAggregatesInput>
    OR?: Enumerable<StudentImageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StudentImageScalarWhereWithAggregatesInput>
    idStudentImage?: IntWithAggregatesFilter | number
    imagePath?: StringWithAggregatesFilter | string
    studentId?: IntWithAggregatesFilter | number
  }

  export type ProvinceWhereInput = {
    AND?: Enumerable<ProvinceWhereInput>
    OR?: Enumerable<ProvinceWhereInput>
    NOT?: Enumerable<ProvinceWhereInput>
    idProvince?: IntFilter | number
    provinceName?: StringFilter | string
    provinceNameEn?: StringFilter | string
    addresses?: AddressListRelationFilter
  }

  export type ProvinceOrderByWithRelationInput = {
    idProvince?: SortOrder
    provinceName?: SortOrder
    provinceNameEn?: SortOrder
    addresses?: AddressOrderByRelationAggregateInput
  }

  export type ProvinceWhereUniqueInput = {
    idProvince?: number
  }

  export type ProvinceOrderByWithAggregationInput = {
    idProvince?: SortOrder
    provinceName?: SortOrder
    provinceNameEn?: SortOrder
    _count?: ProvinceCountOrderByAggregateInput
    _avg?: ProvinceAvgOrderByAggregateInput
    _max?: ProvinceMaxOrderByAggregateInput
    _min?: ProvinceMinOrderByAggregateInput
    _sum?: ProvinceSumOrderByAggregateInput
  }

  export type ProvinceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProvinceScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProvinceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProvinceScalarWhereWithAggregatesInput>
    idProvince?: IntWithAggregatesFilter | number
    provinceName?: StringWithAggregatesFilter | string
    provinceNameEn?: StringWithAggregatesFilter | string
  }

  export type AddressWhereInput = {
    AND?: Enumerable<AddressWhereInput>
    OR?: Enumerable<AddressWhereInput>
    NOT?: Enumerable<AddressWhereInput>
    idAddress?: IntFilter | number
    province?: XOR<ProvinceRelationFilter, ProvinceWhereInput>
    provinceId?: IntFilter | number
    district?: StringFilter | string
    avenue?: StringFilter | string
    houseNumber?: StringFilter | string
    streetNumber?: StringFilter | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    studentId?: IntFilter | number
  }

  export type AddressOrderByWithRelationInput = {
    idAddress?: SortOrder
    province?: ProvinceOrderByWithRelationInput
    provinceId?: SortOrder
    district?: SortOrder
    avenue?: SortOrder
    houseNumber?: SortOrder
    streetNumber?: SortOrder
    student?: StudentOrderByWithRelationInput
    studentId?: SortOrder
  }

  export type AddressWhereUniqueInput = {
    idAddress?: number
  }

  export type AddressOrderByWithAggregationInput = {
    idAddress?: SortOrder
    provinceId?: SortOrder
    district?: SortOrder
    avenue?: SortOrder
    houseNumber?: SortOrder
    streetNumber?: SortOrder
    studentId?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _avg?: AddressAvgOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
    _sum?: AddressSumOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AddressScalarWhereWithAggregatesInput>
    OR?: Enumerable<AddressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AddressScalarWhereWithAggregatesInput>
    idAddress?: IntWithAggregatesFilter | number
    provinceId?: IntWithAggregatesFilter | number
    district?: StringWithAggregatesFilter | string
    avenue?: StringWithAggregatesFilter | string
    houseNumber?: StringWithAggregatesFilter | string
    streetNumber?: StringWithAggregatesFilter | string
    studentId?: IntWithAggregatesFilter | number
  }

  export type AdministrativeOrderCreateInput = {
    orderNumber: number
    orderDescription: string
    orderYear: string
    orderLevel: number
    orderDate: Date | string
    createdAt?: Date | string
    orderTitle: OrderTitleCreateNestedOneWithoutAdministrativeOrdersInput
    student: StudentCreateNestedOneWithoutAdministrativeOrdersInput
    user: UserCreateNestedOneWithoutAdministrativeOrdersInput
  }

  export type AdministrativeOrderUncheckedCreateInput = {
    idAdministrative?: number
    orderTitleId: number
    orderNumber: number
    orderDescription: string
    orderYear: string
    orderLevel: number
    studentId: number
    orderDate: Date | string
    createdBy: number
    createdAt?: Date | string
  }

  export type AdministrativeOrderUpdateInput = {
    orderNumber?: IntFieldUpdateOperationsInput | number
    orderDescription?: StringFieldUpdateOperationsInput | string
    orderYear?: StringFieldUpdateOperationsInput | string
    orderLevel?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderTitle?: OrderTitleUpdateOneRequiredWithoutAdministrativeOrdersInput
    student?: StudentUpdateOneRequiredWithoutAdministrativeOrdersInput
    user?: UserUpdateOneRequiredWithoutAdministrativeOrdersInput
  }

  export type AdministrativeOrderUncheckedUpdateInput = {
    idAdministrative?: IntFieldUpdateOperationsInput | number
    orderTitleId?: IntFieldUpdateOperationsInput | number
    orderNumber?: IntFieldUpdateOperationsInput | number
    orderDescription?: StringFieldUpdateOperationsInput | string
    orderYear?: StringFieldUpdateOperationsInput | string
    orderLevel?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdministrativeOrderCreateManyInput = {
    idAdministrative?: number
    orderTitleId: number
    orderNumber: number
    orderDescription: string
    orderYear: string
    orderLevel: number
    studentId: number
    orderDate: Date | string
    createdBy: number
    createdAt?: Date | string
  }

  export type AdministrativeOrderUpdateManyMutationInput = {
    orderNumber?: IntFieldUpdateOperationsInput | number
    orderDescription?: StringFieldUpdateOperationsInput | string
    orderYear?: StringFieldUpdateOperationsInput | string
    orderLevel?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdministrativeOrderUncheckedUpdateManyInput = {
    idAdministrative?: IntFieldUpdateOperationsInput | number
    orderTitleId?: IntFieldUpdateOperationsInput | number
    orderNumber?: IntFieldUpdateOperationsInput | number
    orderDescription?: StringFieldUpdateOperationsInput | string
    orderYear?: StringFieldUpdateOperationsInput | string
    orderLevel?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderTitleCreateInput = {
    title: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutOrderTitlesInput
    administrativeOrders?: AdministrativeOrderCreateNestedManyWithoutOrderTitleInput
  }

  export type OrderTitleUncheckedCreateInput = {
    idOrderTitle?: number
    title: string
    createdAt?: Date | string
    createdBy: number
    administrativeOrders?: AdministrativeOrderUncheckedCreateNestedManyWithoutOrderTitleInput
  }

  export type OrderTitleUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrderTitlesInput
    administrativeOrders?: AdministrativeOrderUpdateManyWithoutOrderTitleInput
  }

  export type OrderTitleUncheckedUpdateInput = {
    idOrderTitle?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    administrativeOrders?: AdministrativeOrderUncheckedUpdateManyWithoutOrderTitleInput
  }

  export type OrderTitleCreateManyInput = {
    idOrderTitle?: number
    title: string
    createdAt?: Date | string
    createdBy: number
  }

  export type OrderTitleUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderTitleUncheckedUpdateManyInput = {
    idOrderTitle?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
  }

  export type ExitCausesCreateInput = {
    exitCausesTitle: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutExitCausesInput
  }

  export type ExitCausesUncheckedCreateInput = {
    idExitCauses?: number
    exitCausesTitle: string
    createdAt?: Date | string
    createdBy: number
  }

  export type ExitCausesUpdateInput = {
    exitCausesTitle?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExitCausesInput
  }

  export type ExitCausesUncheckedUpdateInput = {
    idExitCauses?: IntFieldUpdateOperationsInput | number
    exitCausesTitle?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
  }

  export type ExitCausesCreateManyInput = {
    idExitCauses?: number
    exitCausesTitle: string
    createdAt?: Date | string
    createdBy: number
  }

  export type ExitCausesUpdateManyMutationInput = {
    exitCausesTitle?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExitCausesUncheckedUpdateManyInput = {
    idExitCauses?: IntFieldUpdateOperationsInput | number
    exitCausesTitle?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
  }

  export type PassTypeCreateInput = {
    passName: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPassTypesInput
  }

  export type PassTypeUncheckedCreateInput = {
    idPassType?: number
    passName: string
    createdAt?: Date | string
    createdBy: number
  }

  export type PassTypeUpdateInput = {
    passName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPassTypesInput
  }

  export type PassTypeUncheckedUpdateInput = {
    idPassType?: IntFieldUpdateOperationsInput | number
    passName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
  }

  export type PassTypeCreateManyInput = {
    idPassType?: number
    passName: string
    createdAt?: Date | string
    createdBy: number
  }

  export type PassTypeUpdateManyMutationInput = {
    passName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PassTypeUncheckedUpdateManyInput = {
    idPassType?: IntFieldUpdateOperationsInput | number
    passName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateInput = {
    userName: string
    password: string
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    section: SectionCreateNestedOneWithoutUserInput
    passTypes?: PassTypeCreateNestedManyWithoutUserInput
    administrativeOrders?: AdministrativeOrderCreateNestedManyWithoutUserInput
    OrderTitles?: OrderTitleCreateNestedManyWithoutUserInput
    ExitCauses?: ExitCausesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    idUser?: number
    userName: string
    password: string
    roleId: number
    sectionId: number
    createdAt?: Date | string
    passTypes?: PassTypeUncheckedCreateNestedManyWithoutUserInput
    administrativeOrders?: AdministrativeOrderUncheckedCreateNestedManyWithoutUserInput
    OrderTitles?: OrderTitleUncheckedCreateNestedManyWithoutUserInput
    ExitCauses?: ExitCausesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersInput
    section?: SectionUpdateOneRequiredWithoutUserInput
    passTypes?: PassTypeUpdateManyWithoutUserInput
    administrativeOrders?: AdministrativeOrderUpdateManyWithoutUserInput
    OrderTitles?: OrderTitleUpdateManyWithoutUserInput
    ExitCauses?: ExitCausesUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateInput = {
    idUser?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    sectionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passTypes?: PassTypeUncheckedUpdateManyWithoutUserInput
    administrativeOrders?: AdministrativeOrderUncheckedUpdateManyWithoutUserInput
    OrderTitles?: OrderTitleUncheckedUpdateManyWithoutUserInput
    ExitCauses?: ExitCausesUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateManyInput = {
    idUser?: number
    userName: string
    password: string
    roleId: number
    sectionId: number
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    idUser?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    sectionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    roleName: string
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    idRole?: number
    roleName: string
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    roleName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutRoleInput
  }

  export type RoleUncheckedUpdateInput = {
    idRole?: IntFieldUpdateOperationsInput | number
    roleName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutRoleInput
  }

  export type RoleCreateManyInput = {
    idRole?: number
    roleName: string
    createdAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    roleName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    idRole?: IntFieldUpdateOperationsInput | number
    roleName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionCreateInput = {
    sectionName: string
    code: string
    englishName: string
    students?: StudentCreateNestedManyWithoutSectionInput
    User?: UserCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateInput = {
    idSection?: number
    sectionName: string
    code: string
    englishName: string
    students?: StudentUncheckedCreateNestedManyWithoutSectionInput
    User?: UserUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionUpdateInput = {
    sectionName?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    students?: StudentUpdateManyWithoutSectionInput
    User?: UserUpdateManyWithoutSectionInput
  }

  export type SectionUncheckedUpdateInput = {
    idSection?: IntFieldUpdateOperationsInput | number
    sectionName?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    students?: StudentUncheckedUpdateManyWithoutSectionInput
    User?: UserUncheckedUpdateManyWithoutSectionInput
  }

  export type SectionCreateManyInput = {
    idSection?: number
    sectionName: string
    code: string
    englishName: string
  }

  export type SectionUpdateManyMutationInput = {
    sectionName?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
  }

  export type SectionUncheckedUpdateManyInput = {
    idSection?: IntFieldUpdateOperationsInput | number
    sectionName?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
  }

  export type StudentCreateInput = {
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    section: SectionCreateNestedOneWithoutStudentsInput
    yearStudy: YearStudyCreateNestedOneWithoutStudentInput
    studentStatus: StudentStatusCreateNestedOneWithoutStudentsInput
    acceptedType: AcceptedTypeCreateNestedOneWithoutStudentsInput
    administrativeOrders?: AdministrativeOrderCreateNestedManyWithoutStudentInput
    studentSchool?: StudentSchoolCreateNestedOneWithoutStudentInput
    studentLevel?: StudentLevelCreateNestedManyWithoutStudentInput
    studentGraduation?: StudentGraduationCreateNestedOneWithoutStudentInput
    nationalInfo?: NationalInfoCreateNestedOneWithoutStudentInput
    studentResponsables?: StudentResponsibleCreateNestedManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateCreateNestedManyWithoutStudentInput
    studentImage?: StudentImageCreateNestedManyWithoutStudentInput
    address?: AddressCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    idStudent?: number
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    sectionId: number
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    registerYearId: number
    studentStatusId: number
    acceptedTypeId: number
    administrativeOrders?: AdministrativeOrderUncheckedCreateNestedManyWithoutStudentInput
    studentSchool?: StudentSchoolUncheckedCreateNestedOneWithoutStudentInput
    studentLevel?: StudentLevelUncheckedCreateNestedManyWithoutStudentInput
    studentGraduation?: StudentGraduationUncheckedCreateNestedOneWithoutStudentInput
    nationalInfo?: NationalInfoUncheckedCreateNestedOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUncheckedCreateNestedManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUncheckedCreateNestedManyWithoutStudentInput
    studentImage?: StudentImageUncheckedCreateNestedManyWithoutStudentInput
    address?: AddressUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentUpdateInput = {
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    section?: SectionUpdateOneRequiredWithoutStudentsInput
    yearStudy?: YearStudyUpdateOneRequiredWithoutStudentInput
    studentStatus?: StudentStatusUpdateOneRequiredWithoutStudentsInput
    acceptedType?: AcceptedTypeUpdateOneRequiredWithoutStudentsInput
    administrativeOrders?: AdministrativeOrderUpdateManyWithoutStudentInput
    studentSchool?: StudentSchoolUpdateOneWithoutStudentInput
    studentLevel?: StudentLevelUpdateManyWithoutStudentInput
    studentGraduation?: StudentGraduationUpdateOneWithoutStudentInput
    nationalInfo?: NationalInfoUpdateOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUpdateManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUpdateManyWithoutStudentInput
    studentImage?: StudentImageUpdateManyWithoutStudentInput
    address?: AddressUpdateOneWithoutStudentInput
  }

  export type StudentUncheckedUpdateInput = {
    idStudent?: IntFieldUpdateOperationsInput | number
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    sectionId?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    registerYearId?: IntFieldUpdateOperationsInput | number
    studentStatusId?: IntFieldUpdateOperationsInput | number
    acceptedTypeId?: IntFieldUpdateOperationsInput | number
    administrativeOrders?: AdministrativeOrderUncheckedUpdateManyWithoutStudentInput
    studentSchool?: StudentSchoolUncheckedUpdateOneWithoutStudentInput
    studentLevel?: StudentLevelUncheckedUpdateManyWithoutStudentInput
    studentGraduation?: StudentGraduationUncheckedUpdateOneWithoutStudentInput
    nationalInfo?: NationalInfoUncheckedUpdateOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUncheckedUpdateManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUncheckedUpdateManyWithoutStudentInput
    studentImage?: StudentImageUncheckedUpdateManyWithoutStudentInput
    address?: AddressUncheckedUpdateOneWithoutStudentInput
  }

  export type StudentCreateManyInput = {
    idStudent?: number
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    sectionId: number
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    registerYearId: number
    studentStatusId: number
    acceptedTypeId: number
  }

  export type StudentUpdateManyMutationInput = {
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
  }

  export type StudentUncheckedUpdateManyInput = {
    idStudent?: IntFieldUpdateOperationsInput | number
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    sectionId?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    registerYearId?: IntFieldUpdateOperationsInput | number
    studentStatusId?: IntFieldUpdateOperationsInput | number
    acceptedTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type YearStudyCreateInput = {
    year: string
    currentYear: boolean
    StudentLevel?: StudentLevelCreateNestedManyWithoutYearStudyInput
    Student?: StudentCreateNestedManyWithoutYearStudyInput
  }

  export type YearStudyUncheckedCreateInput = {
    idYearStudy?: number
    year: string
    currentYear: boolean
    StudentLevel?: StudentLevelUncheckedCreateNestedManyWithoutYearStudyInput
    Student?: StudentUncheckedCreateNestedManyWithoutYearStudyInput
  }

  export type YearStudyUpdateInput = {
    year?: StringFieldUpdateOperationsInput | string
    currentYear?: BoolFieldUpdateOperationsInput | boolean
    StudentLevel?: StudentLevelUpdateManyWithoutYearStudyInput
    Student?: StudentUpdateManyWithoutYearStudyInput
  }

  export type YearStudyUncheckedUpdateInput = {
    idYearStudy?: IntFieldUpdateOperationsInput | number
    year?: StringFieldUpdateOperationsInput | string
    currentYear?: BoolFieldUpdateOperationsInput | boolean
    StudentLevel?: StudentLevelUncheckedUpdateManyWithoutYearStudyInput
    Student?: StudentUncheckedUpdateManyWithoutYearStudyInput
  }

  export type YearStudyCreateManyInput = {
    idYearStudy?: number
    year: string
    currentYear: boolean
  }

  export type YearStudyUpdateManyMutationInput = {
    year?: StringFieldUpdateOperationsInput | string
    currentYear?: BoolFieldUpdateOperationsInput | boolean
  }

  export type YearStudyUncheckedUpdateManyInput = {
    idYearStudy?: IntFieldUpdateOperationsInput | number
    year?: StringFieldUpdateOperationsInput | string
    currentYear?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentResponsibleCreateInput = {
    responsibleName: string
    responsiblePhone: string
    student: StudentCreateNestedOneWithoutStudentResponsablesInput
  }

  export type StudentResponsibleUncheckedCreateInput = {
    idStudentResponsible?: number
    responsibleName: string
    responsiblePhone: string
    studentId: number
  }

  export type StudentResponsibleUpdateInput = {
    responsibleName?: StringFieldUpdateOperationsInput | string
    responsiblePhone?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutStudentResponsablesInput
  }

  export type StudentResponsibleUncheckedUpdateInput = {
    idStudentResponsible?: IntFieldUpdateOperationsInput | number
    responsibleName?: StringFieldUpdateOperationsInput | string
    responsiblePhone?: StringFieldUpdateOperationsInput | string
    studentId?: IntFieldUpdateOperationsInput | number
  }

  export type StudentResponsibleCreateManyInput = {
    idStudentResponsible?: number
    responsibleName: string
    responsiblePhone: string
    studentId: number
  }

  export type StudentResponsibleUpdateManyMutationInput = {
    responsibleName?: StringFieldUpdateOperationsInput | string
    responsiblePhone?: StringFieldUpdateOperationsInput | string
  }

  export type StudentResponsibleUncheckedUpdateManyInput = {
    idStudentResponsible?: IntFieldUpdateOperationsInput | number
    responsibleName?: StringFieldUpdateOperationsInput | string
    responsiblePhone?: StringFieldUpdateOperationsInput | string
    studentId?: IntFieldUpdateOperationsInput | number
  }

  export type NationalityCertificateCreateInput = {
    nationalityNumber: string
    nationalityIssue: string
    nationalityPlace: string
    student: StudentCreateNestedOneWithoutNationalityCertificateInput
  }

  export type NationalityCertificateUncheckedCreateInput = {
    idNationalityCertificate?: number
    nationalityNumber: string
    nationalityIssue: string
    nationalityPlace: string
    studentId: number
  }

  export type NationalityCertificateUpdateInput = {
    nationalityNumber?: StringFieldUpdateOperationsInput | string
    nationalityIssue?: StringFieldUpdateOperationsInput | string
    nationalityPlace?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutNationalityCertificateInput
  }

  export type NationalityCertificateUncheckedUpdateInput = {
    idNationalityCertificate?: IntFieldUpdateOperationsInput | number
    nationalityNumber?: StringFieldUpdateOperationsInput | string
    nationalityIssue?: StringFieldUpdateOperationsInput | string
    nationalityPlace?: StringFieldUpdateOperationsInput | string
    studentId?: IntFieldUpdateOperationsInput | number
  }

  export type NationalityCertificateCreateManyInput = {
    idNationalityCertificate?: number
    nationalityNumber: string
    nationalityIssue: string
    nationalityPlace: string
    studentId: number
  }

  export type NationalityCertificateUpdateManyMutationInput = {
    nationalityNumber?: StringFieldUpdateOperationsInput | string
    nationalityIssue?: StringFieldUpdateOperationsInput | string
    nationalityPlace?: StringFieldUpdateOperationsInput | string
  }

  export type NationalityCertificateUncheckedUpdateManyInput = {
    idNationalityCertificate?: IntFieldUpdateOperationsInput | number
    nationalityNumber?: StringFieldUpdateOperationsInput | string
    nationalityIssue?: StringFieldUpdateOperationsInput | string
    nationalityPlace?: StringFieldUpdateOperationsInput | string
    studentId?: IntFieldUpdateOperationsInput | number
  }

  export type NationalInfoCreateInput = {
    nationalNumber: string
    issueNumber: string
    issuePlace: string
    student: StudentCreateNestedOneWithoutNationalInfoInput
  }

  export type NationalInfoUncheckedCreateInput = {
    idNationalInfo?: number
    nationalNumber: string
    issueNumber: string
    issuePlace: string
    studentId: number
  }

  export type NationalInfoUpdateInput = {
    nationalNumber?: StringFieldUpdateOperationsInput | string
    issueNumber?: StringFieldUpdateOperationsInput | string
    issuePlace?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutNationalInfoInput
  }

  export type NationalInfoUncheckedUpdateInput = {
    idNationalInfo?: IntFieldUpdateOperationsInput | number
    nationalNumber?: StringFieldUpdateOperationsInput | string
    issueNumber?: StringFieldUpdateOperationsInput | string
    issuePlace?: StringFieldUpdateOperationsInput | string
    studentId?: IntFieldUpdateOperationsInput | number
  }

  export type NationalInfoCreateManyInput = {
    idNationalInfo?: number
    nationalNumber: string
    issueNumber: string
    issuePlace: string
    studentId: number
  }

  export type NationalInfoUpdateManyMutationInput = {
    nationalNumber?: StringFieldUpdateOperationsInput | string
    issueNumber?: StringFieldUpdateOperationsInput | string
    issuePlace?: StringFieldUpdateOperationsInput | string
  }

  export type NationalInfoUncheckedUpdateManyInput = {
    idNationalInfo?: IntFieldUpdateOperationsInput | number
    nationalNumber?: StringFieldUpdateOperationsInput | string
    issueNumber?: StringFieldUpdateOperationsInput | string
    issuePlace?: StringFieldUpdateOperationsInput | string
    studentId?: IntFieldUpdateOperationsInput | number
  }

  export type StudentGraduationCreateInput = {
    graduationDate: string
    student: StudentCreateNestedOneWithoutStudentGraduationInput
  }

  export type StudentGraduationUncheckedCreateInput = {
    idStudentGraduation?: number
    graduationDate: string
    studentId: number
  }

  export type StudentGraduationUpdateInput = {
    graduationDate?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutStudentGraduationInput
  }

  export type StudentGraduationUncheckedUpdateInput = {
    idStudentGraduation?: IntFieldUpdateOperationsInput | number
    graduationDate?: StringFieldUpdateOperationsInput | string
    studentId?: IntFieldUpdateOperationsInput | number
  }

  export type StudentGraduationCreateManyInput = {
    idStudentGraduation?: number
    graduationDate: string
    studentId: number
  }

  export type StudentGraduationUpdateManyMutationInput = {
    graduationDate?: StringFieldUpdateOperationsInput | string
  }

  export type StudentGraduationUncheckedUpdateManyInput = {
    idStudentGraduation?: IntFieldUpdateOperationsInput | number
    graduationDate?: StringFieldUpdateOperationsInput | string
    studentId?: IntFieldUpdateOperationsInput | number
  }

  export type StudentLevelCreateInput = {
    level: number
    class: string
    yearStudy: YearStudyCreateNestedOneWithoutStudentLevelInput
    student: StudentCreateNestedOneWithoutStudentLevelInput
  }

  export type StudentLevelUncheckedCreateInput = {
    idStudentLevel?: number
    level: number
    class: string
    yearStudyId: number
    studentId: number
  }

  export type StudentLevelUpdateInput = {
    level?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    yearStudy?: YearStudyUpdateOneRequiredWithoutStudentLevelInput
    student?: StudentUpdateOneRequiredWithoutStudentLevelInput
  }

  export type StudentLevelUncheckedUpdateInput = {
    idStudentLevel?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    yearStudyId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
  }

  export type StudentLevelCreateManyInput = {
    idStudentLevel?: number
    level: number
    class: string
    yearStudyId: number
    studentId: number
  }

  export type StudentLevelUpdateManyMutationInput = {
    level?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
  }

  export type StudentLevelUncheckedUpdateManyInput = {
    idStudentLevel?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    yearStudyId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
  }

  export type StudentSchoolCreateInput = {
    schoolName: string
    graduationDate: string
    documentDate: string
    totalMarks: number
    average: number
    documentNumber: number
    lessonCount: number
    Directorate: string
    certificateStatusDescription: string
    createdAt?: Date | string
    studySubCategory: StudySubCategoryCreateNestedOneWithoutStudentSchoolInput
    student: StudentCreateNestedOneWithoutStudentSchoolInput
    certificateStatus: CertificateStatusCreateNestedOneWithoutStudentSchoolInput
  }

  export type StudentSchoolUncheckedCreateInput = {
    idStudentSchool?: number
    schoolName: string
    graduationDate: string
    documentDate: string
    totalMarks: number
    average: number
    documentNumber: number
    lessonCount: number
    Directorate: string
    studySubCategoryId: number
    studentId: number
    certificateStatusId: number
    certificateStatusDescription: string
    createdAt?: Date | string
  }

  export type StudentSchoolUpdateInput = {
    schoolName?: StringFieldUpdateOperationsInput | string
    graduationDate?: StringFieldUpdateOperationsInput | string
    documentDate?: StringFieldUpdateOperationsInput | string
    totalMarks?: IntFieldUpdateOperationsInput | number
    average?: FloatFieldUpdateOperationsInput | number
    documentNumber?: IntFieldUpdateOperationsInput | number
    lessonCount?: IntFieldUpdateOperationsInput | number
    Directorate?: StringFieldUpdateOperationsInput | string
    certificateStatusDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studySubCategory?: StudySubCategoryUpdateOneRequiredWithoutStudentSchoolInput
    student?: StudentUpdateOneRequiredWithoutStudentSchoolInput
    certificateStatus?: CertificateStatusUpdateOneRequiredWithoutStudentSchoolInput
  }

  export type StudentSchoolUncheckedUpdateInput = {
    idStudentSchool?: IntFieldUpdateOperationsInput | number
    schoolName?: StringFieldUpdateOperationsInput | string
    graduationDate?: StringFieldUpdateOperationsInput | string
    documentDate?: StringFieldUpdateOperationsInput | string
    totalMarks?: IntFieldUpdateOperationsInput | number
    average?: FloatFieldUpdateOperationsInput | number
    documentNumber?: IntFieldUpdateOperationsInput | number
    lessonCount?: IntFieldUpdateOperationsInput | number
    Directorate?: StringFieldUpdateOperationsInput | string
    studySubCategoryId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    certificateStatusId?: IntFieldUpdateOperationsInput | number
    certificateStatusDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSchoolCreateManyInput = {
    idStudentSchool?: number
    schoolName: string
    graduationDate: string
    documentDate: string
    totalMarks: number
    average: number
    documentNumber: number
    lessonCount: number
    Directorate: string
    studySubCategoryId: number
    studentId: number
    certificateStatusId: number
    certificateStatusDescription: string
    createdAt?: Date | string
  }

  export type StudentSchoolUpdateManyMutationInput = {
    schoolName?: StringFieldUpdateOperationsInput | string
    graduationDate?: StringFieldUpdateOperationsInput | string
    documentDate?: StringFieldUpdateOperationsInput | string
    totalMarks?: IntFieldUpdateOperationsInput | number
    average?: FloatFieldUpdateOperationsInput | number
    documentNumber?: IntFieldUpdateOperationsInput | number
    lessonCount?: IntFieldUpdateOperationsInput | number
    Directorate?: StringFieldUpdateOperationsInput | string
    certificateStatusDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSchoolUncheckedUpdateManyInput = {
    idStudentSchool?: IntFieldUpdateOperationsInput | number
    schoolName?: StringFieldUpdateOperationsInput | string
    graduationDate?: StringFieldUpdateOperationsInput | string
    documentDate?: StringFieldUpdateOperationsInput | string
    totalMarks?: IntFieldUpdateOperationsInput | number
    average?: FloatFieldUpdateOperationsInput | number
    documentNumber?: IntFieldUpdateOperationsInput | number
    lessonCount?: IntFieldUpdateOperationsInput | number
    Directorate?: StringFieldUpdateOperationsInput | string
    studySubCategoryId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    certificateStatusId?: IntFieldUpdateOperationsInput | number
    certificateStatusDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyCategoryCreateInput = {
    categoryName: string
    StudySubCategory?: StudySubCategoryCreateNestedManyWithoutStudyCategoryInput
  }

  export type StudyCategoryUncheckedCreateInput = {
    idStudyCategory?: number
    categoryName: string
    StudySubCategory?: StudySubCategoryUncheckedCreateNestedManyWithoutStudyCategoryInput
  }

  export type StudyCategoryUpdateInput = {
    categoryName?: StringFieldUpdateOperationsInput | string
    StudySubCategory?: StudySubCategoryUpdateManyWithoutStudyCategoryInput
  }

  export type StudyCategoryUncheckedUpdateInput = {
    idStudyCategory?: IntFieldUpdateOperationsInput | number
    categoryName?: StringFieldUpdateOperationsInput | string
    StudySubCategory?: StudySubCategoryUncheckedUpdateManyWithoutStudyCategoryInput
  }

  export type StudyCategoryCreateManyInput = {
    idStudyCategory?: number
    categoryName: string
  }

  export type StudyCategoryUpdateManyMutationInput = {
    categoryName?: StringFieldUpdateOperationsInput | string
  }

  export type StudyCategoryUncheckedUpdateManyInput = {
    idStudyCategory?: IntFieldUpdateOperationsInput | number
    categoryName?: StringFieldUpdateOperationsInput | string
  }

  export type StudySubCategoryCreateInput = {
    subCategoryName: string
    studyCategory: StudyCategoryCreateNestedOneWithoutStudySubCategoryInput
    StudentSchool?: StudentSchoolCreateNestedManyWithoutStudySubCategoryInput
  }

  export type StudySubCategoryUncheckedCreateInput = {
    idStudySubCategory?: number
    subCategoryName: string
    studyCategoryId: number
    StudentSchool?: StudentSchoolUncheckedCreateNestedManyWithoutStudySubCategoryInput
  }

  export type StudySubCategoryUpdateInput = {
    subCategoryName?: StringFieldUpdateOperationsInput | string
    studyCategory?: StudyCategoryUpdateOneRequiredWithoutStudySubCategoryInput
    StudentSchool?: StudentSchoolUpdateManyWithoutStudySubCategoryInput
  }

  export type StudySubCategoryUncheckedUpdateInput = {
    idStudySubCategory?: IntFieldUpdateOperationsInput | number
    subCategoryName?: StringFieldUpdateOperationsInput | string
    studyCategoryId?: IntFieldUpdateOperationsInput | number
    StudentSchool?: StudentSchoolUncheckedUpdateManyWithoutStudySubCategoryInput
  }

  export type StudySubCategoryCreateManyInput = {
    idStudySubCategory?: number
    subCategoryName: string
    studyCategoryId: number
  }

  export type StudySubCategoryUpdateManyMutationInput = {
    subCategoryName?: StringFieldUpdateOperationsInput | string
  }

  export type StudySubCategoryUncheckedUpdateManyInput = {
    idStudySubCategory?: IntFieldUpdateOperationsInput | number
    subCategoryName?: StringFieldUpdateOperationsInput | string
    studyCategoryId?: IntFieldUpdateOperationsInput | number
  }

  export type CertificateStatusCreateInput = {
    certificateStatusName: string
    studentSchool?: StudentSchoolCreateNestedManyWithoutCertificateStatusInput
  }

  export type CertificateStatusUncheckedCreateInput = {
    idCertificateStatus?: number
    certificateStatusName: string
    studentSchool?: StudentSchoolUncheckedCreateNestedManyWithoutCertificateStatusInput
  }

  export type CertificateStatusUpdateInput = {
    certificateStatusName?: StringFieldUpdateOperationsInput | string
    studentSchool?: StudentSchoolUpdateManyWithoutCertificateStatusInput
  }

  export type CertificateStatusUncheckedUpdateInput = {
    idCertificateStatus?: IntFieldUpdateOperationsInput | number
    certificateStatusName?: StringFieldUpdateOperationsInput | string
    studentSchool?: StudentSchoolUncheckedUpdateManyWithoutCertificateStatusInput
  }

  export type CertificateStatusCreateManyInput = {
    idCertificateStatus?: number
    certificateStatusName: string
  }

  export type CertificateStatusUpdateManyMutationInput = {
    certificateStatusName?: StringFieldUpdateOperationsInput | string
  }

  export type CertificateStatusUncheckedUpdateManyInput = {
    idCertificateStatus?: IntFieldUpdateOperationsInput | number
    certificateStatusName?: StringFieldUpdateOperationsInput | string
  }

  export type StudentStatusCreateInput = {
    statusName: string
    students?: StudentCreateNestedManyWithoutStudentStatusInput
  }

  export type StudentStatusUncheckedCreateInput = {
    idStudentStatus?: number
    statusName: string
    students?: StudentUncheckedCreateNestedManyWithoutStudentStatusInput
  }

  export type StudentStatusUpdateInput = {
    statusName?: StringFieldUpdateOperationsInput | string
    students?: StudentUpdateManyWithoutStudentStatusInput
  }

  export type StudentStatusUncheckedUpdateInput = {
    idStudentStatus?: IntFieldUpdateOperationsInput | number
    statusName?: StringFieldUpdateOperationsInput | string
    students?: StudentUncheckedUpdateManyWithoutStudentStatusInput
  }

  export type StudentStatusCreateManyInput = {
    idStudentStatus?: number
    statusName: string
  }

  export type StudentStatusUpdateManyMutationInput = {
    statusName?: StringFieldUpdateOperationsInput | string
  }

  export type StudentStatusUncheckedUpdateManyInput = {
    idStudentStatus?: IntFieldUpdateOperationsInput | number
    statusName?: StringFieldUpdateOperationsInput | string
  }

  export type AcceptedTypeCreateInput = {
    acceptedName: string
    students?: StudentCreateNestedManyWithoutAcceptedTypeInput
  }

  export type AcceptedTypeUncheckedCreateInput = {
    idAcceptedType?: number
    acceptedName: string
    students?: StudentUncheckedCreateNestedManyWithoutAcceptedTypeInput
  }

  export type AcceptedTypeUpdateInput = {
    acceptedName?: StringFieldUpdateOperationsInput | string
    students?: StudentUpdateManyWithoutAcceptedTypeInput
  }

  export type AcceptedTypeUncheckedUpdateInput = {
    idAcceptedType?: IntFieldUpdateOperationsInput | number
    acceptedName?: StringFieldUpdateOperationsInput | string
    students?: StudentUncheckedUpdateManyWithoutAcceptedTypeInput
  }

  export type AcceptedTypeCreateManyInput = {
    idAcceptedType?: number
    acceptedName: string
  }

  export type AcceptedTypeUpdateManyMutationInput = {
    acceptedName?: StringFieldUpdateOperationsInput | string
  }

  export type AcceptedTypeUncheckedUpdateManyInput = {
    idAcceptedType?: IntFieldUpdateOperationsInput | number
    acceptedName?: StringFieldUpdateOperationsInput | string
  }

  export type StudentImageCreateInput = {
    imagePath: string
    student: StudentCreateNestedOneWithoutStudentImageInput
  }

  export type StudentImageUncheckedCreateInput = {
    idStudentImage?: number
    imagePath: string
    studentId: number
  }

  export type StudentImageUpdateInput = {
    imagePath?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutStudentImageInput
  }

  export type StudentImageUncheckedUpdateInput = {
    idStudentImage?: IntFieldUpdateOperationsInput | number
    imagePath?: StringFieldUpdateOperationsInput | string
    studentId?: IntFieldUpdateOperationsInput | number
  }

  export type StudentImageCreateManyInput = {
    idStudentImage?: number
    imagePath: string
    studentId: number
  }

  export type StudentImageUpdateManyMutationInput = {
    imagePath?: StringFieldUpdateOperationsInput | string
  }

  export type StudentImageUncheckedUpdateManyInput = {
    idStudentImage?: IntFieldUpdateOperationsInput | number
    imagePath?: StringFieldUpdateOperationsInput | string
    studentId?: IntFieldUpdateOperationsInput | number
  }

  export type ProvinceCreateInput = {
    provinceName: string
    provinceNameEn: string
    addresses?: AddressCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceUncheckedCreateInput = {
    idProvince?: number
    provinceName: string
    provinceNameEn: string
    addresses?: AddressUncheckedCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceUpdateInput = {
    provinceName?: StringFieldUpdateOperationsInput | string
    provinceNameEn?: StringFieldUpdateOperationsInput | string
    addresses?: AddressUpdateManyWithoutProvinceInput
  }

  export type ProvinceUncheckedUpdateInput = {
    idProvince?: IntFieldUpdateOperationsInput | number
    provinceName?: StringFieldUpdateOperationsInput | string
    provinceNameEn?: StringFieldUpdateOperationsInput | string
    addresses?: AddressUncheckedUpdateManyWithoutProvinceInput
  }

  export type ProvinceCreateManyInput = {
    idProvince?: number
    provinceName: string
    provinceNameEn: string
  }

  export type ProvinceUpdateManyMutationInput = {
    provinceName?: StringFieldUpdateOperationsInput | string
    provinceNameEn?: StringFieldUpdateOperationsInput | string
  }

  export type ProvinceUncheckedUpdateManyInput = {
    idProvince?: IntFieldUpdateOperationsInput | number
    provinceName?: StringFieldUpdateOperationsInput | string
    provinceNameEn?: StringFieldUpdateOperationsInput | string
  }

  export type AddressCreateInput = {
    district: string
    avenue: string
    houseNumber: string
    streetNumber: string
    province: ProvinceCreateNestedOneWithoutAddressesInput
    student: StudentCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateInput = {
    idAddress?: number
    provinceId: number
    district: string
    avenue: string
    houseNumber: string
    streetNumber: string
    studentId: number
  }

  export type AddressUpdateInput = {
    district?: StringFieldUpdateOperationsInput | string
    avenue?: StringFieldUpdateOperationsInput | string
    houseNumber?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    province?: ProvinceUpdateOneRequiredWithoutAddressesInput
    student?: StudentUpdateOneRequiredWithoutAddressInput
  }

  export type AddressUncheckedUpdateInput = {
    idAddress?: IntFieldUpdateOperationsInput | number
    provinceId?: IntFieldUpdateOperationsInput | number
    district?: StringFieldUpdateOperationsInput | string
    avenue?: StringFieldUpdateOperationsInput | string
    houseNumber?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    studentId?: IntFieldUpdateOperationsInput | number
  }

  export type AddressCreateManyInput = {
    idAddress?: number
    provinceId: number
    district: string
    avenue: string
    houseNumber: string
    streetNumber: string
    studentId: number
  }

  export type AddressUpdateManyMutationInput = {
    district?: StringFieldUpdateOperationsInput | string
    avenue?: StringFieldUpdateOperationsInput | string
    houseNumber?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUncheckedUpdateManyInput = {
    idAddress?: IntFieldUpdateOperationsInput | number
    provinceId?: IntFieldUpdateOperationsInput | number
    district?: StringFieldUpdateOperationsInput | string
    avenue?: StringFieldUpdateOperationsInput | string
    houseNumber?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    studentId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type OrderTitleRelationFilter = {
    is?: OrderTitleWhereInput
    isNot?: OrderTitleWhereInput
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type StudentRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AdministrativeOrderCountOrderByAggregateInput = {
    idAdministrative?: SortOrder
    orderTitleId?: SortOrder
    orderNumber?: SortOrder
    orderDescription?: SortOrder
    orderYear?: SortOrder
    orderLevel?: SortOrder
    studentId?: SortOrder
    orderDate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type AdministrativeOrderAvgOrderByAggregateInput = {
    idAdministrative?: SortOrder
    orderTitleId?: SortOrder
    orderNumber?: SortOrder
    orderLevel?: SortOrder
    studentId?: SortOrder
    createdBy?: SortOrder
  }

  export type AdministrativeOrderMaxOrderByAggregateInput = {
    idAdministrative?: SortOrder
    orderTitleId?: SortOrder
    orderNumber?: SortOrder
    orderDescription?: SortOrder
    orderYear?: SortOrder
    orderLevel?: SortOrder
    studentId?: SortOrder
    orderDate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type AdministrativeOrderMinOrderByAggregateInput = {
    idAdministrative?: SortOrder
    orderTitleId?: SortOrder
    orderNumber?: SortOrder
    orderDescription?: SortOrder
    orderYear?: SortOrder
    orderLevel?: SortOrder
    studentId?: SortOrder
    orderDate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type AdministrativeOrderSumOrderByAggregateInput = {
    idAdministrative?: SortOrder
    orderTitleId?: SortOrder
    orderNumber?: SortOrder
    orderLevel?: SortOrder
    studentId?: SortOrder
    createdBy?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type AdministrativeOrderListRelationFilter = {
    every?: AdministrativeOrderWhereInput
    some?: AdministrativeOrderWhereInput
    none?: AdministrativeOrderWhereInput
  }

  export type AdministrativeOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderTitleCountOrderByAggregateInput = {
    idOrderTitle?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type OrderTitleAvgOrderByAggregateInput = {
    idOrderTitle?: SortOrder
    createdBy?: SortOrder
  }

  export type OrderTitleMaxOrderByAggregateInput = {
    idOrderTitle?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type OrderTitleMinOrderByAggregateInput = {
    idOrderTitle?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type OrderTitleSumOrderByAggregateInput = {
    idOrderTitle?: SortOrder
    createdBy?: SortOrder
  }

  export type ExitCausesCountOrderByAggregateInput = {
    idExitCauses?: SortOrder
    exitCausesTitle?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type ExitCausesAvgOrderByAggregateInput = {
    idExitCauses?: SortOrder
    createdBy?: SortOrder
  }

  export type ExitCausesMaxOrderByAggregateInput = {
    idExitCauses?: SortOrder
    exitCausesTitle?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type ExitCausesMinOrderByAggregateInput = {
    idExitCauses?: SortOrder
    exitCausesTitle?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type ExitCausesSumOrderByAggregateInput = {
    idExitCauses?: SortOrder
    createdBy?: SortOrder
  }

  export type PassTypeCountOrderByAggregateInput = {
    idPassType?: SortOrder
    passName?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type PassTypeAvgOrderByAggregateInput = {
    idPassType?: SortOrder
    createdBy?: SortOrder
  }

  export type PassTypeMaxOrderByAggregateInput = {
    idPassType?: SortOrder
    passName?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type PassTypeMinOrderByAggregateInput = {
    idPassType?: SortOrder
    passName?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type PassTypeSumOrderByAggregateInput = {
    idPassType?: SortOrder
    createdBy?: SortOrder
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type SectionRelationFilter = {
    is?: SectionWhereInput
    isNot?: SectionWhereInput
  }

  export type PassTypeListRelationFilter = {
    every?: PassTypeWhereInput
    some?: PassTypeWhereInput
    none?: PassTypeWhereInput
  }

  export type OrderTitleListRelationFilter = {
    every?: OrderTitleWhereInput
    some?: OrderTitleWhereInput
    none?: OrderTitleWhereInput
  }

  export type ExitCausesListRelationFilter = {
    every?: ExitCausesWhereInput
    some?: ExitCausesWhereInput
    none?: ExitCausesWhereInput
  }

  export type PassTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderTitleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExitCausesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    idUser?: SortOrder
    userName?: SortOrder
    password?: SortOrder
    roleId?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    idUser?: SortOrder
    roleId?: SortOrder
    sectionId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    idUser?: SortOrder
    userName?: SortOrder
    password?: SortOrder
    roleId?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    idUser?: SortOrder
    userName?: SortOrder
    password?: SortOrder
    roleId?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    idUser?: SortOrder
    roleId?: SortOrder
    sectionId?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    idRole?: SortOrder
    roleName?: SortOrder
    createdAt?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    idRole?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    idRole?: SortOrder
    roleName?: SortOrder
    createdAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    idRole?: SortOrder
    roleName?: SortOrder
    createdAt?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    idRole?: SortOrder
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SectionCountOrderByAggregateInput = {
    idSection?: SortOrder
    sectionName?: SortOrder
    code?: SortOrder
    englishName?: SortOrder
  }

  export type SectionAvgOrderByAggregateInput = {
    idSection?: SortOrder
  }

  export type SectionMaxOrderByAggregateInput = {
    idSection?: SortOrder
    sectionName?: SortOrder
    code?: SortOrder
    englishName?: SortOrder
  }

  export type SectionMinOrderByAggregateInput = {
    idSection?: SortOrder
    sectionName?: SortOrder
    code?: SortOrder
    englishName?: SortOrder
  }

  export type SectionSumOrderByAggregateInput = {
    idSection?: SortOrder
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type YearStudyRelationFilter = {
    is?: YearStudyWhereInput
    isNot?: YearStudyWhereInput
  }

  export type StudentStatusRelationFilter = {
    is?: StudentStatusWhereInput
    isNot?: StudentStatusWhereInput
  }

  export type AcceptedTypeRelationFilter = {
    is?: AcceptedTypeWhereInput
    isNot?: AcceptedTypeWhereInput
  }

  export type StudentSchoolRelationFilter = {
    is?: StudentSchoolWhereInput | null
    isNot?: StudentSchoolWhereInput | null
  }

  export type StudentLevelListRelationFilter = {
    every?: StudentLevelWhereInput
    some?: StudentLevelWhereInput
    none?: StudentLevelWhereInput
  }

  export type StudentGraduationRelationFilter = {
    is?: StudentGraduationWhereInput | null
    isNot?: StudentGraduationWhereInput | null
  }

  export type NationalInfoRelationFilter = {
    is?: NationalInfoWhereInput | null
    isNot?: NationalInfoWhereInput | null
  }

  export type StudentResponsibleListRelationFilter = {
    every?: StudentResponsibleWhereInput
    some?: StudentResponsibleWhereInput
    none?: StudentResponsibleWhereInput
  }

  export type NationalityCertificateListRelationFilter = {
    every?: NationalityCertificateWhereInput
    some?: NationalityCertificateWhereInput
    none?: NationalityCertificateWhereInput
  }

  export type StudentImageListRelationFilter = {
    every?: StudentImageWhereInput
    some?: StudentImageWhereInput
    none?: StudentImageWhereInput
  }

  export type AddressRelationFilter = {
    is?: AddressWhereInput | null
    isNot?: AddressWhereInput | null
  }

  export type StudentLevelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentResponsibleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NationalityCertificateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentCountOrderByAggregateInput = {
    idStudent?: SortOrder
    studentName?: SortOrder
    englishName?: SortOrder
    mail?: SortOrder
    password?: SortOrder
    dob?: SortOrder
    sectionId?: SortOrder
    nationality?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    studyType?: SortOrder
    relationships?: SortOrder
    note?: SortOrder
    religion?: SortOrder
    motherName?: SortOrder
    collegeNumber?: SortOrder
    registerYearId?: SortOrder
    studentStatusId?: SortOrder
    acceptedTypeId?: SortOrder
  }

  export type StudentAvgOrderByAggregateInput = {
    idStudent?: SortOrder
    sectionId?: SortOrder
    registerYearId?: SortOrder
    studentStatusId?: SortOrder
    acceptedTypeId?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    idStudent?: SortOrder
    studentName?: SortOrder
    englishName?: SortOrder
    mail?: SortOrder
    password?: SortOrder
    dob?: SortOrder
    sectionId?: SortOrder
    nationality?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    studyType?: SortOrder
    relationships?: SortOrder
    note?: SortOrder
    religion?: SortOrder
    motherName?: SortOrder
    collegeNumber?: SortOrder
    registerYearId?: SortOrder
    studentStatusId?: SortOrder
    acceptedTypeId?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    idStudent?: SortOrder
    studentName?: SortOrder
    englishName?: SortOrder
    mail?: SortOrder
    password?: SortOrder
    dob?: SortOrder
    sectionId?: SortOrder
    nationality?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    studyType?: SortOrder
    relationships?: SortOrder
    note?: SortOrder
    religion?: SortOrder
    motherName?: SortOrder
    collegeNumber?: SortOrder
    registerYearId?: SortOrder
    studentStatusId?: SortOrder
    acceptedTypeId?: SortOrder
  }

  export type StudentSumOrderByAggregateInput = {
    idStudent?: SortOrder
    sectionId?: SortOrder
    registerYearId?: SortOrder
    studentStatusId?: SortOrder
    acceptedTypeId?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type YearStudyCountOrderByAggregateInput = {
    idYearStudy?: SortOrder
    year?: SortOrder
    currentYear?: SortOrder
  }

  export type YearStudyAvgOrderByAggregateInput = {
    idYearStudy?: SortOrder
  }

  export type YearStudyMaxOrderByAggregateInput = {
    idYearStudy?: SortOrder
    year?: SortOrder
    currentYear?: SortOrder
  }

  export type YearStudyMinOrderByAggregateInput = {
    idYearStudy?: SortOrder
    year?: SortOrder
    currentYear?: SortOrder
  }

  export type YearStudySumOrderByAggregateInput = {
    idYearStudy?: SortOrder
  }

  export type StudentResponsibleCountOrderByAggregateInput = {
    idStudentResponsible?: SortOrder
    responsibleName?: SortOrder
    responsiblePhone?: SortOrder
    studentId?: SortOrder
  }

  export type StudentResponsibleAvgOrderByAggregateInput = {
    idStudentResponsible?: SortOrder
    studentId?: SortOrder
  }

  export type StudentResponsibleMaxOrderByAggregateInput = {
    idStudentResponsible?: SortOrder
    responsibleName?: SortOrder
    responsiblePhone?: SortOrder
    studentId?: SortOrder
  }

  export type StudentResponsibleMinOrderByAggregateInput = {
    idStudentResponsible?: SortOrder
    responsibleName?: SortOrder
    responsiblePhone?: SortOrder
    studentId?: SortOrder
  }

  export type StudentResponsibleSumOrderByAggregateInput = {
    idStudentResponsible?: SortOrder
    studentId?: SortOrder
  }

  export type NationalityCertificateCountOrderByAggregateInput = {
    idNationalityCertificate?: SortOrder
    nationalityNumber?: SortOrder
    nationalityIssue?: SortOrder
    nationalityPlace?: SortOrder
    studentId?: SortOrder
  }

  export type NationalityCertificateAvgOrderByAggregateInput = {
    idNationalityCertificate?: SortOrder
    studentId?: SortOrder
  }

  export type NationalityCertificateMaxOrderByAggregateInput = {
    idNationalityCertificate?: SortOrder
    nationalityNumber?: SortOrder
    nationalityIssue?: SortOrder
    nationalityPlace?: SortOrder
    studentId?: SortOrder
  }

  export type NationalityCertificateMinOrderByAggregateInput = {
    idNationalityCertificate?: SortOrder
    nationalityNumber?: SortOrder
    nationalityIssue?: SortOrder
    nationalityPlace?: SortOrder
    studentId?: SortOrder
  }

  export type NationalityCertificateSumOrderByAggregateInput = {
    idNationalityCertificate?: SortOrder
    studentId?: SortOrder
  }

  export type NationalInfoCountOrderByAggregateInput = {
    idNationalInfo?: SortOrder
    nationalNumber?: SortOrder
    issueNumber?: SortOrder
    issuePlace?: SortOrder
    studentId?: SortOrder
  }

  export type NationalInfoAvgOrderByAggregateInput = {
    idNationalInfo?: SortOrder
    studentId?: SortOrder
  }

  export type NationalInfoMaxOrderByAggregateInput = {
    idNationalInfo?: SortOrder
    nationalNumber?: SortOrder
    issueNumber?: SortOrder
    issuePlace?: SortOrder
    studentId?: SortOrder
  }

  export type NationalInfoMinOrderByAggregateInput = {
    idNationalInfo?: SortOrder
    nationalNumber?: SortOrder
    issueNumber?: SortOrder
    issuePlace?: SortOrder
    studentId?: SortOrder
  }

  export type NationalInfoSumOrderByAggregateInput = {
    idNationalInfo?: SortOrder
    studentId?: SortOrder
  }

  export type StudentGraduationCountOrderByAggregateInput = {
    idStudentGraduation?: SortOrder
    graduationDate?: SortOrder
    studentId?: SortOrder
  }

  export type StudentGraduationAvgOrderByAggregateInput = {
    idStudentGraduation?: SortOrder
    studentId?: SortOrder
  }

  export type StudentGraduationMaxOrderByAggregateInput = {
    idStudentGraduation?: SortOrder
    graduationDate?: SortOrder
    studentId?: SortOrder
  }

  export type StudentGraduationMinOrderByAggregateInput = {
    idStudentGraduation?: SortOrder
    graduationDate?: SortOrder
    studentId?: SortOrder
  }

  export type StudentGraduationSumOrderByAggregateInput = {
    idStudentGraduation?: SortOrder
    studentId?: SortOrder
  }

  export type StudentLevelCountOrderByAggregateInput = {
    idStudentLevel?: SortOrder
    level?: SortOrder
    class?: SortOrder
    yearStudyId?: SortOrder
    studentId?: SortOrder
  }

  export type StudentLevelAvgOrderByAggregateInput = {
    idStudentLevel?: SortOrder
    level?: SortOrder
    yearStudyId?: SortOrder
    studentId?: SortOrder
  }

  export type StudentLevelMaxOrderByAggregateInput = {
    idStudentLevel?: SortOrder
    level?: SortOrder
    class?: SortOrder
    yearStudyId?: SortOrder
    studentId?: SortOrder
  }

  export type StudentLevelMinOrderByAggregateInput = {
    idStudentLevel?: SortOrder
    level?: SortOrder
    class?: SortOrder
    yearStudyId?: SortOrder
    studentId?: SortOrder
  }

  export type StudentLevelSumOrderByAggregateInput = {
    idStudentLevel?: SortOrder
    level?: SortOrder
    yearStudyId?: SortOrder
    studentId?: SortOrder
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type StudySubCategoryRelationFilter = {
    is?: StudySubCategoryWhereInput
    isNot?: StudySubCategoryWhereInput
  }

  export type CertificateStatusRelationFilter = {
    is?: CertificateStatusWhereInput
    isNot?: CertificateStatusWhereInput
  }

  export type StudentSchoolCountOrderByAggregateInput = {
    idStudentSchool?: SortOrder
    schoolName?: SortOrder
    graduationDate?: SortOrder
    documentDate?: SortOrder
    totalMarks?: SortOrder
    average?: SortOrder
    documentNumber?: SortOrder
    lessonCount?: SortOrder
    Directorate?: SortOrder
    studySubCategoryId?: SortOrder
    studentId?: SortOrder
    certificateStatusId?: SortOrder
    certificateStatusDescription?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentSchoolAvgOrderByAggregateInput = {
    idStudentSchool?: SortOrder
    totalMarks?: SortOrder
    average?: SortOrder
    documentNumber?: SortOrder
    lessonCount?: SortOrder
    studySubCategoryId?: SortOrder
    studentId?: SortOrder
    certificateStatusId?: SortOrder
  }

  export type StudentSchoolMaxOrderByAggregateInput = {
    idStudentSchool?: SortOrder
    schoolName?: SortOrder
    graduationDate?: SortOrder
    documentDate?: SortOrder
    totalMarks?: SortOrder
    average?: SortOrder
    documentNumber?: SortOrder
    lessonCount?: SortOrder
    Directorate?: SortOrder
    studySubCategoryId?: SortOrder
    studentId?: SortOrder
    certificateStatusId?: SortOrder
    certificateStatusDescription?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentSchoolMinOrderByAggregateInput = {
    idStudentSchool?: SortOrder
    schoolName?: SortOrder
    graduationDate?: SortOrder
    documentDate?: SortOrder
    totalMarks?: SortOrder
    average?: SortOrder
    documentNumber?: SortOrder
    lessonCount?: SortOrder
    Directorate?: SortOrder
    studySubCategoryId?: SortOrder
    studentId?: SortOrder
    certificateStatusId?: SortOrder
    certificateStatusDescription?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentSchoolSumOrderByAggregateInput = {
    idStudentSchool?: SortOrder
    totalMarks?: SortOrder
    average?: SortOrder
    documentNumber?: SortOrder
    lessonCount?: SortOrder
    studySubCategoryId?: SortOrder
    studentId?: SortOrder
    certificateStatusId?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type StudySubCategoryListRelationFilter = {
    every?: StudySubCategoryWhereInput
    some?: StudySubCategoryWhereInput
    none?: StudySubCategoryWhereInput
  }

  export type StudySubCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudyCategoryCountOrderByAggregateInput = {
    idStudyCategory?: SortOrder
    categoryName?: SortOrder
  }

  export type StudyCategoryAvgOrderByAggregateInput = {
    idStudyCategory?: SortOrder
  }

  export type StudyCategoryMaxOrderByAggregateInput = {
    idStudyCategory?: SortOrder
    categoryName?: SortOrder
  }

  export type StudyCategoryMinOrderByAggregateInput = {
    idStudyCategory?: SortOrder
    categoryName?: SortOrder
  }

  export type StudyCategorySumOrderByAggregateInput = {
    idStudyCategory?: SortOrder
  }

  export type StudyCategoryRelationFilter = {
    is?: StudyCategoryWhereInput
    isNot?: StudyCategoryWhereInput
  }

  export type StudentSchoolListRelationFilter = {
    every?: StudentSchoolWhereInput
    some?: StudentSchoolWhereInput
    none?: StudentSchoolWhereInput
  }

  export type StudentSchoolOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudySubCategoryCountOrderByAggregateInput = {
    idStudySubCategory?: SortOrder
    subCategoryName?: SortOrder
    studyCategoryId?: SortOrder
  }

  export type StudySubCategoryAvgOrderByAggregateInput = {
    idStudySubCategory?: SortOrder
    studyCategoryId?: SortOrder
  }

  export type StudySubCategoryMaxOrderByAggregateInput = {
    idStudySubCategory?: SortOrder
    subCategoryName?: SortOrder
    studyCategoryId?: SortOrder
  }

  export type StudySubCategoryMinOrderByAggregateInput = {
    idStudySubCategory?: SortOrder
    subCategoryName?: SortOrder
    studyCategoryId?: SortOrder
  }

  export type StudySubCategorySumOrderByAggregateInput = {
    idStudySubCategory?: SortOrder
    studyCategoryId?: SortOrder
  }

  export type CertificateStatusCountOrderByAggregateInput = {
    idCertificateStatus?: SortOrder
    certificateStatusName?: SortOrder
  }

  export type CertificateStatusAvgOrderByAggregateInput = {
    idCertificateStatus?: SortOrder
  }

  export type CertificateStatusMaxOrderByAggregateInput = {
    idCertificateStatus?: SortOrder
    certificateStatusName?: SortOrder
  }

  export type CertificateStatusMinOrderByAggregateInput = {
    idCertificateStatus?: SortOrder
    certificateStatusName?: SortOrder
  }

  export type CertificateStatusSumOrderByAggregateInput = {
    idCertificateStatus?: SortOrder
  }

  export type StudentStatusCountOrderByAggregateInput = {
    idStudentStatus?: SortOrder
    statusName?: SortOrder
  }

  export type StudentStatusAvgOrderByAggregateInput = {
    idStudentStatus?: SortOrder
  }

  export type StudentStatusMaxOrderByAggregateInput = {
    idStudentStatus?: SortOrder
    statusName?: SortOrder
  }

  export type StudentStatusMinOrderByAggregateInput = {
    idStudentStatus?: SortOrder
    statusName?: SortOrder
  }

  export type StudentStatusSumOrderByAggregateInput = {
    idStudentStatus?: SortOrder
  }

  export type AcceptedTypeCountOrderByAggregateInput = {
    idAcceptedType?: SortOrder
    acceptedName?: SortOrder
  }

  export type AcceptedTypeAvgOrderByAggregateInput = {
    idAcceptedType?: SortOrder
  }

  export type AcceptedTypeMaxOrderByAggregateInput = {
    idAcceptedType?: SortOrder
    acceptedName?: SortOrder
  }

  export type AcceptedTypeMinOrderByAggregateInput = {
    idAcceptedType?: SortOrder
    acceptedName?: SortOrder
  }

  export type AcceptedTypeSumOrderByAggregateInput = {
    idAcceptedType?: SortOrder
  }

  export type StudentImageCountOrderByAggregateInput = {
    idStudentImage?: SortOrder
    imagePath?: SortOrder
    studentId?: SortOrder
  }

  export type StudentImageAvgOrderByAggregateInput = {
    idStudentImage?: SortOrder
    studentId?: SortOrder
  }

  export type StudentImageMaxOrderByAggregateInput = {
    idStudentImage?: SortOrder
    imagePath?: SortOrder
    studentId?: SortOrder
  }

  export type StudentImageMinOrderByAggregateInput = {
    idStudentImage?: SortOrder
    imagePath?: SortOrder
    studentId?: SortOrder
  }

  export type StudentImageSumOrderByAggregateInput = {
    idStudentImage?: SortOrder
    studentId?: SortOrder
  }

  export type AddressListRelationFilter = {
    every?: AddressWhereInput
    some?: AddressWhereInput
    none?: AddressWhereInput
  }

  export type AddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProvinceCountOrderByAggregateInput = {
    idProvince?: SortOrder
    provinceName?: SortOrder
    provinceNameEn?: SortOrder
  }

  export type ProvinceAvgOrderByAggregateInput = {
    idProvince?: SortOrder
  }

  export type ProvinceMaxOrderByAggregateInput = {
    idProvince?: SortOrder
    provinceName?: SortOrder
    provinceNameEn?: SortOrder
  }

  export type ProvinceMinOrderByAggregateInput = {
    idProvince?: SortOrder
    provinceName?: SortOrder
    provinceNameEn?: SortOrder
  }

  export type ProvinceSumOrderByAggregateInput = {
    idProvince?: SortOrder
  }

  export type ProvinceRelationFilter = {
    is?: ProvinceWhereInput
    isNot?: ProvinceWhereInput
  }

  export type AddressCountOrderByAggregateInput = {
    idAddress?: SortOrder
    provinceId?: SortOrder
    district?: SortOrder
    avenue?: SortOrder
    houseNumber?: SortOrder
    streetNumber?: SortOrder
    studentId?: SortOrder
  }

  export type AddressAvgOrderByAggregateInput = {
    idAddress?: SortOrder
    provinceId?: SortOrder
    studentId?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    idAddress?: SortOrder
    provinceId?: SortOrder
    district?: SortOrder
    avenue?: SortOrder
    houseNumber?: SortOrder
    streetNumber?: SortOrder
    studentId?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    idAddress?: SortOrder
    provinceId?: SortOrder
    district?: SortOrder
    avenue?: SortOrder
    houseNumber?: SortOrder
    streetNumber?: SortOrder
    studentId?: SortOrder
  }

  export type AddressSumOrderByAggregateInput = {
    idAddress?: SortOrder
    provinceId?: SortOrder
    studentId?: SortOrder
  }

  export type OrderTitleCreateNestedOneWithoutAdministrativeOrdersInput = {
    create?: XOR<OrderTitleCreateWithoutAdministrativeOrdersInput, OrderTitleUncheckedCreateWithoutAdministrativeOrdersInput>
    connectOrCreate?: OrderTitleCreateOrConnectWithoutAdministrativeOrdersInput
    connect?: OrderTitleWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutAdministrativeOrdersInput = {
    create?: XOR<StudentCreateWithoutAdministrativeOrdersInput, StudentUncheckedCreateWithoutAdministrativeOrdersInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAdministrativeOrdersInput
    connect?: StudentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAdministrativeOrdersInput = {
    create?: XOR<UserCreateWithoutAdministrativeOrdersInput, UserUncheckedCreateWithoutAdministrativeOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdministrativeOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type OrderTitleUpdateOneRequiredWithoutAdministrativeOrdersInput = {
    create?: XOR<OrderTitleCreateWithoutAdministrativeOrdersInput, OrderTitleUncheckedCreateWithoutAdministrativeOrdersInput>
    connectOrCreate?: OrderTitleCreateOrConnectWithoutAdministrativeOrdersInput
    upsert?: OrderTitleUpsertWithoutAdministrativeOrdersInput
    connect?: OrderTitleWhereUniqueInput
    update?: XOR<OrderTitleUpdateWithoutAdministrativeOrdersInput, OrderTitleUncheckedUpdateWithoutAdministrativeOrdersInput>
  }

  export type StudentUpdateOneRequiredWithoutAdministrativeOrdersInput = {
    create?: XOR<StudentCreateWithoutAdministrativeOrdersInput, StudentUncheckedCreateWithoutAdministrativeOrdersInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAdministrativeOrdersInput
    upsert?: StudentUpsertWithoutAdministrativeOrdersInput
    connect?: StudentWhereUniqueInput
    update?: XOR<StudentUpdateWithoutAdministrativeOrdersInput, StudentUncheckedUpdateWithoutAdministrativeOrdersInput>
  }

  export type UserUpdateOneRequiredWithoutAdministrativeOrdersInput = {
    create?: XOR<UserCreateWithoutAdministrativeOrdersInput, UserUncheckedCreateWithoutAdministrativeOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdministrativeOrdersInput
    upsert?: UserUpsertWithoutAdministrativeOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAdministrativeOrdersInput, UserUncheckedUpdateWithoutAdministrativeOrdersInput>
  }

  export type UserCreateNestedOneWithoutOrderTitlesInput = {
    create?: XOR<UserCreateWithoutOrderTitlesInput, UserUncheckedCreateWithoutOrderTitlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrderTitlesInput
    connect?: UserWhereUniqueInput
  }

  export type AdministrativeOrderCreateNestedManyWithoutOrderTitleInput = {
    create?: XOR<Enumerable<AdministrativeOrderCreateWithoutOrderTitleInput>, Enumerable<AdministrativeOrderUncheckedCreateWithoutOrderTitleInput>>
    connectOrCreate?: Enumerable<AdministrativeOrderCreateOrConnectWithoutOrderTitleInput>
    createMany?: AdministrativeOrderCreateManyOrderTitleInputEnvelope
    connect?: Enumerable<AdministrativeOrderWhereUniqueInput>
  }

  export type AdministrativeOrderUncheckedCreateNestedManyWithoutOrderTitleInput = {
    create?: XOR<Enumerable<AdministrativeOrderCreateWithoutOrderTitleInput>, Enumerable<AdministrativeOrderUncheckedCreateWithoutOrderTitleInput>>
    connectOrCreate?: Enumerable<AdministrativeOrderCreateOrConnectWithoutOrderTitleInput>
    createMany?: AdministrativeOrderCreateManyOrderTitleInputEnvelope
    connect?: Enumerable<AdministrativeOrderWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutOrderTitlesInput = {
    create?: XOR<UserCreateWithoutOrderTitlesInput, UserUncheckedCreateWithoutOrderTitlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrderTitlesInput
    upsert?: UserUpsertWithoutOrderTitlesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutOrderTitlesInput, UserUncheckedUpdateWithoutOrderTitlesInput>
  }

  export type AdministrativeOrderUpdateManyWithoutOrderTitleInput = {
    create?: XOR<Enumerable<AdministrativeOrderCreateWithoutOrderTitleInput>, Enumerable<AdministrativeOrderUncheckedCreateWithoutOrderTitleInput>>
    connectOrCreate?: Enumerable<AdministrativeOrderCreateOrConnectWithoutOrderTitleInput>
    upsert?: Enumerable<AdministrativeOrderUpsertWithWhereUniqueWithoutOrderTitleInput>
    createMany?: AdministrativeOrderCreateManyOrderTitleInputEnvelope
    connect?: Enumerable<AdministrativeOrderWhereUniqueInput>
    set?: Enumerable<AdministrativeOrderWhereUniqueInput>
    disconnect?: Enumerable<AdministrativeOrderWhereUniqueInput>
    delete?: Enumerable<AdministrativeOrderWhereUniqueInput>
    update?: Enumerable<AdministrativeOrderUpdateWithWhereUniqueWithoutOrderTitleInput>
    updateMany?: Enumerable<AdministrativeOrderUpdateManyWithWhereWithoutOrderTitleInput>
    deleteMany?: Enumerable<AdministrativeOrderScalarWhereInput>
  }

  export type AdministrativeOrderUncheckedUpdateManyWithoutOrderTitleInput = {
    create?: XOR<Enumerable<AdministrativeOrderCreateWithoutOrderTitleInput>, Enumerable<AdministrativeOrderUncheckedCreateWithoutOrderTitleInput>>
    connectOrCreate?: Enumerable<AdministrativeOrderCreateOrConnectWithoutOrderTitleInput>
    upsert?: Enumerable<AdministrativeOrderUpsertWithWhereUniqueWithoutOrderTitleInput>
    createMany?: AdministrativeOrderCreateManyOrderTitleInputEnvelope
    connect?: Enumerable<AdministrativeOrderWhereUniqueInput>
    set?: Enumerable<AdministrativeOrderWhereUniqueInput>
    disconnect?: Enumerable<AdministrativeOrderWhereUniqueInput>
    delete?: Enumerable<AdministrativeOrderWhereUniqueInput>
    update?: Enumerable<AdministrativeOrderUpdateWithWhereUniqueWithoutOrderTitleInput>
    updateMany?: Enumerable<AdministrativeOrderUpdateManyWithWhereWithoutOrderTitleInput>
    deleteMany?: Enumerable<AdministrativeOrderScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutExitCausesInput = {
    create?: XOR<UserCreateWithoutExitCausesInput, UserUncheckedCreateWithoutExitCausesInput>
    connectOrCreate?: UserCreateOrConnectWithoutExitCausesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutExitCausesInput = {
    create?: XOR<UserCreateWithoutExitCausesInput, UserUncheckedCreateWithoutExitCausesInput>
    connectOrCreate?: UserCreateOrConnectWithoutExitCausesInput
    upsert?: UserUpsertWithoutExitCausesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutExitCausesInput, UserUncheckedUpdateWithoutExitCausesInput>
  }

  export type UserCreateNestedOneWithoutPassTypesInput = {
    create?: XOR<UserCreateWithoutPassTypesInput, UserUncheckedCreateWithoutPassTypesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPassTypesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPassTypesInput = {
    create?: XOR<UserCreateWithoutPassTypesInput, UserUncheckedCreateWithoutPassTypesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPassTypesInput
    upsert?: UserUpsertWithoutPassTypesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPassTypesInput, UserUncheckedUpdateWithoutPassTypesInput>
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type SectionCreateNestedOneWithoutUserInput = {
    create?: XOR<SectionCreateWithoutUserInput, SectionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SectionCreateOrConnectWithoutUserInput
    connect?: SectionWhereUniqueInput
  }

  export type PassTypeCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PassTypeCreateWithoutUserInput>, Enumerable<PassTypeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PassTypeCreateOrConnectWithoutUserInput>
    createMany?: PassTypeCreateManyUserInputEnvelope
    connect?: Enumerable<PassTypeWhereUniqueInput>
  }

  export type AdministrativeOrderCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AdministrativeOrderCreateWithoutUserInput>, Enumerable<AdministrativeOrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AdministrativeOrderCreateOrConnectWithoutUserInput>
    createMany?: AdministrativeOrderCreateManyUserInputEnvelope
    connect?: Enumerable<AdministrativeOrderWhereUniqueInput>
  }

  export type OrderTitleCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<OrderTitleCreateWithoutUserInput>, Enumerable<OrderTitleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrderTitleCreateOrConnectWithoutUserInput>
    createMany?: OrderTitleCreateManyUserInputEnvelope
    connect?: Enumerable<OrderTitleWhereUniqueInput>
  }

  export type ExitCausesCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ExitCausesCreateWithoutUserInput>, Enumerable<ExitCausesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ExitCausesCreateOrConnectWithoutUserInput>
    createMany?: ExitCausesCreateManyUserInputEnvelope
    connect?: Enumerable<ExitCausesWhereUniqueInput>
  }

  export type PassTypeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PassTypeCreateWithoutUserInput>, Enumerable<PassTypeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PassTypeCreateOrConnectWithoutUserInput>
    createMany?: PassTypeCreateManyUserInputEnvelope
    connect?: Enumerable<PassTypeWhereUniqueInput>
  }

  export type AdministrativeOrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AdministrativeOrderCreateWithoutUserInput>, Enumerable<AdministrativeOrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AdministrativeOrderCreateOrConnectWithoutUserInput>
    createMany?: AdministrativeOrderCreateManyUserInputEnvelope
    connect?: Enumerable<AdministrativeOrderWhereUniqueInput>
  }

  export type OrderTitleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<OrderTitleCreateWithoutUserInput>, Enumerable<OrderTitleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrderTitleCreateOrConnectWithoutUserInput>
    createMany?: OrderTitleCreateManyUserInputEnvelope
    connect?: Enumerable<OrderTitleWhereUniqueInput>
  }

  export type ExitCausesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ExitCausesCreateWithoutUserInput>, Enumerable<ExitCausesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ExitCausesCreateOrConnectWithoutUserInput>
    createMany?: ExitCausesCreateManyUserInputEnvelope
    connect?: Enumerable<ExitCausesWhereUniqueInput>
  }

  export type RoleUpdateOneRequiredWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type SectionUpdateOneRequiredWithoutUserInput = {
    create?: XOR<SectionCreateWithoutUserInput, SectionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SectionCreateOrConnectWithoutUserInput
    upsert?: SectionUpsertWithoutUserInput
    connect?: SectionWhereUniqueInput
    update?: XOR<SectionUpdateWithoutUserInput, SectionUncheckedUpdateWithoutUserInput>
  }

  export type PassTypeUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<PassTypeCreateWithoutUserInput>, Enumerable<PassTypeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PassTypeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PassTypeUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PassTypeCreateManyUserInputEnvelope
    connect?: Enumerable<PassTypeWhereUniqueInput>
    set?: Enumerable<PassTypeWhereUniqueInput>
    disconnect?: Enumerable<PassTypeWhereUniqueInput>
    delete?: Enumerable<PassTypeWhereUniqueInput>
    update?: Enumerable<PassTypeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PassTypeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PassTypeScalarWhereInput>
  }

  export type AdministrativeOrderUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<AdministrativeOrderCreateWithoutUserInput>, Enumerable<AdministrativeOrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AdministrativeOrderCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AdministrativeOrderUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AdministrativeOrderCreateManyUserInputEnvelope
    connect?: Enumerable<AdministrativeOrderWhereUniqueInput>
    set?: Enumerable<AdministrativeOrderWhereUniqueInput>
    disconnect?: Enumerable<AdministrativeOrderWhereUniqueInput>
    delete?: Enumerable<AdministrativeOrderWhereUniqueInput>
    update?: Enumerable<AdministrativeOrderUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AdministrativeOrderUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AdministrativeOrderScalarWhereInput>
  }

  export type OrderTitleUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<OrderTitleCreateWithoutUserInput>, Enumerable<OrderTitleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrderTitleCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<OrderTitleUpsertWithWhereUniqueWithoutUserInput>
    createMany?: OrderTitleCreateManyUserInputEnvelope
    connect?: Enumerable<OrderTitleWhereUniqueInput>
    set?: Enumerable<OrderTitleWhereUniqueInput>
    disconnect?: Enumerable<OrderTitleWhereUniqueInput>
    delete?: Enumerable<OrderTitleWhereUniqueInput>
    update?: Enumerable<OrderTitleUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<OrderTitleUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<OrderTitleScalarWhereInput>
  }

  export type ExitCausesUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ExitCausesCreateWithoutUserInput>, Enumerable<ExitCausesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ExitCausesCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ExitCausesUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ExitCausesCreateManyUserInputEnvelope
    connect?: Enumerable<ExitCausesWhereUniqueInput>
    set?: Enumerable<ExitCausesWhereUniqueInput>
    disconnect?: Enumerable<ExitCausesWhereUniqueInput>
    delete?: Enumerable<ExitCausesWhereUniqueInput>
    update?: Enumerable<ExitCausesUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ExitCausesUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ExitCausesScalarWhereInput>
  }

  export type PassTypeUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<PassTypeCreateWithoutUserInput>, Enumerable<PassTypeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PassTypeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PassTypeUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PassTypeCreateManyUserInputEnvelope
    connect?: Enumerable<PassTypeWhereUniqueInput>
    set?: Enumerable<PassTypeWhereUniqueInput>
    disconnect?: Enumerable<PassTypeWhereUniqueInput>
    delete?: Enumerable<PassTypeWhereUniqueInput>
    update?: Enumerable<PassTypeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PassTypeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PassTypeScalarWhereInput>
  }

  export type AdministrativeOrderUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<AdministrativeOrderCreateWithoutUserInput>, Enumerable<AdministrativeOrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AdministrativeOrderCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AdministrativeOrderUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AdministrativeOrderCreateManyUserInputEnvelope
    connect?: Enumerable<AdministrativeOrderWhereUniqueInput>
    set?: Enumerable<AdministrativeOrderWhereUniqueInput>
    disconnect?: Enumerable<AdministrativeOrderWhereUniqueInput>
    delete?: Enumerable<AdministrativeOrderWhereUniqueInput>
    update?: Enumerable<AdministrativeOrderUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AdministrativeOrderUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AdministrativeOrderScalarWhereInput>
  }

  export type OrderTitleUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<OrderTitleCreateWithoutUserInput>, Enumerable<OrderTitleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrderTitleCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<OrderTitleUpsertWithWhereUniqueWithoutUserInput>
    createMany?: OrderTitleCreateManyUserInputEnvelope
    connect?: Enumerable<OrderTitleWhereUniqueInput>
    set?: Enumerable<OrderTitleWhereUniqueInput>
    disconnect?: Enumerable<OrderTitleWhereUniqueInput>
    delete?: Enumerable<OrderTitleWhereUniqueInput>
    update?: Enumerable<OrderTitleUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<OrderTitleUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<OrderTitleScalarWhereInput>
  }

  export type ExitCausesUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ExitCausesCreateWithoutUserInput>, Enumerable<ExitCausesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ExitCausesCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ExitCausesUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ExitCausesCreateManyUserInputEnvelope
    connect?: Enumerable<ExitCausesWhereUniqueInput>
    set?: Enumerable<ExitCausesWhereUniqueInput>
    disconnect?: Enumerable<ExitCausesWhereUniqueInput>
    delete?: Enumerable<ExitCausesWhereUniqueInput>
    update?: Enumerable<ExitCausesUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ExitCausesUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ExitCausesScalarWhereInput>
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<UserCreateWithoutRoleInput>, Enumerable<UserUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRoleInput>
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<UserCreateWithoutRoleInput>, Enumerable<UserUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRoleInput>
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserUpdateManyWithoutRoleInput = {
    create?: XOR<Enumerable<UserCreateWithoutRoleInput>, Enumerable<UserUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    create?: XOR<Enumerable<UserCreateWithoutRoleInput>, Enumerable<UserUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type StudentCreateNestedManyWithoutSectionInput = {
    create?: XOR<Enumerable<StudentCreateWithoutSectionInput>, Enumerable<StudentUncheckedCreateWithoutSectionInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutSectionInput>
    createMany?: StudentCreateManySectionInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type UserCreateNestedManyWithoutSectionInput = {
    create?: XOR<Enumerable<UserCreateWithoutSectionInput>, Enumerable<UserUncheckedCreateWithoutSectionInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutSectionInput>
    createMany?: UserCreateManySectionInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type StudentUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<Enumerable<StudentCreateWithoutSectionInput>, Enumerable<StudentUncheckedCreateWithoutSectionInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutSectionInput>
    createMany?: StudentCreateManySectionInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<Enumerable<UserCreateWithoutSectionInput>, Enumerable<UserUncheckedCreateWithoutSectionInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutSectionInput>
    createMany?: UserCreateManySectionInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type StudentUpdateManyWithoutSectionInput = {
    create?: XOR<Enumerable<StudentCreateWithoutSectionInput>, Enumerable<StudentUncheckedCreateWithoutSectionInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutSectionInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutSectionInput>
    createMany?: StudentCreateManySectionInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutSectionInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutSectionInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type UserUpdateManyWithoutSectionInput = {
    create?: XOR<Enumerable<UserCreateWithoutSectionInput>, Enumerable<UserUncheckedCreateWithoutSectionInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutSectionInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutSectionInput>
    createMany?: UserCreateManySectionInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutSectionInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutSectionInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type StudentUncheckedUpdateManyWithoutSectionInput = {
    create?: XOR<Enumerable<StudentCreateWithoutSectionInput>, Enumerable<StudentUncheckedCreateWithoutSectionInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutSectionInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutSectionInput>
    createMany?: StudentCreateManySectionInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutSectionInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutSectionInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutSectionInput = {
    create?: XOR<Enumerable<UserCreateWithoutSectionInput>, Enumerable<UserUncheckedCreateWithoutSectionInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutSectionInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutSectionInput>
    createMany?: UserCreateManySectionInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutSectionInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutSectionInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type SectionCreateNestedOneWithoutStudentsInput = {
    create?: XOR<SectionCreateWithoutStudentsInput, SectionUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: SectionCreateOrConnectWithoutStudentsInput
    connect?: SectionWhereUniqueInput
  }

  export type YearStudyCreateNestedOneWithoutStudentInput = {
    create?: XOR<YearStudyCreateWithoutStudentInput, YearStudyUncheckedCreateWithoutStudentInput>
    connectOrCreate?: YearStudyCreateOrConnectWithoutStudentInput
    connect?: YearStudyWhereUniqueInput
  }

  export type StudentStatusCreateNestedOneWithoutStudentsInput = {
    create?: XOR<StudentStatusCreateWithoutStudentsInput, StudentStatusUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: StudentStatusCreateOrConnectWithoutStudentsInput
    connect?: StudentStatusWhereUniqueInput
  }

  export type AcceptedTypeCreateNestedOneWithoutStudentsInput = {
    create?: XOR<AcceptedTypeCreateWithoutStudentsInput, AcceptedTypeUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: AcceptedTypeCreateOrConnectWithoutStudentsInput
    connect?: AcceptedTypeWhereUniqueInput
  }

  export type AdministrativeOrderCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<AdministrativeOrderCreateWithoutStudentInput>, Enumerable<AdministrativeOrderUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<AdministrativeOrderCreateOrConnectWithoutStudentInput>
    createMany?: AdministrativeOrderCreateManyStudentInputEnvelope
    connect?: Enumerable<AdministrativeOrderWhereUniqueInput>
  }

  export type StudentSchoolCreateNestedOneWithoutStudentInput = {
    create?: XOR<StudentSchoolCreateWithoutStudentInput, StudentSchoolUncheckedCreateWithoutStudentInput>
    connectOrCreate?: StudentSchoolCreateOrConnectWithoutStudentInput
    connect?: StudentSchoolWhereUniqueInput
  }

  export type StudentLevelCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<StudentLevelCreateWithoutStudentInput>, Enumerable<StudentLevelUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<StudentLevelCreateOrConnectWithoutStudentInput>
    createMany?: StudentLevelCreateManyStudentInputEnvelope
    connect?: Enumerable<StudentLevelWhereUniqueInput>
  }

  export type StudentGraduationCreateNestedOneWithoutStudentInput = {
    create?: XOR<StudentGraduationCreateWithoutStudentInput, StudentGraduationUncheckedCreateWithoutStudentInput>
    connectOrCreate?: StudentGraduationCreateOrConnectWithoutStudentInput
    connect?: StudentGraduationWhereUniqueInput
  }

  export type NationalInfoCreateNestedOneWithoutStudentInput = {
    create?: XOR<NationalInfoCreateWithoutStudentInput, NationalInfoUncheckedCreateWithoutStudentInput>
    connectOrCreate?: NationalInfoCreateOrConnectWithoutStudentInput
    connect?: NationalInfoWhereUniqueInput
  }

  export type StudentResponsibleCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<StudentResponsibleCreateWithoutStudentInput>, Enumerable<StudentResponsibleUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<StudentResponsibleCreateOrConnectWithoutStudentInput>
    createMany?: StudentResponsibleCreateManyStudentInputEnvelope
    connect?: Enumerable<StudentResponsibleWhereUniqueInput>
  }

  export type NationalityCertificateCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<NationalityCertificateCreateWithoutStudentInput>, Enumerable<NationalityCertificateUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<NationalityCertificateCreateOrConnectWithoutStudentInput>
    createMany?: NationalityCertificateCreateManyStudentInputEnvelope
    connect?: Enumerable<NationalityCertificateWhereUniqueInput>
  }

  export type StudentImageCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<StudentImageCreateWithoutStudentInput>, Enumerable<StudentImageUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<StudentImageCreateOrConnectWithoutStudentInput>
    createMany?: StudentImageCreateManyStudentInputEnvelope
    connect?: Enumerable<StudentImageWhereUniqueInput>
  }

  export type AddressCreateNestedOneWithoutStudentInput = {
    create?: XOR<AddressCreateWithoutStudentInput, AddressUncheckedCreateWithoutStudentInput>
    connectOrCreate?: AddressCreateOrConnectWithoutStudentInput
    connect?: AddressWhereUniqueInput
  }

  export type AdministrativeOrderUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<AdministrativeOrderCreateWithoutStudentInput>, Enumerable<AdministrativeOrderUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<AdministrativeOrderCreateOrConnectWithoutStudentInput>
    createMany?: AdministrativeOrderCreateManyStudentInputEnvelope
    connect?: Enumerable<AdministrativeOrderWhereUniqueInput>
  }

  export type StudentSchoolUncheckedCreateNestedOneWithoutStudentInput = {
    create?: XOR<StudentSchoolCreateWithoutStudentInput, StudentSchoolUncheckedCreateWithoutStudentInput>
    connectOrCreate?: StudentSchoolCreateOrConnectWithoutStudentInput
    connect?: StudentSchoolWhereUniqueInput
  }

  export type StudentLevelUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<StudentLevelCreateWithoutStudentInput>, Enumerable<StudentLevelUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<StudentLevelCreateOrConnectWithoutStudentInput>
    createMany?: StudentLevelCreateManyStudentInputEnvelope
    connect?: Enumerable<StudentLevelWhereUniqueInput>
  }

  export type StudentGraduationUncheckedCreateNestedOneWithoutStudentInput = {
    create?: XOR<StudentGraduationCreateWithoutStudentInput, StudentGraduationUncheckedCreateWithoutStudentInput>
    connectOrCreate?: StudentGraduationCreateOrConnectWithoutStudentInput
    connect?: StudentGraduationWhereUniqueInput
  }

  export type NationalInfoUncheckedCreateNestedOneWithoutStudentInput = {
    create?: XOR<NationalInfoCreateWithoutStudentInput, NationalInfoUncheckedCreateWithoutStudentInput>
    connectOrCreate?: NationalInfoCreateOrConnectWithoutStudentInput
    connect?: NationalInfoWhereUniqueInput
  }

  export type StudentResponsibleUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<StudentResponsibleCreateWithoutStudentInput>, Enumerable<StudentResponsibleUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<StudentResponsibleCreateOrConnectWithoutStudentInput>
    createMany?: StudentResponsibleCreateManyStudentInputEnvelope
    connect?: Enumerable<StudentResponsibleWhereUniqueInput>
  }

  export type NationalityCertificateUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<NationalityCertificateCreateWithoutStudentInput>, Enumerable<NationalityCertificateUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<NationalityCertificateCreateOrConnectWithoutStudentInput>
    createMany?: NationalityCertificateCreateManyStudentInputEnvelope
    connect?: Enumerable<NationalityCertificateWhereUniqueInput>
  }

  export type StudentImageUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<StudentImageCreateWithoutStudentInput>, Enumerable<StudentImageUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<StudentImageCreateOrConnectWithoutStudentInput>
    createMany?: StudentImageCreateManyStudentInputEnvelope
    connect?: Enumerable<StudentImageWhereUniqueInput>
  }

  export type AddressUncheckedCreateNestedOneWithoutStudentInput = {
    create?: XOR<AddressCreateWithoutStudentInput, AddressUncheckedCreateWithoutStudentInput>
    connectOrCreate?: AddressCreateOrConnectWithoutStudentInput
    connect?: AddressWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type SectionUpdateOneRequiredWithoutStudentsInput = {
    create?: XOR<SectionCreateWithoutStudentsInput, SectionUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: SectionCreateOrConnectWithoutStudentsInput
    upsert?: SectionUpsertWithoutStudentsInput
    connect?: SectionWhereUniqueInput
    update?: XOR<SectionUpdateWithoutStudentsInput, SectionUncheckedUpdateWithoutStudentsInput>
  }

  export type YearStudyUpdateOneRequiredWithoutStudentInput = {
    create?: XOR<YearStudyCreateWithoutStudentInput, YearStudyUncheckedCreateWithoutStudentInput>
    connectOrCreate?: YearStudyCreateOrConnectWithoutStudentInput
    upsert?: YearStudyUpsertWithoutStudentInput
    connect?: YearStudyWhereUniqueInput
    update?: XOR<YearStudyUpdateWithoutStudentInput, YearStudyUncheckedUpdateWithoutStudentInput>
  }

  export type StudentStatusUpdateOneRequiredWithoutStudentsInput = {
    create?: XOR<StudentStatusCreateWithoutStudentsInput, StudentStatusUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: StudentStatusCreateOrConnectWithoutStudentsInput
    upsert?: StudentStatusUpsertWithoutStudentsInput
    connect?: StudentStatusWhereUniqueInput
    update?: XOR<StudentStatusUpdateWithoutStudentsInput, StudentStatusUncheckedUpdateWithoutStudentsInput>
  }

  export type AcceptedTypeUpdateOneRequiredWithoutStudentsInput = {
    create?: XOR<AcceptedTypeCreateWithoutStudentsInput, AcceptedTypeUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: AcceptedTypeCreateOrConnectWithoutStudentsInput
    upsert?: AcceptedTypeUpsertWithoutStudentsInput
    connect?: AcceptedTypeWhereUniqueInput
    update?: XOR<AcceptedTypeUpdateWithoutStudentsInput, AcceptedTypeUncheckedUpdateWithoutStudentsInput>
  }

  export type AdministrativeOrderUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<AdministrativeOrderCreateWithoutStudentInput>, Enumerable<AdministrativeOrderUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<AdministrativeOrderCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<AdministrativeOrderUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: AdministrativeOrderCreateManyStudentInputEnvelope
    connect?: Enumerable<AdministrativeOrderWhereUniqueInput>
    set?: Enumerable<AdministrativeOrderWhereUniqueInput>
    disconnect?: Enumerable<AdministrativeOrderWhereUniqueInput>
    delete?: Enumerable<AdministrativeOrderWhereUniqueInput>
    update?: Enumerable<AdministrativeOrderUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<AdministrativeOrderUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<AdministrativeOrderScalarWhereInput>
  }

  export type StudentSchoolUpdateOneWithoutStudentInput = {
    create?: XOR<StudentSchoolCreateWithoutStudentInput, StudentSchoolUncheckedCreateWithoutStudentInput>
    connectOrCreate?: StudentSchoolCreateOrConnectWithoutStudentInput
    upsert?: StudentSchoolUpsertWithoutStudentInput
    connect?: StudentSchoolWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<StudentSchoolUpdateWithoutStudentInput, StudentSchoolUncheckedUpdateWithoutStudentInput>
  }

  export type StudentLevelUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<StudentLevelCreateWithoutStudentInput>, Enumerable<StudentLevelUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<StudentLevelCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<StudentLevelUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: StudentLevelCreateManyStudentInputEnvelope
    connect?: Enumerable<StudentLevelWhereUniqueInput>
    set?: Enumerable<StudentLevelWhereUniqueInput>
    disconnect?: Enumerable<StudentLevelWhereUniqueInput>
    delete?: Enumerable<StudentLevelWhereUniqueInput>
    update?: Enumerable<StudentLevelUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<StudentLevelUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<StudentLevelScalarWhereInput>
  }

  export type StudentGraduationUpdateOneWithoutStudentInput = {
    create?: XOR<StudentGraduationCreateWithoutStudentInput, StudentGraduationUncheckedCreateWithoutStudentInput>
    connectOrCreate?: StudentGraduationCreateOrConnectWithoutStudentInput
    upsert?: StudentGraduationUpsertWithoutStudentInput
    connect?: StudentGraduationWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<StudentGraduationUpdateWithoutStudentInput, StudentGraduationUncheckedUpdateWithoutStudentInput>
  }

  export type NationalInfoUpdateOneWithoutStudentInput = {
    create?: XOR<NationalInfoCreateWithoutStudentInput, NationalInfoUncheckedCreateWithoutStudentInput>
    connectOrCreate?: NationalInfoCreateOrConnectWithoutStudentInput
    upsert?: NationalInfoUpsertWithoutStudentInput
    connect?: NationalInfoWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<NationalInfoUpdateWithoutStudentInput, NationalInfoUncheckedUpdateWithoutStudentInput>
  }

  export type StudentResponsibleUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<StudentResponsibleCreateWithoutStudentInput>, Enumerable<StudentResponsibleUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<StudentResponsibleCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<StudentResponsibleUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: StudentResponsibleCreateManyStudentInputEnvelope
    connect?: Enumerable<StudentResponsibleWhereUniqueInput>
    set?: Enumerable<StudentResponsibleWhereUniqueInput>
    disconnect?: Enumerable<StudentResponsibleWhereUniqueInput>
    delete?: Enumerable<StudentResponsibleWhereUniqueInput>
    update?: Enumerable<StudentResponsibleUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<StudentResponsibleUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<StudentResponsibleScalarWhereInput>
  }

  export type NationalityCertificateUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<NationalityCertificateCreateWithoutStudentInput>, Enumerable<NationalityCertificateUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<NationalityCertificateCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<NationalityCertificateUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: NationalityCertificateCreateManyStudentInputEnvelope
    connect?: Enumerable<NationalityCertificateWhereUniqueInput>
    set?: Enumerable<NationalityCertificateWhereUniqueInput>
    disconnect?: Enumerable<NationalityCertificateWhereUniqueInput>
    delete?: Enumerable<NationalityCertificateWhereUniqueInput>
    update?: Enumerable<NationalityCertificateUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<NationalityCertificateUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<NationalityCertificateScalarWhereInput>
  }

  export type StudentImageUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<StudentImageCreateWithoutStudentInput>, Enumerable<StudentImageUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<StudentImageCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<StudentImageUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: StudentImageCreateManyStudentInputEnvelope
    connect?: Enumerable<StudentImageWhereUniqueInput>
    set?: Enumerable<StudentImageWhereUniqueInput>
    disconnect?: Enumerable<StudentImageWhereUniqueInput>
    delete?: Enumerable<StudentImageWhereUniqueInput>
    update?: Enumerable<StudentImageUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<StudentImageUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<StudentImageScalarWhereInput>
  }

  export type AddressUpdateOneWithoutStudentInput = {
    create?: XOR<AddressCreateWithoutStudentInput, AddressUncheckedCreateWithoutStudentInput>
    connectOrCreate?: AddressCreateOrConnectWithoutStudentInput
    upsert?: AddressUpsertWithoutStudentInput
    connect?: AddressWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<AddressUpdateWithoutStudentInput, AddressUncheckedUpdateWithoutStudentInput>
  }

  export type AdministrativeOrderUncheckedUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<AdministrativeOrderCreateWithoutStudentInput>, Enumerable<AdministrativeOrderUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<AdministrativeOrderCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<AdministrativeOrderUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: AdministrativeOrderCreateManyStudentInputEnvelope
    connect?: Enumerable<AdministrativeOrderWhereUniqueInput>
    set?: Enumerable<AdministrativeOrderWhereUniqueInput>
    disconnect?: Enumerable<AdministrativeOrderWhereUniqueInput>
    delete?: Enumerable<AdministrativeOrderWhereUniqueInput>
    update?: Enumerable<AdministrativeOrderUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<AdministrativeOrderUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<AdministrativeOrderScalarWhereInput>
  }

  export type StudentSchoolUncheckedUpdateOneWithoutStudentInput = {
    create?: XOR<StudentSchoolCreateWithoutStudentInput, StudentSchoolUncheckedCreateWithoutStudentInput>
    connectOrCreate?: StudentSchoolCreateOrConnectWithoutStudentInput
    upsert?: StudentSchoolUpsertWithoutStudentInput
    connect?: StudentSchoolWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<StudentSchoolUpdateWithoutStudentInput, StudentSchoolUncheckedUpdateWithoutStudentInput>
  }

  export type StudentLevelUncheckedUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<StudentLevelCreateWithoutStudentInput>, Enumerable<StudentLevelUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<StudentLevelCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<StudentLevelUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: StudentLevelCreateManyStudentInputEnvelope
    connect?: Enumerable<StudentLevelWhereUniqueInput>
    set?: Enumerable<StudentLevelWhereUniqueInput>
    disconnect?: Enumerable<StudentLevelWhereUniqueInput>
    delete?: Enumerable<StudentLevelWhereUniqueInput>
    update?: Enumerable<StudentLevelUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<StudentLevelUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<StudentLevelScalarWhereInput>
  }

  export type StudentGraduationUncheckedUpdateOneWithoutStudentInput = {
    create?: XOR<StudentGraduationCreateWithoutStudentInput, StudentGraduationUncheckedCreateWithoutStudentInput>
    connectOrCreate?: StudentGraduationCreateOrConnectWithoutStudentInput
    upsert?: StudentGraduationUpsertWithoutStudentInput
    connect?: StudentGraduationWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<StudentGraduationUpdateWithoutStudentInput, StudentGraduationUncheckedUpdateWithoutStudentInput>
  }

  export type NationalInfoUncheckedUpdateOneWithoutStudentInput = {
    create?: XOR<NationalInfoCreateWithoutStudentInput, NationalInfoUncheckedCreateWithoutStudentInput>
    connectOrCreate?: NationalInfoCreateOrConnectWithoutStudentInput
    upsert?: NationalInfoUpsertWithoutStudentInput
    connect?: NationalInfoWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<NationalInfoUpdateWithoutStudentInput, NationalInfoUncheckedUpdateWithoutStudentInput>
  }

  export type StudentResponsibleUncheckedUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<StudentResponsibleCreateWithoutStudentInput>, Enumerable<StudentResponsibleUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<StudentResponsibleCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<StudentResponsibleUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: StudentResponsibleCreateManyStudentInputEnvelope
    connect?: Enumerable<StudentResponsibleWhereUniqueInput>
    set?: Enumerable<StudentResponsibleWhereUniqueInput>
    disconnect?: Enumerable<StudentResponsibleWhereUniqueInput>
    delete?: Enumerable<StudentResponsibleWhereUniqueInput>
    update?: Enumerable<StudentResponsibleUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<StudentResponsibleUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<StudentResponsibleScalarWhereInput>
  }

  export type NationalityCertificateUncheckedUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<NationalityCertificateCreateWithoutStudentInput>, Enumerable<NationalityCertificateUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<NationalityCertificateCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<NationalityCertificateUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: NationalityCertificateCreateManyStudentInputEnvelope
    connect?: Enumerable<NationalityCertificateWhereUniqueInput>
    set?: Enumerable<NationalityCertificateWhereUniqueInput>
    disconnect?: Enumerable<NationalityCertificateWhereUniqueInput>
    delete?: Enumerable<NationalityCertificateWhereUniqueInput>
    update?: Enumerable<NationalityCertificateUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<NationalityCertificateUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<NationalityCertificateScalarWhereInput>
  }

  export type StudentImageUncheckedUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<StudentImageCreateWithoutStudentInput>, Enumerable<StudentImageUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<StudentImageCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<StudentImageUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: StudentImageCreateManyStudentInputEnvelope
    connect?: Enumerable<StudentImageWhereUniqueInput>
    set?: Enumerable<StudentImageWhereUniqueInput>
    disconnect?: Enumerable<StudentImageWhereUniqueInput>
    delete?: Enumerable<StudentImageWhereUniqueInput>
    update?: Enumerable<StudentImageUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<StudentImageUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<StudentImageScalarWhereInput>
  }

  export type AddressUncheckedUpdateOneWithoutStudentInput = {
    create?: XOR<AddressCreateWithoutStudentInput, AddressUncheckedCreateWithoutStudentInput>
    connectOrCreate?: AddressCreateOrConnectWithoutStudentInput
    upsert?: AddressUpsertWithoutStudentInput
    connect?: AddressWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<AddressUpdateWithoutStudentInput, AddressUncheckedUpdateWithoutStudentInput>
  }

  export type StudentLevelCreateNestedManyWithoutYearStudyInput = {
    create?: XOR<Enumerable<StudentLevelCreateWithoutYearStudyInput>, Enumerable<StudentLevelUncheckedCreateWithoutYearStudyInput>>
    connectOrCreate?: Enumerable<StudentLevelCreateOrConnectWithoutYearStudyInput>
    createMany?: StudentLevelCreateManyYearStudyInputEnvelope
    connect?: Enumerable<StudentLevelWhereUniqueInput>
  }

  export type StudentCreateNestedManyWithoutYearStudyInput = {
    create?: XOR<Enumerable<StudentCreateWithoutYearStudyInput>, Enumerable<StudentUncheckedCreateWithoutYearStudyInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutYearStudyInput>
    createMany?: StudentCreateManyYearStudyInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type StudentLevelUncheckedCreateNestedManyWithoutYearStudyInput = {
    create?: XOR<Enumerable<StudentLevelCreateWithoutYearStudyInput>, Enumerable<StudentLevelUncheckedCreateWithoutYearStudyInput>>
    connectOrCreate?: Enumerable<StudentLevelCreateOrConnectWithoutYearStudyInput>
    createMany?: StudentLevelCreateManyYearStudyInputEnvelope
    connect?: Enumerable<StudentLevelWhereUniqueInput>
  }

  export type StudentUncheckedCreateNestedManyWithoutYearStudyInput = {
    create?: XOR<Enumerable<StudentCreateWithoutYearStudyInput>, Enumerable<StudentUncheckedCreateWithoutYearStudyInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutYearStudyInput>
    createMany?: StudentCreateManyYearStudyInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type StudentLevelUpdateManyWithoutYearStudyInput = {
    create?: XOR<Enumerable<StudentLevelCreateWithoutYearStudyInput>, Enumerable<StudentLevelUncheckedCreateWithoutYearStudyInput>>
    connectOrCreate?: Enumerable<StudentLevelCreateOrConnectWithoutYearStudyInput>
    upsert?: Enumerable<StudentLevelUpsertWithWhereUniqueWithoutYearStudyInput>
    createMany?: StudentLevelCreateManyYearStudyInputEnvelope
    connect?: Enumerable<StudentLevelWhereUniqueInput>
    set?: Enumerable<StudentLevelWhereUniqueInput>
    disconnect?: Enumerable<StudentLevelWhereUniqueInput>
    delete?: Enumerable<StudentLevelWhereUniqueInput>
    update?: Enumerable<StudentLevelUpdateWithWhereUniqueWithoutYearStudyInput>
    updateMany?: Enumerable<StudentLevelUpdateManyWithWhereWithoutYearStudyInput>
    deleteMany?: Enumerable<StudentLevelScalarWhereInput>
  }

  export type StudentUpdateManyWithoutYearStudyInput = {
    create?: XOR<Enumerable<StudentCreateWithoutYearStudyInput>, Enumerable<StudentUncheckedCreateWithoutYearStudyInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutYearStudyInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutYearStudyInput>
    createMany?: StudentCreateManyYearStudyInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutYearStudyInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutYearStudyInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type StudentLevelUncheckedUpdateManyWithoutYearStudyInput = {
    create?: XOR<Enumerable<StudentLevelCreateWithoutYearStudyInput>, Enumerable<StudentLevelUncheckedCreateWithoutYearStudyInput>>
    connectOrCreate?: Enumerable<StudentLevelCreateOrConnectWithoutYearStudyInput>
    upsert?: Enumerable<StudentLevelUpsertWithWhereUniqueWithoutYearStudyInput>
    createMany?: StudentLevelCreateManyYearStudyInputEnvelope
    connect?: Enumerable<StudentLevelWhereUniqueInput>
    set?: Enumerable<StudentLevelWhereUniqueInput>
    disconnect?: Enumerable<StudentLevelWhereUniqueInput>
    delete?: Enumerable<StudentLevelWhereUniqueInput>
    update?: Enumerable<StudentLevelUpdateWithWhereUniqueWithoutYearStudyInput>
    updateMany?: Enumerable<StudentLevelUpdateManyWithWhereWithoutYearStudyInput>
    deleteMany?: Enumerable<StudentLevelScalarWhereInput>
  }

  export type StudentUncheckedUpdateManyWithoutYearStudyInput = {
    create?: XOR<Enumerable<StudentCreateWithoutYearStudyInput>, Enumerable<StudentUncheckedCreateWithoutYearStudyInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutYearStudyInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutYearStudyInput>
    createMany?: StudentCreateManyYearStudyInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutYearStudyInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutYearStudyInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type StudentCreateNestedOneWithoutStudentResponsablesInput = {
    create?: XOR<StudentCreateWithoutStudentResponsablesInput, StudentUncheckedCreateWithoutStudentResponsablesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentResponsablesInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutStudentResponsablesInput = {
    create?: XOR<StudentCreateWithoutStudentResponsablesInput, StudentUncheckedCreateWithoutStudentResponsablesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentResponsablesInput
    upsert?: StudentUpsertWithoutStudentResponsablesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<StudentUpdateWithoutStudentResponsablesInput, StudentUncheckedUpdateWithoutStudentResponsablesInput>
  }

  export type StudentCreateNestedOneWithoutNationalityCertificateInput = {
    create?: XOR<StudentCreateWithoutNationalityCertificateInput, StudentUncheckedCreateWithoutNationalityCertificateInput>
    connectOrCreate?: StudentCreateOrConnectWithoutNationalityCertificateInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutNationalityCertificateInput = {
    create?: XOR<StudentCreateWithoutNationalityCertificateInput, StudentUncheckedCreateWithoutNationalityCertificateInput>
    connectOrCreate?: StudentCreateOrConnectWithoutNationalityCertificateInput
    upsert?: StudentUpsertWithoutNationalityCertificateInput
    connect?: StudentWhereUniqueInput
    update?: XOR<StudentUpdateWithoutNationalityCertificateInput, StudentUncheckedUpdateWithoutNationalityCertificateInput>
  }

  export type StudentCreateNestedOneWithoutNationalInfoInput = {
    create?: XOR<StudentCreateWithoutNationalInfoInput, StudentUncheckedCreateWithoutNationalInfoInput>
    connectOrCreate?: StudentCreateOrConnectWithoutNationalInfoInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutNationalInfoInput = {
    create?: XOR<StudentCreateWithoutNationalInfoInput, StudentUncheckedCreateWithoutNationalInfoInput>
    connectOrCreate?: StudentCreateOrConnectWithoutNationalInfoInput
    upsert?: StudentUpsertWithoutNationalInfoInput
    connect?: StudentWhereUniqueInput
    update?: XOR<StudentUpdateWithoutNationalInfoInput, StudentUncheckedUpdateWithoutNationalInfoInput>
  }

  export type StudentCreateNestedOneWithoutStudentGraduationInput = {
    create?: XOR<StudentCreateWithoutStudentGraduationInput, StudentUncheckedCreateWithoutStudentGraduationInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentGraduationInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutStudentGraduationInput = {
    create?: XOR<StudentCreateWithoutStudentGraduationInput, StudentUncheckedCreateWithoutStudentGraduationInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentGraduationInput
    upsert?: StudentUpsertWithoutStudentGraduationInput
    connect?: StudentWhereUniqueInput
    update?: XOR<StudentUpdateWithoutStudentGraduationInput, StudentUncheckedUpdateWithoutStudentGraduationInput>
  }

  export type YearStudyCreateNestedOneWithoutStudentLevelInput = {
    create?: XOR<YearStudyCreateWithoutStudentLevelInput, YearStudyUncheckedCreateWithoutStudentLevelInput>
    connectOrCreate?: YearStudyCreateOrConnectWithoutStudentLevelInput
    connect?: YearStudyWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutStudentLevelInput = {
    create?: XOR<StudentCreateWithoutStudentLevelInput, StudentUncheckedCreateWithoutStudentLevelInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentLevelInput
    connect?: StudentWhereUniqueInput
  }

  export type YearStudyUpdateOneRequiredWithoutStudentLevelInput = {
    create?: XOR<YearStudyCreateWithoutStudentLevelInput, YearStudyUncheckedCreateWithoutStudentLevelInput>
    connectOrCreate?: YearStudyCreateOrConnectWithoutStudentLevelInput
    upsert?: YearStudyUpsertWithoutStudentLevelInput
    connect?: YearStudyWhereUniqueInput
    update?: XOR<YearStudyUpdateWithoutStudentLevelInput, YearStudyUncheckedUpdateWithoutStudentLevelInput>
  }

  export type StudentUpdateOneRequiredWithoutStudentLevelInput = {
    create?: XOR<StudentCreateWithoutStudentLevelInput, StudentUncheckedCreateWithoutStudentLevelInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentLevelInput
    upsert?: StudentUpsertWithoutStudentLevelInput
    connect?: StudentWhereUniqueInput
    update?: XOR<StudentUpdateWithoutStudentLevelInput, StudentUncheckedUpdateWithoutStudentLevelInput>
  }

  export type StudySubCategoryCreateNestedOneWithoutStudentSchoolInput = {
    create?: XOR<StudySubCategoryCreateWithoutStudentSchoolInput, StudySubCategoryUncheckedCreateWithoutStudentSchoolInput>
    connectOrCreate?: StudySubCategoryCreateOrConnectWithoutStudentSchoolInput
    connect?: StudySubCategoryWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutStudentSchoolInput = {
    create?: XOR<StudentCreateWithoutStudentSchoolInput, StudentUncheckedCreateWithoutStudentSchoolInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentSchoolInput
    connect?: StudentWhereUniqueInput
  }

  export type CertificateStatusCreateNestedOneWithoutStudentSchoolInput = {
    create?: XOR<CertificateStatusCreateWithoutStudentSchoolInput, CertificateStatusUncheckedCreateWithoutStudentSchoolInput>
    connectOrCreate?: CertificateStatusCreateOrConnectWithoutStudentSchoolInput
    connect?: CertificateStatusWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StudySubCategoryUpdateOneRequiredWithoutStudentSchoolInput = {
    create?: XOR<StudySubCategoryCreateWithoutStudentSchoolInput, StudySubCategoryUncheckedCreateWithoutStudentSchoolInput>
    connectOrCreate?: StudySubCategoryCreateOrConnectWithoutStudentSchoolInput
    upsert?: StudySubCategoryUpsertWithoutStudentSchoolInput
    connect?: StudySubCategoryWhereUniqueInput
    update?: XOR<StudySubCategoryUpdateWithoutStudentSchoolInput, StudySubCategoryUncheckedUpdateWithoutStudentSchoolInput>
  }

  export type StudentUpdateOneRequiredWithoutStudentSchoolInput = {
    create?: XOR<StudentCreateWithoutStudentSchoolInput, StudentUncheckedCreateWithoutStudentSchoolInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentSchoolInput
    upsert?: StudentUpsertWithoutStudentSchoolInput
    connect?: StudentWhereUniqueInput
    update?: XOR<StudentUpdateWithoutStudentSchoolInput, StudentUncheckedUpdateWithoutStudentSchoolInput>
  }

  export type CertificateStatusUpdateOneRequiredWithoutStudentSchoolInput = {
    create?: XOR<CertificateStatusCreateWithoutStudentSchoolInput, CertificateStatusUncheckedCreateWithoutStudentSchoolInput>
    connectOrCreate?: CertificateStatusCreateOrConnectWithoutStudentSchoolInput
    upsert?: CertificateStatusUpsertWithoutStudentSchoolInput
    connect?: CertificateStatusWhereUniqueInput
    update?: XOR<CertificateStatusUpdateWithoutStudentSchoolInput, CertificateStatusUncheckedUpdateWithoutStudentSchoolInput>
  }

  export type StudySubCategoryCreateNestedManyWithoutStudyCategoryInput = {
    create?: XOR<Enumerable<StudySubCategoryCreateWithoutStudyCategoryInput>, Enumerable<StudySubCategoryUncheckedCreateWithoutStudyCategoryInput>>
    connectOrCreate?: Enumerable<StudySubCategoryCreateOrConnectWithoutStudyCategoryInput>
    createMany?: StudySubCategoryCreateManyStudyCategoryInputEnvelope
    connect?: Enumerable<StudySubCategoryWhereUniqueInput>
  }

  export type StudySubCategoryUncheckedCreateNestedManyWithoutStudyCategoryInput = {
    create?: XOR<Enumerable<StudySubCategoryCreateWithoutStudyCategoryInput>, Enumerable<StudySubCategoryUncheckedCreateWithoutStudyCategoryInput>>
    connectOrCreate?: Enumerable<StudySubCategoryCreateOrConnectWithoutStudyCategoryInput>
    createMany?: StudySubCategoryCreateManyStudyCategoryInputEnvelope
    connect?: Enumerable<StudySubCategoryWhereUniqueInput>
  }

  export type StudySubCategoryUpdateManyWithoutStudyCategoryInput = {
    create?: XOR<Enumerable<StudySubCategoryCreateWithoutStudyCategoryInput>, Enumerable<StudySubCategoryUncheckedCreateWithoutStudyCategoryInput>>
    connectOrCreate?: Enumerable<StudySubCategoryCreateOrConnectWithoutStudyCategoryInput>
    upsert?: Enumerable<StudySubCategoryUpsertWithWhereUniqueWithoutStudyCategoryInput>
    createMany?: StudySubCategoryCreateManyStudyCategoryInputEnvelope
    connect?: Enumerable<StudySubCategoryWhereUniqueInput>
    set?: Enumerable<StudySubCategoryWhereUniqueInput>
    disconnect?: Enumerable<StudySubCategoryWhereUniqueInput>
    delete?: Enumerable<StudySubCategoryWhereUniqueInput>
    update?: Enumerable<StudySubCategoryUpdateWithWhereUniqueWithoutStudyCategoryInput>
    updateMany?: Enumerable<StudySubCategoryUpdateManyWithWhereWithoutStudyCategoryInput>
    deleteMany?: Enumerable<StudySubCategoryScalarWhereInput>
  }

  export type StudySubCategoryUncheckedUpdateManyWithoutStudyCategoryInput = {
    create?: XOR<Enumerable<StudySubCategoryCreateWithoutStudyCategoryInput>, Enumerable<StudySubCategoryUncheckedCreateWithoutStudyCategoryInput>>
    connectOrCreate?: Enumerable<StudySubCategoryCreateOrConnectWithoutStudyCategoryInput>
    upsert?: Enumerable<StudySubCategoryUpsertWithWhereUniqueWithoutStudyCategoryInput>
    createMany?: StudySubCategoryCreateManyStudyCategoryInputEnvelope
    connect?: Enumerable<StudySubCategoryWhereUniqueInput>
    set?: Enumerable<StudySubCategoryWhereUniqueInput>
    disconnect?: Enumerable<StudySubCategoryWhereUniqueInput>
    delete?: Enumerable<StudySubCategoryWhereUniqueInput>
    update?: Enumerable<StudySubCategoryUpdateWithWhereUniqueWithoutStudyCategoryInput>
    updateMany?: Enumerable<StudySubCategoryUpdateManyWithWhereWithoutStudyCategoryInput>
    deleteMany?: Enumerable<StudySubCategoryScalarWhereInput>
  }

  export type StudyCategoryCreateNestedOneWithoutStudySubCategoryInput = {
    create?: XOR<StudyCategoryCreateWithoutStudySubCategoryInput, StudyCategoryUncheckedCreateWithoutStudySubCategoryInput>
    connectOrCreate?: StudyCategoryCreateOrConnectWithoutStudySubCategoryInput
    connect?: StudyCategoryWhereUniqueInput
  }

  export type StudentSchoolCreateNestedManyWithoutStudySubCategoryInput = {
    create?: XOR<Enumerable<StudentSchoolCreateWithoutStudySubCategoryInput>, Enumerable<StudentSchoolUncheckedCreateWithoutStudySubCategoryInput>>
    connectOrCreate?: Enumerable<StudentSchoolCreateOrConnectWithoutStudySubCategoryInput>
    createMany?: StudentSchoolCreateManyStudySubCategoryInputEnvelope
    connect?: Enumerable<StudentSchoolWhereUniqueInput>
  }

  export type StudentSchoolUncheckedCreateNestedManyWithoutStudySubCategoryInput = {
    create?: XOR<Enumerable<StudentSchoolCreateWithoutStudySubCategoryInput>, Enumerable<StudentSchoolUncheckedCreateWithoutStudySubCategoryInput>>
    connectOrCreate?: Enumerable<StudentSchoolCreateOrConnectWithoutStudySubCategoryInput>
    createMany?: StudentSchoolCreateManyStudySubCategoryInputEnvelope
    connect?: Enumerable<StudentSchoolWhereUniqueInput>
  }

  export type StudyCategoryUpdateOneRequiredWithoutStudySubCategoryInput = {
    create?: XOR<StudyCategoryCreateWithoutStudySubCategoryInput, StudyCategoryUncheckedCreateWithoutStudySubCategoryInput>
    connectOrCreate?: StudyCategoryCreateOrConnectWithoutStudySubCategoryInput
    upsert?: StudyCategoryUpsertWithoutStudySubCategoryInput
    connect?: StudyCategoryWhereUniqueInput
    update?: XOR<StudyCategoryUpdateWithoutStudySubCategoryInput, StudyCategoryUncheckedUpdateWithoutStudySubCategoryInput>
  }

  export type StudentSchoolUpdateManyWithoutStudySubCategoryInput = {
    create?: XOR<Enumerable<StudentSchoolCreateWithoutStudySubCategoryInput>, Enumerable<StudentSchoolUncheckedCreateWithoutStudySubCategoryInput>>
    connectOrCreate?: Enumerable<StudentSchoolCreateOrConnectWithoutStudySubCategoryInput>
    upsert?: Enumerable<StudentSchoolUpsertWithWhereUniqueWithoutStudySubCategoryInput>
    createMany?: StudentSchoolCreateManyStudySubCategoryInputEnvelope
    connect?: Enumerable<StudentSchoolWhereUniqueInput>
    set?: Enumerable<StudentSchoolWhereUniqueInput>
    disconnect?: Enumerable<StudentSchoolWhereUniqueInput>
    delete?: Enumerable<StudentSchoolWhereUniqueInput>
    update?: Enumerable<StudentSchoolUpdateWithWhereUniqueWithoutStudySubCategoryInput>
    updateMany?: Enumerable<StudentSchoolUpdateManyWithWhereWithoutStudySubCategoryInput>
    deleteMany?: Enumerable<StudentSchoolScalarWhereInput>
  }

  export type StudentSchoolUncheckedUpdateManyWithoutStudySubCategoryInput = {
    create?: XOR<Enumerable<StudentSchoolCreateWithoutStudySubCategoryInput>, Enumerable<StudentSchoolUncheckedCreateWithoutStudySubCategoryInput>>
    connectOrCreate?: Enumerable<StudentSchoolCreateOrConnectWithoutStudySubCategoryInput>
    upsert?: Enumerable<StudentSchoolUpsertWithWhereUniqueWithoutStudySubCategoryInput>
    createMany?: StudentSchoolCreateManyStudySubCategoryInputEnvelope
    connect?: Enumerable<StudentSchoolWhereUniqueInput>
    set?: Enumerable<StudentSchoolWhereUniqueInput>
    disconnect?: Enumerable<StudentSchoolWhereUniqueInput>
    delete?: Enumerable<StudentSchoolWhereUniqueInput>
    update?: Enumerable<StudentSchoolUpdateWithWhereUniqueWithoutStudySubCategoryInput>
    updateMany?: Enumerable<StudentSchoolUpdateManyWithWhereWithoutStudySubCategoryInput>
    deleteMany?: Enumerable<StudentSchoolScalarWhereInput>
  }

  export type StudentSchoolCreateNestedManyWithoutCertificateStatusInput = {
    create?: XOR<Enumerable<StudentSchoolCreateWithoutCertificateStatusInput>, Enumerable<StudentSchoolUncheckedCreateWithoutCertificateStatusInput>>
    connectOrCreate?: Enumerable<StudentSchoolCreateOrConnectWithoutCertificateStatusInput>
    createMany?: StudentSchoolCreateManyCertificateStatusInputEnvelope
    connect?: Enumerable<StudentSchoolWhereUniqueInput>
  }

  export type StudentSchoolUncheckedCreateNestedManyWithoutCertificateStatusInput = {
    create?: XOR<Enumerable<StudentSchoolCreateWithoutCertificateStatusInput>, Enumerable<StudentSchoolUncheckedCreateWithoutCertificateStatusInput>>
    connectOrCreate?: Enumerable<StudentSchoolCreateOrConnectWithoutCertificateStatusInput>
    createMany?: StudentSchoolCreateManyCertificateStatusInputEnvelope
    connect?: Enumerable<StudentSchoolWhereUniqueInput>
  }

  export type StudentSchoolUpdateManyWithoutCertificateStatusInput = {
    create?: XOR<Enumerable<StudentSchoolCreateWithoutCertificateStatusInput>, Enumerable<StudentSchoolUncheckedCreateWithoutCertificateStatusInput>>
    connectOrCreate?: Enumerable<StudentSchoolCreateOrConnectWithoutCertificateStatusInput>
    upsert?: Enumerable<StudentSchoolUpsertWithWhereUniqueWithoutCertificateStatusInput>
    createMany?: StudentSchoolCreateManyCertificateStatusInputEnvelope
    connect?: Enumerable<StudentSchoolWhereUniqueInput>
    set?: Enumerable<StudentSchoolWhereUniqueInput>
    disconnect?: Enumerable<StudentSchoolWhereUniqueInput>
    delete?: Enumerable<StudentSchoolWhereUniqueInput>
    update?: Enumerable<StudentSchoolUpdateWithWhereUniqueWithoutCertificateStatusInput>
    updateMany?: Enumerable<StudentSchoolUpdateManyWithWhereWithoutCertificateStatusInput>
    deleteMany?: Enumerable<StudentSchoolScalarWhereInput>
  }

  export type StudentSchoolUncheckedUpdateManyWithoutCertificateStatusInput = {
    create?: XOR<Enumerable<StudentSchoolCreateWithoutCertificateStatusInput>, Enumerable<StudentSchoolUncheckedCreateWithoutCertificateStatusInput>>
    connectOrCreate?: Enumerable<StudentSchoolCreateOrConnectWithoutCertificateStatusInput>
    upsert?: Enumerable<StudentSchoolUpsertWithWhereUniqueWithoutCertificateStatusInput>
    createMany?: StudentSchoolCreateManyCertificateStatusInputEnvelope
    connect?: Enumerable<StudentSchoolWhereUniqueInput>
    set?: Enumerable<StudentSchoolWhereUniqueInput>
    disconnect?: Enumerable<StudentSchoolWhereUniqueInput>
    delete?: Enumerable<StudentSchoolWhereUniqueInput>
    update?: Enumerable<StudentSchoolUpdateWithWhereUniqueWithoutCertificateStatusInput>
    updateMany?: Enumerable<StudentSchoolUpdateManyWithWhereWithoutCertificateStatusInput>
    deleteMany?: Enumerable<StudentSchoolScalarWhereInput>
  }

  export type StudentCreateNestedManyWithoutStudentStatusInput = {
    create?: XOR<Enumerable<StudentCreateWithoutStudentStatusInput>, Enumerable<StudentUncheckedCreateWithoutStudentStatusInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutStudentStatusInput>
    createMany?: StudentCreateManyStudentStatusInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type StudentUncheckedCreateNestedManyWithoutStudentStatusInput = {
    create?: XOR<Enumerable<StudentCreateWithoutStudentStatusInput>, Enumerable<StudentUncheckedCreateWithoutStudentStatusInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutStudentStatusInput>
    createMany?: StudentCreateManyStudentStatusInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type StudentUpdateManyWithoutStudentStatusInput = {
    create?: XOR<Enumerable<StudentCreateWithoutStudentStatusInput>, Enumerable<StudentUncheckedCreateWithoutStudentStatusInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutStudentStatusInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutStudentStatusInput>
    createMany?: StudentCreateManyStudentStatusInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutStudentStatusInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutStudentStatusInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type StudentUncheckedUpdateManyWithoutStudentStatusInput = {
    create?: XOR<Enumerable<StudentCreateWithoutStudentStatusInput>, Enumerable<StudentUncheckedCreateWithoutStudentStatusInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutStudentStatusInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutStudentStatusInput>
    createMany?: StudentCreateManyStudentStatusInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutStudentStatusInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutStudentStatusInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type StudentCreateNestedManyWithoutAcceptedTypeInput = {
    create?: XOR<Enumerable<StudentCreateWithoutAcceptedTypeInput>, Enumerable<StudentUncheckedCreateWithoutAcceptedTypeInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutAcceptedTypeInput>
    createMany?: StudentCreateManyAcceptedTypeInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type StudentUncheckedCreateNestedManyWithoutAcceptedTypeInput = {
    create?: XOR<Enumerable<StudentCreateWithoutAcceptedTypeInput>, Enumerable<StudentUncheckedCreateWithoutAcceptedTypeInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutAcceptedTypeInput>
    createMany?: StudentCreateManyAcceptedTypeInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type StudentUpdateManyWithoutAcceptedTypeInput = {
    create?: XOR<Enumerable<StudentCreateWithoutAcceptedTypeInput>, Enumerable<StudentUncheckedCreateWithoutAcceptedTypeInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutAcceptedTypeInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutAcceptedTypeInput>
    createMany?: StudentCreateManyAcceptedTypeInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutAcceptedTypeInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutAcceptedTypeInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type StudentUncheckedUpdateManyWithoutAcceptedTypeInput = {
    create?: XOR<Enumerable<StudentCreateWithoutAcceptedTypeInput>, Enumerable<StudentUncheckedCreateWithoutAcceptedTypeInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutAcceptedTypeInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutAcceptedTypeInput>
    createMany?: StudentCreateManyAcceptedTypeInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutAcceptedTypeInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutAcceptedTypeInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type StudentCreateNestedOneWithoutStudentImageInput = {
    create?: XOR<StudentCreateWithoutStudentImageInput, StudentUncheckedCreateWithoutStudentImageInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentImageInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutStudentImageInput = {
    create?: XOR<StudentCreateWithoutStudentImageInput, StudentUncheckedCreateWithoutStudentImageInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentImageInput
    upsert?: StudentUpsertWithoutStudentImageInput
    connect?: StudentWhereUniqueInput
    update?: XOR<StudentUpdateWithoutStudentImageInput, StudentUncheckedUpdateWithoutStudentImageInput>
  }

  export type AddressCreateNestedManyWithoutProvinceInput = {
    create?: XOR<Enumerable<AddressCreateWithoutProvinceInput>, Enumerable<AddressUncheckedCreateWithoutProvinceInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutProvinceInput>
    createMany?: AddressCreateManyProvinceInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type AddressUncheckedCreateNestedManyWithoutProvinceInput = {
    create?: XOR<Enumerable<AddressCreateWithoutProvinceInput>, Enumerable<AddressUncheckedCreateWithoutProvinceInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutProvinceInput>
    createMany?: AddressCreateManyProvinceInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type AddressUpdateManyWithoutProvinceInput = {
    create?: XOR<Enumerable<AddressCreateWithoutProvinceInput>, Enumerable<AddressUncheckedCreateWithoutProvinceInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutProvinceInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutProvinceInput>
    createMany?: AddressCreateManyProvinceInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutProvinceInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutProvinceInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type AddressUncheckedUpdateManyWithoutProvinceInput = {
    create?: XOR<Enumerable<AddressCreateWithoutProvinceInput>, Enumerable<AddressUncheckedCreateWithoutProvinceInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutProvinceInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutProvinceInput>
    createMany?: AddressCreateManyProvinceInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutProvinceInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutProvinceInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type ProvinceCreateNestedOneWithoutAddressesInput = {
    create?: XOR<ProvinceCreateWithoutAddressesInput, ProvinceUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutAddressesInput
    connect?: ProvinceWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutAddressInput = {
    create?: XOR<StudentCreateWithoutAddressInput, StudentUncheckedCreateWithoutAddressInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAddressInput
    connect?: StudentWhereUniqueInput
  }

  export type ProvinceUpdateOneRequiredWithoutAddressesInput = {
    create?: XOR<ProvinceCreateWithoutAddressesInput, ProvinceUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutAddressesInput
    upsert?: ProvinceUpsertWithoutAddressesInput
    connect?: ProvinceWhereUniqueInput
    update?: XOR<ProvinceUpdateWithoutAddressesInput, ProvinceUncheckedUpdateWithoutAddressesInput>
  }

  export type StudentUpdateOneRequiredWithoutAddressInput = {
    create?: XOR<StudentCreateWithoutAddressInput, StudentUncheckedCreateWithoutAddressInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAddressInput
    upsert?: StudentUpsertWithoutAddressInput
    connect?: StudentWhereUniqueInput
    update?: XOR<StudentUpdateWithoutAddressInput, StudentUncheckedUpdateWithoutAddressInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type OrderTitleCreateWithoutAdministrativeOrdersInput = {
    title: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutOrderTitlesInput
  }

  export type OrderTitleUncheckedCreateWithoutAdministrativeOrdersInput = {
    idOrderTitle?: number
    title: string
    createdAt?: Date | string
    createdBy: number
  }

  export type OrderTitleCreateOrConnectWithoutAdministrativeOrdersInput = {
    where: OrderTitleWhereUniqueInput
    create: XOR<OrderTitleCreateWithoutAdministrativeOrdersInput, OrderTitleUncheckedCreateWithoutAdministrativeOrdersInput>
  }

  export type StudentCreateWithoutAdministrativeOrdersInput = {
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    section: SectionCreateNestedOneWithoutStudentsInput
    yearStudy: YearStudyCreateNestedOneWithoutStudentInput
    studentStatus: StudentStatusCreateNestedOneWithoutStudentsInput
    acceptedType: AcceptedTypeCreateNestedOneWithoutStudentsInput
    studentSchool?: StudentSchoolCreateNestedOneWithoutStudentInput
    studentLevel?: StudentLevelCreateNestedManyWithoutStudentInput
    studentGraduation?: StudentGraduationCreateNestedOneWithoutStudentInput
    nationalInfo?: NationalInfoCreateNestedOneWithoutStudentInput
    studentResponsables?: StudentResponsibleCreateNestedManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateCreateNestedManyWithoutStudentInput
    studentImage?: StudentImageCreateNestedManyWithoutStudentInput
    address?: AddressCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAdministrativeOrdersInput = {
    idStudent?: number
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    sectionId: number
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    registerYearId: number
    studentStatusId: number
    acceptedTypeId: number
    studentSchool?: StudentSchoolUncheckedCreateNestedOneWithoutStudentInput
    studentLevel?: StudentLevelUncheckedCreateNestedManyWithoutStudentInput
    studentGraduation?: StudentGraduationUncheckedCreateNestedOneWithoutStudentInput
    nationalInfo?: NationalInfoUncheckedCreateNestedOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUncheckedCreateNestedManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUncheckedCreateNestedManyWithoutStudentInput
    studentImage?: StudentImageUncheckedCreateNestedManyWithoutStudentInput
    address?: AddressUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAdministrativeOrdersInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAdministrativeOrdersInput, StudentUncheckedCreateWithoutAdministrativeOrdersInput>
  }

  export type UserCreateWithoutAdministrativeOrdersInput = {
    userName: string
    password: string
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    section: SectionCreateNestedOneWithoutUserInput
    passTypes?: PassTypeCreateNestedManyWithoutUserInput
    OrderTitles?: OrderTitleCreateNestedManyWithoutUserInput
    ExitCauses?: ExitCausesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdministrativeOrdersInput = {
    idUser?: number
    userName: string
    password: string
    roleId: number
    sectionId: number
    createdAt?: Date | string
    passTypes?: PassTypeUncheckedCreateNestedManyWithoutUserInput
    OrderTitles?: OrderTitleUncheckedCreateNestedManyWithoutUserInput
    ExitCauses?: ExitCausesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdministrativeOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdministrativeOrdersInput, UserUncheckedCreateWithoutAdministrativeOrdersInput>
  }

  export type OrderTitleUpsertWithoutAdministrativeOrdersInput = {
    update: XOR<OrderTitleUpdateWithoutAdministrativeOrdersInput, OrderTitleUncheckedUpdateWithoutAdministrativeOrdersInput>
    create: XOR<OrderTitleCreateWithoutAdministrativeOrdersInput, OrderTitleUncheckedCreateWithoutAdministrativeOrdersInput>
  }

  export type OrderTitleUpdateWithoutAdministrativeOrdersInput = {
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrderTitlesInput
  }

  export type OrderTitleUncheckedUpdateWithoutAdministrativeOrdersInput = {
    idOrderTitle?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
  }

  export type StudentUpsertWithoutAdministrativeOrdersInput = {
    update: XOR<StudentUpdateWithoutAdministrativeOrdersInput, StudentUncheckedUpdateWithoutAdministrativeOrdersInput>
    create: XOR<StudentCreateWithoutAdministrativeOrdersInput, StudentUncheckedCreateWithoutAdministrativeOrdersInput>
  }

  export type StudentUpdateWithoutAdministrativeOrdersInput = {
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    section?: SectionUpdateOneRequiredWithoutStudentsInput
    yearStudy?: YearStudyUpdateOneRequiredWithoutStudentInput
    studentStatus?: StudentStatusUpdateOneRequiredWithoutStudentsInput
    acceptedType?: AcceptedTypeUpdateOneRequiredWithoutStudentsInput
    studentSchool?: StudentSchoolUpdateOneWithoutStudentInput
    studentLevel?: StudentLevelUpdateManyWithoutStudentInput
    studentGraduation?: StudentGraduationUpdateOneWithoutStudentInput
    nationalInfo?: NationalInfoUpdateOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUpdateManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUpdateManyWithoutStudentInput
    studentImage?: StudentImageUpdateManyWithoutStudentInput
    address?: AddressUpdateOneWithoutStudentInput
  }

  export type StudentUncheckedUpdateWithoutAdministrativeOrdersInput = {
    idStudent?: IntFieldUpdateOperationsInput | number
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    sectionId?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    registerYearId?: IntFieldUpdateOperationsInput | number
    studentStatusId?: IntFieldUpdateOperationsInput | number
    acceptedTypeId?: IntFieldUpdateOperationsInput | number
    studentSchool?: StudentSchoolUncheckedUpdateOneWithoutStudentInput
    studentLevel?: StudentLevelUncheckedUpdateManyWithoutStudentInput
    studentGraduation?: StudentGraduationUncheckedUpdateOneWithoutStudentInput
    nationalInfo?: NationalInfoUncheckedUpdateOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUncheckedUpdateManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUncheckedUpdateManyWithoutStudentInput
    studentImage?: StudentImageUncheckedUpdateManyWithoutStudentInput
    address?: AddressUncheckedUpdateOneWithoutStudentInput
  }

  export type UserUpsertWithoutAdministrativeOrdersInput = {
    update: XOR<UserUpdateWithoutAdministrativeOrdersInput, UserUncheckedUpdateWithoutAdministrativeOrdersInput>
    create: XOR<UserCreateWithoutAdministrativeOrdersInput, UserUncheckedCreateWithoutAdministrativeOrdersInput>
  }

  export type UserUpdateWithoutAdministrativeOrdersInput = {
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersInput
    section?: SectionUpdateOneRequiredWithoutUserInput
    passTypes?: PassTypeUpdateManyWithoutUserInput
    OrderTitles?: OrderTitleUpdateManyWithoutUserInput
    ExitCauses?: ExitCausesUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutAdministrativeOrdersInput = {
    idUser?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    sectionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passTypes?: PassTypeUncheckedUpdateManyWithoutUserInput
    OrderTitles?: OrderTitleUncheckedUpdateManyWithoutUserInput
    ExitCauses?: ExitCausesUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutOrderTitlesInput = {
    userName: string
    password: string
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    section: SectionCreateNestedOneWithoutUserInput
    passTypes?: PassTypeCreateNestedManyWithoutUserInput
    administrativeOrders?: AdministrativeOrderCreateNestedManyWithoutUserInput
    ExitCauses?: ExitCausesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrderTitlesInput = {
    idUser?: number
    userName: string
    password: string
    roleId: number
    sectionId: number
    createdAt?: Date | string
    passTypes?: PassTypeUncheckedCreateNestedManyWithoutUserInput
    administrativeOrders?: AdministrativeOrderUncheckedCreateNestedManyWithoutUserInput
    ExitCauses?: ExitCausesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrderTitlesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrderTitlesInput, UserUncheckedCreateWithoutOrderTitlesInput>
  }

  export type AdministrativeOrderCreateWithoutOrderTitleInput = {
    orderNumber: number
    orderDescription: string
    orderYear: string
    orderLevel: number
    orderDate: Date | string
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutAdministrativeOrdersInput
    user: UserCreateNestedOneWithoutAdministrativeOrdersInput
  }

  export type AdministrativeOrderUncheckedCreateWithoutOrderTitleInput = {
    idAdministrative?: number
    orderNumber: number
    orderDescription: string
    orderYear: string
    orderLevel: number
    studentId: number
    orderDate: Date | string
    createdBy: number
    createdAt?: Date | string
  }

  export type AdministrativeOrderCreateOrConnectWithoutOrderTitleInput = {
    where: AdministrativeOrderWhereUniqueInput
    create: XOR<AdministrativeOrderCreateWithoutOrderTitleInput, AdministrativeOrderUncheckedCreateWithoutOrderTitleInput>
  }

  export type AdministrativeOrderCreateManyOrderTitleInputEnvelope = {
    data: Enumerable<AdministrativeOrderCreateManyOrderTitleInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOrderTitlesInput = {
    update: XOR<UserUpdateWithoutOrderTitlesInput, UserUncheckedUpdateWithoutOrderTitlesInput>
    create: XOR<UserCreateWithoutOrderTitlesInput, UserUncheckedCreateWithoutOrderTitlesInput>
  }

  export type UserUpdateWithoutOrderTitlesInput = {
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersInput
    section?: SectionUpdateOneRequiredWithoutUserInput
    passTypes?: PassTypeUpdateManyWithoutUserInput
    administrativeOrders?: AdministrativeOrderUpdateManyWithoutUserInput
    ExitCauses?: ExitCausesUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutOrderTitlesInput = {
    idUser?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    sectionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passTypes?: PassTypeUncheckedUpdateManyWithoutUserInput
    administrativeOrders?: AdministrativeOrderUncheckedUpdateManyWithoutUserInput
    ExitCauses?: ExitCausesUncheckedUpdateManyWithoutUserInput
  }

  export type AdministrativeOrderUpsertWithWhereUniqueWithoutOrderTitleInput = {
    where: AdministrativeOrderWhereUniqueInput
    update: XOR<AdministrativeOrderUpdateWithoutOrderTitleInput, AdministrativeOrderUncheckedUpdateWithoutOrderTitleInput>
    create: XOR<AdministrativeOrderCreateWithoutOrderTitleInput, AdministrativeOrderUncheckedCreateWithoutOrderTitleInput>
  }

  export type AdministrativeOrderUpdateWithWhereUniqueWithoutOrderTitleInput = {
    where: AdministrativeOrderWhereUniqueInput
    data: XOR<AdministrativeOrderUpdateWithoutOrderTitleInput, AdministrativeOrderUncheckedUpdateWithoutOrderTitleInput>
  }

  export type AdministrativeOrderUpdateManyWithWhereWithoutOrderTitleInput = {
    where: AdministrativeOrderScalarWhereInput
    data: XOR<AdministrativeOrderUpdateManyMutationInput, AdministrativeOrderUncheckedUpdateManyWithoutAdministrativeOrdersInput>
  }

  export type AdministrativeOrderScalarWhereInput = {
    AND?: Enumerable<AdministrativeOrderScalarWhereInput>
    OR?: Enumerable<AdministrativeOrderScalarWhereInput>
    NOT?: Enumerable<AdministrativeOrderScalarWhereInput>
    idAdministrative?: IntFilter | number
    orderTitleId?: IntFilter | number
    orderNumber?: IntFilter | number
    orderDescription?: StringFilter | string
    orderYear?: StringFilter | string
    orderLevel?: IntFilter | number
    studentId?: IntFilter | number
    orderDate?: DateTimeFilter | Date | string
    createdBy?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
  }

  export type UserCreateWithoutExitCausesInput = {
    userName: string
    password: string
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    section: SectionCreateNestedOneWithoutUserInput
    passTypes?: PassTypeCreateNestedManyWithoutUserInput
    administrativeOrders?: AdministrativeOrderCreateNestedManyWithoutUserInput
    OrderTitles?: OrderTitleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutExitCausesInput = {
    idUser?: number
    userName: string
    password: string
    roleId: number
    sectionId: number
    createdAt?: Date | string
    passTypes?: PassTypeUncheckedCreateNestedManyWithoutUserInput
    administrativeOrders?: AdministrativeOrderUncheckedCreateNestedManyWithoutUserInput
    OrderTitles?: OrderTitleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutExitCausesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExitCausesInput, UserUncheckedCreateWithoutExitCausesInput>
  }

  export type UserUpsertWithoutExitCausesInput = {
    update: XOR<UserUpdateWithoutExitCausesInput, UserUncheckedUpdateWithoutExitCausesInput>
    create: XOR<UserCreateWithoutExitCausesInput, UserUncheckedCreateWithoutExitCausesInput>
  }

  export type UserUpdateWithoutExitCausesInput = {
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersInput
    section?: SectionUpdateOneRequiredWithoutUserInput
    passTypes?: PassTypeUpdateManyWithoutUserInput
    administrativeOrders?: AdministrativeOrderUpdateManyWithoutUserInput
    OrderTitles?: OrderTitleUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutExitCausesInput = {
    idUser?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    sectionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passTypes?: PassTypeUncheckedUpdateManyWithoutUserInput
    administrativeOrders?: AdministrativeOrderUncheckedUpdateManyWithoutUserInput
    OrderTitles?: OrderTitleUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutPassTypesInput = {
    userName: string
    password: string
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    section: SectionCreateNestedOneWithoutUserInput
    administrativeOrders?: AdministrativeOrderCreateNestedManyWithoutUserInput
    OrderTitles?: OrderTitleCreateNestedManyWithoutUserInput
    ExitCauses?: ExitCausesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPassTypesInput = {
    idUser?: number
    userName: string
    password: string
    roleId: number
    sectionId: number
    createdAt?: Date | string
    administrativeOrders?: AdministrativeOrderUncheckedCreateNestedManyWithoutUserInput
    OrderTitles?: OrderTitleUncheckedCreateNestedManyWithoutUserInput
    ExitCauses?: ExitCausesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPassTypesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPassTypesInput, UserUncheckedCreateWithoutPassTypesInput>
  }

  export type UserUpsertWithoutPassTypesInput = {
    update: XOR<UserUpdateWithoutPassTypesInput, UserUncheckedUpdateWithoutPassTypesInput>
    create: XOR<UserCreateWithoutPassTypesInput, UserUncheckedCreateWithoutPassTypesInput>
  }

  export type UserUpdateWithoutPassTypesInput = {
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersInput
    section?: SectionUpdateOneRequiredWithoutUserInput
    administrativeOrders?: AdministrativeOrderUpdateManyWithoutUserInput
    OrderTitles?: OrderTitleUpdateManyWithoutUserInput
    ExitCauses?: ExitCausesUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutPassTypesInput = {
    idUser?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    sectionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    administrativeOrders?: AdministrativeOrderUncheckedUpdateManyWithoutUserInput
    OrderTitles?: OrderTitleUncheckedUpdateManyWithoutUserInput
    ExitCauses?: ExitCausesUncheckedUpdateManyWithoutUserInput
  }

  export type RoleCreateWithoutUsersInput = {
    roleName: string
    createdAt?: Date | string
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    idRole?: number
    roleName: string
    createdAt?: Date | string
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type SectionCreateWithoutUserInput = {
    sectionName: string
    code: string
    englishName: string
    students?: StudentCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutUserInput = {
    idSection?: number
    sectionName: string
    code: string
    englishName: string
    students?: StudentUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutUserInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutUserInput, SectionUncheckedCreateWithoutUserInput>
  }

  export type PassTypeCreateWithoutUserInput = {
    passName: string
    createdAt?: Date | string
  }

  export type PassTypeUncheckedCreateWithoutUserInput = {
    idPassType?: number
    passName: string
    createdAt?: Date | string
  }

  export type PassTypeCreateOrConnectWithoutUserInput = {
    where: PassTypeWhereUniqueInput
    create: XOR<PassTypeCreateWithoutUserInput, PassTypeUncheckedCreateWithoutUserInput>
  }

  export type PassTypeCreateManyUserInputEnvelope = {
    data: Enumerable<PassTypeCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type AdministrativeOrderCreateWithoutUserInput = {
    orderNumber: number
    orderDescription: string
    orderYear: string
    orderLevel: number
    orderDate: Date | string
    createdAt?: Date | string
    orderTitle: OrderTitleCreateNestedOneWithoutAdministrativeOrdersInput
    student: StudentCreateNestedOneWithoutAdministrativeOrdersInput
  }

  export type AdministrativeOrderUncheckedCreateWithoutUserInput = {
    idAdministrative?: number
    orderTitleId: number
    orderNumber: number
    orderDescription: string
    orderYear: string
    orderLevel: number
    studentId: number
    orderDate: Date | string
    createdAt?: Date | string
  }

  export type AdministrativeOrderCreateOrConnectWithoutUserInput = {
    where: AdministrativeOrderWhereUniqueInput
    create: XOR<AdministrativeOrderCreateWithoutUserInput, AdministrativeOrderUncheckedCreateWithoutUserInput>
  }

  export type AdministrativeOrderCreateManyUserInputEnvelope = {
    data: Enumerable<AdministrativeOrderCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type OrderTitleCreateWithoutUserInput = {
    title: string
    createdAt?: Date | string
    administrativeOrders?: AdministrativeOrderCreateNestedManyWithoutOrderTitleInput
  }

  export type OrderTitleUncheckedCreateWithoutUserInput = {
    idOrderTitle?: number
    title: string
    createdAt?: Date | string
    administrativeOrders?: AdministrativeOrderUncheckedCreateNestedManyWithoutOrderTitleInput
  }

  export type OrderTitleCreateOrConnectWithoutUserInput = {
    where: OrderTitleWhereUniqueInput
    create: XOR<OrderTitleCreateWithoutUserInput, OrderTitleUncheckedCreateWithoutUserInput>
  }

  export type OrderTitleCreateManyUserInputEnvelope = {
    data: Enumerable<OrderTitleCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ExitCausesCreateWithoutUserInput = {
    exitCausesTitle: string
    createdAt?: Date | string
  }

  export type ExitCausesUncheckedCreateWithoutUserInput = {
    idExitCauses?: number
    exitCausesTitle: string
    createdAt?: Date | string
  }

  export type ExitCausesCreateOrConnectWithoutUserInput = {
    where: ExitCausesWhereUniqueInput
    create: XOR<ExitCausesCreateWithoutUserInput, ExitCausesUncheckedCreateWithoutUserInput>
  }

  export type ExitCausesCreateManyUserInputEnvelope = {
    data: Enumerable<ExitCausesCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    roleName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    idRole?: IntFieldUpdateOperationsInput | number
    roleName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionUpsertWithoutUserInput = {
    update: XOR<SectionUpdateWithoutUserInput, SectionUncheckedUpdateWithoutUserInput>
    create: XOR<SectionCreateWithoutUserInput, SectionUncheckedCreateWithoutUserInput>
  }

  export type SectionUpdateWithoutUserInput = {
    sectionName?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    students?: StudentUpdateManyWithoutSectionInput
  }

  export type SectionUncheckedUpdateWithoutUserInput = {
    idSection?: IntFieldUpdateOperationsInput | number
    sectionName?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    students?: StudentUncheckedUpdateManyWithoutSectionInput
  }

  export type PassTypeUpsertWithWhereUniqueWithoutUserInput = {
    where: PassTypeWhereUniqueInput
    update: XOR<PassTypeUpdateWithoutUserInput, PassTypeUncheckedUpdateWithoutUserInput>
    create: XOR<PassTypeCreateWithoutUserInput, PassTypeUncheckedCreateWithoutUserInput>
  }

  export type PassTypeUpdateWithWhereUniqueWithoutUserInput = {
    where: PassTypeWhereUniqueInput
    data: XOR<PassTypeUpdateWithoutUserInput, PassTypeUncheckedUpdateWithoutUserInput>
  }

  export type PassTypeUpdateManyWithWhereWithoutUserInput = {
    where: PassTypeScalarWhereInput
    data: XOR<PassTypeUpdateManyMutationInput, PassTypeUncheckedUpdateManyWithoutPassTypesInput>
  }

  export type PassTypeScalarWhereInput = {
    AND?: Enumerable<PassTypeScalarWhereInput>
    OR?: Enumerable<PassTypeScalarWhereInput>
    NOT?: Enumerable<PassTypeScalarWhereInput>
    idPassType?: IntFilter | number
    passName?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    createdBy?: IntFilter | number
  }

  export type AdministrativeOrderUpsertWithWhereUniqueWithoutUserInput = {
    where: AdministrativeOrderWhereUniqueInput
    update: XOR<AdministrativeOrderUpdateWithoutUserInput, AdministrativeOrderUncheckedUpdateWithoutUserInput>
    create: XOR<AdministrativeOrderCreateWithoutUserInput, AdministrativeOrderUncheckedCreateWithoutUserInput>
  }

  export type AdministrativeOrderUpdateWithWhereUniqueWithoutUserInput = {
    where: AdministrativeOrderWhereUniqueInput
    data: XOR<AdministrativeOrderUpdateWithoutUserInput, AdministrativeOrderUncheckedUpdateWithoutUserInput>
  }

  export type AdministrativeOrderUpdateManyWithWhereWithoutUserInput = {
    where: AdministrativeOrderScalarWhereInput
    data: XOR<AdministrativeOrderUpdateManyMutationInput, AdministrativeOrderUncheckedUpdateManyWithoutAdministrativeOrdersInput>
  }

  export type OrderTitleUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderTitleWhereUniqueInput
    update: XOR<OrderTitleUpdateWithoutUserInput, OrderTitleUncheckedUpdateWithoutUserInput>
    create: XOR<OrderTitleCreateWithoutUserInput, OrderTitleUncheckedCreateWithoutUserInput>
  }

  export type OrderTitleUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderTitleWhereUniqueInput
    data: XOR<OrderTitleUpdateWithoutUserInput, OrderTitleUncheckedUpdateWithoutUserInput>
  }

  export type OrderTitleUpdateManyWithWhereWithoutUserInput = {
    where: OrderTitleScalarWhereInput
    data: XOR<OrderTitleUpdateManyMutationInput, OrderTitleUncheckedUpdateManyWithoutOrderTitlesInput>
  }

  export type OrderTitleScalarWhereInput = {
    AND?: Enumerable<OrderTitleScalarWhereInput>
    OR?: Enumerable<OrderTitleScalarWhereInput>
    NOT?: Enumerable<OrderTitleScalarWhereInput>
    idOrderTitle?: IntFilter | number
    title?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    createdBy?: IntFilter | number
  }

  export type ExitCausesUpsertWithWhereUniqueWithoutUserInput = {
    where: ExitCausesWhereUniqueInput
    update: XOR<ExitCausesUpdateWithoutUserInput, ExitCausesUncheckedUpdateWithoutUserInput>
    create: XOR<ExitCausesCreateWithoutUserInput, ExitCausesUncheckedCreateWithoutUserInput>
  }

  export type ExitCausesUpdateWithWhereUniqueWithoutUserInput = {
    where: ExitCausesWhereUniqueInput
    data: XOR<ExitCausesUpdateWithoutUserInput, ExitCausesUncheckedUpdateWithoutUserInput>
  }

  export type ExitCausesUpdateManyWithWhereWithoutUserInput = {
    where: ExitCausesScalarWhereInput
    data: XOR<ExitCausesUpdateManyMutationInput, ExitCausesUncheckedUpdateManyWithoutExitCausesInput>
  }

  export type ExitCausesScalarWhereInput = {
    AND?: Enumerable<ExitCausesScalarWhereInput>
    OR?: Enumerable<ExitCausesScalarWhereInput>
    NOT?: Enumerable<ExitCausesScalarWhereInput>
    idExitCauses?: IntFilter | number
    exitCausesTitle?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    createdBy?: IntFilter | number
  }

  export type UserCreateWithoutRoleInput = {
    userName: string
    password: string
    createdAt?: Date | string
    section: SectionCreateNestedOneWithoutUserInput
    passTypes?: PassTypeCreateNestedManyWithoutUserInput
    administrativeOrders?: AdministrativeOrderCreateNestedManyWithoutUserInput
    OrderTitles?: OrderTitleCreateNestedManyWithoutUserInput
    ExitCauses?: ExitCausesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    idUser?: number
    userName: string
    password: string
    sectionId: number
    createdAt?: Date | string
    passTypes?: PassTypeUncheckedCreateNestedManyWithoutUserInput
    administrativeOrders?: AdministrativeOrderUncheckedCreateNestedManyWithoutUserInput
    OrderTitles?: OrderTitleUncheckedCreateNestedManyWithoutUserInput
    ExitCauses?: ExitCausesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: Enumerable<UserCreateManyRoleInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    idUser?: IntFilter | number
    userName?: StringFilter | string
    password?: StringFilter | string
    roleId?: IntFilter | number
    sectionId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
  }

  export type StudentCreateWithoutSectionInput = {
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    yearStudy: YearStudyCreateNestedOneWithoutStudentInput
    studentStatus: StudentStatusCreateNestedOneWithoutStudentsInput
    acceptedType: AcceptedTypeCreateNestedOneWithoutStudentsInput
    administrativeOrders?: AdministrativeOrderCreateNestedManyWithoutStudentInput
    studentSchool?: StudentSchoolCreateNestedOneWithoutStudentInput
    studentLevel?: StudentLevelCreateNestedManyWithoutStudentInput
    studentGraduation?: StudentGraduationCreateNestedOneWithoutStudentInput
    nationalInfo?: NationalInfoCreateNestedOneWithoutStudentInput
    studentResponsables?: StudentResponsibleCreateNestedManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateCreateNestedManyWithoutStudentInput
    studentImage?: StudentImageCreateNestedManyWithoutStudentInput
    address?: AddressCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutSectionInput = {
    idStudent?: number
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    registerYearId: number
    studentStatusId: number
    acceptedTypeId: number
    administrativeOrders?: AdministrativeOrderUncheckedCreateNestedManyWithoutStudentInput
    studentSchool?: StudentSchoolUncheckedCreateNestedOneWithoutStudentInput
    studentLevel?: StudentLevelUncheckedCreateNestedManyWithoutStudentInput
    studentGraduation?: StudentGraduationUncheckedCreateNestedOneWithoutStudentInput
    nationalInfo?: NationalInfoUncheckedCreateNestedOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUncheckedCreateNestedManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUncheckedCreateNestedManyWithoutStudentInput
    studentImage?: StudentImageUncheckedCreateNestedManyWithoutStudentInput
    address?: AddressUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutSectionInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutSectionInput, StudentUncheckedCreateWithoutSectionInput>
  }

  export type StudentCreateManySectionInputEnvelope = {
    data: Enumerable<StudentCreateManySectionInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutSectionInput = {
    userName: string
    password: string
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    passTypes?: PassTypeCreateNestedManyWithoutUserInput
    administrativeOrders?: AdministrativeOrderCreateNestedManyWithoutUserInput
    OrderTitles?: OrderTitleCreateNestedManyWithoutUserInput
    ExitCauses?: ExitCausesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSectionInput = {
    idUser?: number
    userName: string
    password: string
    roleId: number
    createdAt?: Date | string
    passTypes?: PassTypeUncheckedCreateNestedManyWithoutUserInput
    administrativeOrders?: AdministrativeOrderUncheckedCreateNestedManyWithoutUserInput
    OrderTitles?: OrderTitleUncheckedCreateNestedManyWithoutUserInput
    ExitCauses?: ExitCausesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSectionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSectionInput, UserUncheckedCreateWithoutSectionInput>
  }

  export type UserCreateManySectionInputEnvelope = {
    data: Enumerable<UserCreateManySectionInput>
    skipDuplicates?: boolean
  }

  export type StudentUpsertWithWhereUniqueWithoutSectionInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutSectionInput, StudentUncheckedUpdateWithoutSectionInput>
    create: XOR<StudentCreateWithoutSectionInput, StudentUncheckedCreateWithoutSectionInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutSectionInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutSectionInput, StudentUncheckedUpdateWithoutSectionInput>
  }

  export type StudentUpdateManyWithWhereWithoutSectionInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutStudentsInput>
  }

  export type StudentScalarWhereInput = {
    AND?: Enumerable<StudentScalarWhereInput>
    OR?: Enumerable<StudentScalarWhereInput>
    NOT?: Enumerable<StudentScalarWhereInput>
    idStudent?: IntFilter | number
    studentName?: StringFilter | string
    englishName?: StringFilter | string
    mail?: StringFilter | string
    password?: StringFilter | string
    dob?: StringFilter | string
    sectionId?: IntFilter | number
    nationality?: StringFilter | string
    phone?: StringFilter | string
    gender?: BoolFilter | boolean
    studyType?: BoolFilter | boolean
    relationships?: BoolFilter | boolean
    note?: StringFilter | string
    religion?: StringFilter | string
    motherName?: StringFilter | string
    collegeNumber?: StringFilter | string
    registerYearId?: IntFilter | number
    studentStatusId?: IntFilter | number
    acceptedTypeId?: IntFilter | number
  }

  export type UserUpsertWithWhereUniqueWithoutSectionInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutSectionInput, UserUncheckedUpdateWithoutSectionInput>
    create: XOR<UserCreateWithoutSectionInput, UserUncheckedCreateWithoutSectionInput>
  }

  export type UserUpdateWithWhereUniqueWithoutSectionInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutSectionInput, UserUncheckedUpdateWithoutSectionInput>
  }

  export type UserUpdateManyWithWhereWithoutSectionInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUserInput>
  }

  export type SectionCreateWithoutStudentsInput = {
    sectionName: string
    code: string
    englishName: string
    User?: UserCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutStudentsInput = {
    idSection?: number
    sectionName: string
    code: string
    englishName: string
    User?: UserUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutStudentsInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutStudentsInput, SectionUncheckedCreateWithoutStudentsInput>
  }

  export type YearStudyCreateWithoutStudentInput = {
    year: string
    currentYear: boolean
    StudentLevel?: StudentLevelCreateNestedManyWithoutYearStudyInput
  }

  export type YearStudyUncheckedCreateWithoutStudentInput = {
    idYearStudy?: number
    year: string
    currentYear: boolean
    StudentLevel?: StudentLevelUncheckedCreateNestedManyWithoutYearStudyInput
  }

  export type YearStudyCreateOrConnectWithoutStudentInput = {
    where: YearStudyWhereUniqueInput
    create: XOR<YearStudyCreateWithoutStudentInput, YearStudyUncheckedCreateWithoutStudentInput>
  }

  export type StudentStatusCreateWithoutStudentsInput = {
    statusName: string
  }

  export type StudentStatusUncheckedCreateWithoutStudentsInput = {
    idStudentStatus?: number
    statusName: string
  }

  export type StudentStatusCreateOrConnectWithoutStudentsInput = {
    where: StudentStatusWhereUniqueInput
    create: XOR<StudentStatusCreateWithoutStudentsInput, StudentStatusUncheckedCreateWithoutStudentsInput>
  }

  export type AcceptedTypeCreateWithoutStudentsInput = {
    acceptedName: string
  }

  export type AcceptedTypeUncheckedCreateWithoutStudentsInput = {
    idAcceptedType?: number
    acceptedName: string
  }

  export type AcceptedTypeCreateOrConnectWithoutStudentsInput = {
    where: AcceptedTypeWhereUniqueInput
    create: XOR<AcceptedTypeCreateWithoutStudentsInput, AcceptedTypeUncheckedCreateWithoutStudentsInput>
  }

  export type AdministrativeOrderCreateWithoutStudentInput = {
    orderNumber: number
    orderDescription: string
    orderYear: string
    orderLevel: number
    orderDate: Date | string
    createdAt?: Date | string
    orderTitle: OrderTitleCreateNestedOneWithoutAdministrativeOrdersInput
    user: UserCreateNestedOneWithoutAdministrativeOrdersInput
  }

  export type AdministrativeOrderUncheckedCreateWithoutStudentInput = {
    idAdministrative?: number
    orderTitleId: number
    orderNumber: number
    orderDescription: string
    orderYear: string
    orderLevel: number
    orderDate: Date | string
    createdBy: number
    createdAt?: Date | string
  }

  export type AdministrativeOrderCreateOrConnectWithoutStudentInput = {
    where: AdministrativeOrderWhereUniqueInput
    create: XOR<AdministrativeOrderCreateWithoutStudentInput, AdministrativeOrderUncheckedCreateWithoutStudentInput>
  }

  export type AdministrativeOrderCreateManyStudentInputEnvelope = {
    data: Enumerable<AdministrativeOrderCreateManyStudentInput>
    skipDuplicates?: boolean
  }

  export type StudentSchoolCreateWithoutStudentInput = {
    schoolName: string
    graduationDate: string
    documentDate: string
    totalMarks: number
    average: number
    documentNumber: number
    lessonCount: number
    Directorate: string
    certificateStatusDescription: string
    createdAt?: Date | string
    studySubCategory: StudySubCategoryCreateNestedOneWithoutStudentSchoolInput
    certificateStatus: CertificateStatusCreateNestedOneWithoutStudentSchoolInput
  }

  export type StudentSchoolUncheckedCreateWithoutStudentInput = {
    idStudentSchool?: number
    schoolName: string
    graduationDate: string
    documentDate: string
    totalMarks: number
    average: number
    documentNumber: number
    lessonCount: number
    Directorate: string
    studySubCategoryId: number
    certificateStatusId: number
    certificateStatusDescription: string
    createdAt?: Date | string
  }

  export type StudentSchoolCreateOrConnectWithoutStudentInput = {
    where: StudentSchoolWhereUniqueInput
    create: XOR<StudentSchoolCreateWithoutStudentInput, StudentSchoolUncheckedCreateWithoutStudentInput>
  }

  export type StudentLevelCreateWithoutStudentInput = {
    level: number
    class: string
    yearStudy: YearStudyCreateNestedOneWithoutStudentLevelInput
  }

  export type StudentLevelUncheckedCreateWithoutStudentInput = {
    idStudentLevel?: number
    level: number
    class: string
    yearStudyId: number
  }

  export type StudentLevelCreateOrConnectWithoutStudentInput = {
    where: StudentLevelWhereUniqueInput
    create: XOR<StudentLevelCreateWithoutStudentInput, StudentLevelUncheckedCreateWithoutStudentInput>
  }

  export type StudentLevelCreateManyStudentInputEnvelope = {
    data: Enumerable<StudentLevelCreateManyStudentInput>
    skipDuplicates?: boolean
  }

  export type StudentGraduationCreateWithoutStudentInput = {
    graduationDate: string
  }

  export type StudentGraduationUncheckedCreateWithoutStudentInput = {
    idStudentGraduation?: number
    graduationDate: string
  }

  export type StudentGraduationCreateOrConnectWithoutStudentInput = {
    where: StudentGraduationWhereUniqueInput
    create: XOR<StudentGraduationCreateWithoutStudentInput, StudentGraduationUncheckedCreateWithoutStudentInput>
  }

  export type NationalInfoCreateWithoutStudentInput = {
    nationalNumber: string
    issueNumber: string
    issuePlace: string
  }

  export type NationalInfoUncheckedCreateWithoutStudentInput = {
    idNationalInfo?: number
    nationalNumber: string
    issueNumber: string
    issuePlace: string
  }

  export type NationalInfoCreateOrConnectWithoutStudentInput = {
    where: NationalInfoWhereUniqueInput
    create: XOR<NationalInfoCreateWithoutStudentInput, NationalInfoUncheckedCreateWithoutStudentInput>
  }

  export type StudentResponsibleCreateWithoutStudentInput = {
    responsibleName: string
    responsiblePhone: string
  }

  export type StudentResponsibleUncheckedCreateWithoutStudentInput = {
    idStudentResponsible?: number
    responsibleName: string
    responsiblePhone: string
  }

  export type StudentResponsibleCreateOrConnectWithoutStudentInput = {
    where: StudentResponsibleWhereUniqueInput
    create: XOR<StudentResponsibleCreateWithoutStudentInput, StudentResponsibleUncheckedCreateWithoutStudentInput>
  }

  export type StudentResponsibleCreateManyStudentInputEnvelope = {
    data: Enumerable<StudentResponsibleCreateManyStudentInput>
    skipDuplicates?: boolean
  }

  export type NationalityCertificateCreateWithoutStudentInput = {
    nationalityNumber: string
    nationalityIssue: string
    nationalityPlace: string
  }

  export type NationalityCertificateUncheckedCreateWithoutStudentInput = {
    idNationalityCertificate?: number
    nationalityNumber: string
    nationalityIssue: string
    nationalityPlace: string
  }

  export type NationalityCertificateCreateOrConnectWithoutStudentInput = {
    where: NationalityCertificateWhereUniqueInput
    create: XOR<NationalityCertificateCreateWithoutStudentInput, NationalityCertificateUncheckedCreateWithoutStudentInput>
  }

  export type NationalityCertificateCreateManyStudentInputEnvelope = {
    data: Enumerable<NationalityCertificateCreateManyStudentInput>
    skipDuplicates?: boolean
  }

  export type StudentImageCreateWithoutStudentInput = {
    imagePath: string
  }

  export type StudentImageUncheckedCreateWithoutStudentInput = {
    idStudentImage?: number
    imagePath: string
  }

  export type StudentImageCreateOrConnectWithoutStudentInput = {
    where: StudentImageWhereUniqueInput
    create: XOR<StudentImageCreateWithoutStudentInput, StudentImageUncheckedCreateWithoutStudentInput>
  }

  export type StudentImageCreateManyStudentInputEnvelope = {
    data: Enumerable<StudentImageCreateManyStudentInput>
    skipDuplicates?: boolean
  }

  export type AddressCreateWithoutStudentInput = {
    district: string
    avenue: string
    houseNumber: string
    streetNumber: string
    province: ProvinceCreateNestedOneWithoutAddressesInput
  }

  export type AddressUncheckedCreateWithoutStudentInput = {
    idAddress?: number
    provinceId: number
    district: string
    avenue: string
    houseNumber: string
    streetNumber: string
  }

  export type AddressCreateOrConnectWithoutStudentInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutStudentInput, AddressUncheckedCreateWithoutStudentInput>
  }

  export type SectionUpsertWithoutStudentsInput = {
    update: XOR<SectionUpdateWithoutStudentsInput, SectionUncheckedUpdateWithoutStudentsInput>
    create: XOR<SectionCreateWithoutStudentsInput, SectionUncheckedCreateWithoutStudentsInput>
  }

  export type SectionUpdateWithoutStudentsInput = {
    sectionName?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateManyWithoutSectionInput
  }

  export type SectionUncheckedUpdateWithoutStudentsInput = {
    idSection?: IntFieldUpdateOperationsInput | number
    sectionName?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    User?: UserUncheckedUpdateManyWithoutSectionInput
  }

  export type YearStudyUpsertWithoutStudentInput = {
    update: XOR<YearStudyUpdateWithoutStudentInput, YearStudyUncheckedUpdateWithoutStudentInput>
    create: XOR<YearStudyCreateWithoutStudentInput, YearStudyUncheckedCreateWithoutStudentInput>
  }

  export type YearStudyUpdateWithoutStudentInput = {
    year?: StringFieldUpdateOperationsInput | string
    currentYear?: BoolFieldUpdateOperationsInput | boolean
    StudentLevel?: StudentLevelUpdateManyWithoutYearStudyInput
  }

  export type YearStudyUncheckedUpdateWithoutStudentInput = {
    idYearStudy?: IntFieldUpdateOperationsInput | number
    year?: StringFieldUpdateOperationsInput | string
    currentYear?: BoolFieldUpdateOperationsInput | boolean
    StudentLevel?: StudentLevelUncheckedUpdateManyWithoutYearStudyInput
  }

  export type StudentStatusUpsertWithoutStudentsInput = {
    update: XOR<StudentStatusUpdateWithoutStudentsInput, StudentStatusUncheckedUpdateWithoutStudentsInput>
    create: XOR<StudentStatusCreateWithoutStudentsInput, StudentStatusUncheckedCreateWithoutStudentsInput>
  }

  export type StudentStatusUpdateWithoutStudentsInput = {
    statusName?: StringFieldUpdateOperationsInput | string
  }

  export type StudentStatusUncheckedUpdateWithoutStudentsInput = {
    idStudentStatus?: IntFieldUpdateOperationsInput | number
    statusName?: StringFieldUpdateOperationsInput | string
  }

  export type AcceptedTypeUpsertWithoutStudentsInput = {
    update: XOR<AcceptedTypeUpdateWithoutStudentsInput, AcceptedTypeUncheckedUpdateWithoutStudentsInput>
    create: XOR<AcceptedTypeCreateWithoutStudentsInput, AcceptedTypeUncheckedCreateWithoutStudentsInput>
  }

  export type AcceptedTypeUpdateWithoutStudentsInput = {
    acceptedName?: StringFieldUpdateOperationsInput | string
  }

  export type AcceptedTypeUncheckedUpdateWithoutStudentsInput = {
    idAcceptedType?: IntFieldUpdateOperationsInput | number
    acceptedName?: StringFieldUpdateOperationsInput | string
  }

  export type AdministrativeOrderUpsertWithWhereUniqueWithoutStudentInput = {
    where: AdministrativeOrderWhereUniqueInput
    update: XOR<AdministrativeOrderUpdateWithoutStudentInput, AdministrativeOrderUncheckedUpdateWithoutStudentInput>
    create: XOR<AdministrativeOrderCreateWithoutStudentInput, AdministrativeOrderUncheckedCreateWithoutStudentInput>
  }

  export type AdministrativeOrderUpdateWithWhereUniqueWithoutStudentInput = {
    where: AdministrativeOrderWhereUniqueInput
    data: XOR<AdministrativeOrderUpdateWithoutStudentInput, AdministrativeOrderUncheckedUpdateWithoutStudentInput>
  }

  export type AdministrativeOrderUpdateManyWithWhereWithoutStudentInput = {
    where: AdministrativeOrderScalarWhereInput
    data: XOR<AdministrativeOrderUpdateManyMutationInput, AdministrativeOrderUncheckedUpdateManyWithoutAdministrativeOrdersInput>
  }

  export type StudentSchoolUpsertWithoutStudentInput = {
    update: XOR<StudentSchoolUpdateWithoutStudentInput, StudentSchoolUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentSchoolCreateWithoutStudentInput, StudentSchoolUncheckedCreateWithoutStudentInput>
  }

  export type StudentSchoolUpdateWithoutStudentInput = {
    schoolName?: StringFieldUpdateOperationsInput | string
    graduationDate?: StringFieldUpdateOperationsInput | string
    documentDate?: StringFieldUpdateOperationsInput | string
    totalMarks?: IntFieldUpdateOperationsInput | number
    average?: FloatFieldUpdateOperationsInput | number
    documentNumber?: IntFieldUpdateOperationsInput | number
    lessonCount?: IntFieldUpdateOperationsInput | number
    Directorate?: StringFieldUpdateOperationsInput | string
    certificateStatusDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studySubCategory?: StudySubCategoryUpdateOneRequiredWithoutStudentSchoolInput
    certificateStatus?: CertificateStatusUpdateOneRequiredWithoutStudentSchoolInput
  }

  export type StudentSchoolUncheckedUpdateWithoutStudentInput = {
    idStudentSchool?: IntFieldUpdateOperationsInput | number
    schoolName?: StringFieldUpdateOperationsInput | string
    graduationDate?: StringFieldUpdateOperationsInput | string
    documentDate?: StringFieldUpdateOperationsInput | string
    totalMarks?: IntFieldUpdateOperationsInput | number
    average?: FloatFieldUpdateOperationsInput | number
    documentNumber?: IntFieldUpdateOperationsInput | number
    lessonCount?: IntFieldUpdateOperationsInput | number
    Directorate?: StringFieldUpdateOperationsInput | string
    studySubCategoryId?: IntFieldUpdateOperationsInput | number
    certificateStatusId?: IntFieldUpdateOperationsInput | number
    certificateStatusDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentLevelUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentLevelWhereUniqueInput
    update: XOR<StudentLevelUpdateWithoutStudentInput, StudentLevelUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentLevelCreateWithoutStudentInput, StudentLevelUncheckedCreateWithoutStudentInput>
  }

  export type StudentLevelUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentLevelWhereUniqueInput
    data: XOR<StudentLevelUpdateWithoutStudentInput, StudentLevelUncheckedUpdateWithoutStudentInput>
  }

  export type StudentLevelUpdateManyWithWhereWithoutStudentInput = {
    where: StudentLevelScalarWhereInput
    data: XOR<StudentLevelUpdateManyMutationInput, StudentLevelUncheckedUpdateManyWithoutStudentLevelInput>
  }

  export type StudentLevelScalarWhereInput = {
    AND?: Enumerable<StudentLevelScalarWhereInput>
    OR?: Enumerable<StudentLevelScalarWhereInput>
    NOT?: Enumerable<StudentLevelScalarWhereInput>
    idStudentLevel?: IntFilter | number
    level?: IntFilter | number
    class?: StringFilter | string
    yearStudyId?: IntFilter | number
    studentId?: IntFilter | number
  }

  export type StudentGraduationUpsertWithoutStudentInput = {
    update: XOR<StudentGraduationUpdateWithoutStudentInput, StudentGraduationUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentGraduationCreateWithoutStudentInput, StudentGraduationUncheckedCreateWithoutStudentInput>
  }

  export type StudentGraduationUpdateWithoutStudentInput = {
    graduationDate?: StringFieldUpdateOperationsInput | string
  }

  export type StudentGraduationUncheckedUpdateWithoutStudentInput = {
    idStudentGraduation?: IntFieldUpdateOperationsInput | number
    graduationDate?: StringFieldUpdateOperationsInput | string
  }

  export type NationalInfoUpsertWithoutStudentInput = {
    update: XOR<NationalInfoUpdateWithoutStudentInput, NationalInfoUncheckedUpdateWithoutStudentInput>
    create: XOR<NationalInfoCreateWithoutStudentInput, NationalInfoUncheckedCreateWithoutStudentInput>
  }

  export type NationalInfoUpdateWithoutStudentInput = {
    nationalNumber?: StringFieldUpdateOperationsInput | string
    issueNumber?: StringFieldUpdateOperationsInput | string
    issuePlace?: StringFieldUpdateOperationsInput | string
  }

  export type NationalInfoUncheckedUpdateWithoutStudentInput = {
    idNationalInfo?: IntFieldUpdateOperationsInput | number
    nationalNumber?: StringFieldUpdateOperationsInput | string
    issueNumber?: StringFieldUpdateOperationsInput | string
    issuePlace?: StringFieldUpdateOperationsInput | string
  }

  export type StudentResponsibleUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentResponsibleWhereUniqueInput
    update: XOR<StudentResponsibleUpdateWithoutStudentInput, StudentResponsibleUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentResponsibleCreateWithoutStudentInput, StudentResponsibleUncheckedCreateWithoutStudentInput>
  }

  export type StudentResponsibleUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentResponsibleWhereUniqueInput
    data: XOR<StudentResponsibleUpdateWithoutStudentInput, StudentResponsibleUncheckedUpdateWithoutStudentInput>
  }

  export type StudentResponsibleUpdateManyWithWhereWithoutStudentInput = {
    where: StudentResponsibleScalarWhereInput
    data: XOR<StudentResponsibleUpdateManyMutationInput, StudentResponsibleUncheckedUpdateManyWithoutStudentResponsablesInput>
  }

  export type StudentResponsibleScalarWhereInput = {
    AND?: Enumerable<StudentResponsibleScalarWhereInput>
    OR?: Enumerable<StudentResponsibleScalarWhereInput>
    NOT?: Enumerable<StudentResponsibleScalarWhereInput>
    idStudentResponsible?: IntFilter | number
    responsibleName?: StringFilter | string
    responsiblePhone?: StringFilter | string
    studentId?: IntFilter | number
  }

  export type NationalityCertificateUpsertWithWhereUniqueWithoutStudentInput = {
    where: NationalityCertificateWhereUniqueInput
    update: XOR<NationalityCertificateUpdateWithoutStudentInput, NationalityCertificateUncheckedUpdateWithoutStudentInput>
    create: XOR<NationalityCertificateCreateWithoutStudentInput, NationalityCertificateUncheckedCreateWithoutStudentInput>
  }

  export type NationalityCertificateUpdateWithWhereUniqueWithoutStudentInput = {
    where: NationalityCertificateWhereUniqueInput
    data: XOR<NationalityCertificateUpdateWithoutStudentInput, NationalityCertificateUncheckedUpdateWithoutStudentInput>
  }

  export type NationalityCertificateUpdateManyWithWhereWithoutStudentInput = {
    where: NationalityCertificateScalarWhereInput
    data: XOR<NationalityCertificateUpdateManyMutationInput, NationalityCertificateUncheckedUpdateManyWithoutNationalityCertificateInput>
  }

  export type NationalityCertificateScalarWhereInput = {
    AND?: Enumerable<NationalityCertificateScalarWhereInput>
    OR?: Enumerable<NationalityCertificateScalarWhereInput>
    NOT?: Enumerable<NationalityCertificateScalarWhereInput>
    idNationalityCertificate?: IntFilter | number
    nationalityNumber?: StringFilter | string
    nationalityIssue?: StringFilter | string
    nationalityPlace?: StringFilter | string
    studentId?: IntFilter | number
  }

  export type StudentImageUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentImageWhereUniqueInput
    update: XOR<StudentImageUpdateWithoutStudentInput, StudentImageUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentImageCreateWithoutStudentInput, StudentImageUncheckedCreateWithoutStudentInput>
  }

  export type StudentImageUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentImageWhereUniqueInput
    data: XOR<StudentImageUpdateWithoutStudentInput, StudentImageUncheckedUpdateWithoutStudentInput>
  }

  export type StudentImageUpdateManyWithWhereWithoutStudentInput = {
    where: StudentImageScalarWhereInput
    data: XOR<StudentImageUpdateManyMutationInput, StudentImageUncheckedUpdateManyWithoutStudentImageInput>
  }

  export type StudentImageScalarWhereInput = {
    AND?: Enumerable<StudentImageScalarWhereInput>
    OR?: Enumerable<StudentImageScalarWhereInput>
    NOT?: Enumerable<StudentImageScalarWhereInput>
    idStudentImage?: IntFilter | number
    imagePath?: StringFilter | string
    studentId?: IntFilter | number
  }

  export type AddressUpsertWithoutStudentInput = {
    update: XOR<AddressUpdateWithoutStudentInput, AddressUncheckedUpdateWithoutStudentInput>
    create: XOR<AddressCreateWithoutStudentInput, AddressUncheckedCreateWithoutStudentInput>
  }

  export type AddressUpdateWithoutStudentInput = {
    district?: StringFieldUpdateOperationsInput | string
    avenue?: StringFieldUpdateOperationsInput | string
    houseNumber?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    province?: ProvinceUpdateOneRequiredWithoutAddressesInput
  }

  export type AddressUncheckedUpdateWithoutStudentInput = {
    idAddress?: IntFieldUpdateOperationsInput | number
    provinceId?: IntFieldUpdateOperationsInput | number
    district?: StringFieldUpdateOperationsInput | string
    avenue?: StringFieldUpdateOperationsInput | string
    houseNumber?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
  }

  export type StudentLevelCreateWithoutYearStudyInput = {
    level: number
    class: string
    student: StudentCreateNestedOneWithoutStudentLevelInput
  }

  export type StudentLevelUncheckedCreateWithoutYearStudyInput = {
    idStudentLevel?: number
    level: number
    class: string
    studentId: number
  }

  export type StudentLevelCreateOrConnectWithoutYearStudyInput = {
    where: StudentLevelWhereUniqueInput
    create: XOR<StudentLevelCreateWithoutYearStudyInput, StudentLevelUncheckedCreateWithoutYearStudyInput>
  }

  export type StudentLevelCreateManyYearStudyInputEnvelope = {
    data: Enumerable<StudentLevelCreateManyYearStudyInput>
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutYearStudyInput = {
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    section: SectionCreateNestedOneWithoutStudentsInput
    studentStatus: StudentStatusCreateNestedOneWithoutStudentsInput
    acceptedType: AcceptedTypeCreateNestedOneWithoutStudentsInput
    administrativeOrders?: AdministrativeOrderCreateNestedManyWithoutStudentInput
    studentSchool?: StudentSchoolCreateNestedOneWithoutStudentInput
    studentLevel?: StudentLevelCreateNestedManyWithoutStudentInput
    studentGraduation?: StudentGraduationCreateNestedOneWithoutStudentInput
    nationalInfo?: NationalInfoCreateNestedOneWithoutStudentInput
    studentResponsables?: StudentResponsibleCreateNestedManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateCreateNestedManyWithoutStudentInput
    studentImage?: StudentImageCreateNestedManyWithoutStudentInput
    address?: AddressCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutYearStudyInput = {
    idStudent?: number
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    sectionId: number
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    studentStatusId: number
    acceptedTypeId: number
    administrativeOrders?: AdministrativeOrderUncheckedCreateNestedManyWithoutStudentInput
    studentSchool?: StudentSchoolUncheckedCreateNestedOneWithoutStudentInput
    studentLevel?: StudentLevelUncheckedCreateNestedManyWithoutStudentInput
    studentGraduation?: StudentGraduationUncheckedCreateNestedOneWithoutStudentInput
    nationalInfo?: NationalInfoUncheckedCreateNestedOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUncheckedCreateNestedManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUncheckedCreateNestedManyWithoutStudentInput
    studentImage?: StudentImageUncheckedCreateNestedManyWithoutStudentInput
    address?: AddressUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutYearStudyInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutYearStudyInput, StudentUncheckedCreateWithoutYearStudyInput>
  }

  export type StudentCreateManyYearStudyInputEnvelope = {
    data: Enumerable<StudentCreateManyYearStudyInput>
    skipDuplicates?: boolean
  }

  export type StudentLevelUpsertWithWhereUniqueWithoutYearStudyInput = {
    where: StudentLevelWhereUniqueInput
    update: XOR<StudentLevelUpdateWithoutYearStudyInput, StudentLevelUncheckedUpdateWithoutYearStudyInput>
    create: XOR<StudentLevelCreateWithoutYearStudyInput, StudentLevelUncheckedCreateWithoutYearStudyInput>
  }

  export type StudentLevelUpdateWithWhereUniqueWithoutYearStudyInput = {
    where: StudentLevelWhereUniqueInput
    data: XOR<StudentLevelUpdateWithoutYearStudyInput, StudentLevelUncheckedUpdateWithoutYearStudyInput>
  }

  export type StudentLevelUpdateManyWithWhereWithoutYearStudyInput = {
    where: StudentLevelScalarWhereInput
    data: XOR<StudentLevelUpdateManyMutationInput, StudentLevelUncheckedUpdateManyWithoutStudentLevelInput>
  }

  export type StudentUpsertWithWhereUniqueWithoutYearStudyInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutYearStudyInput, StudentUncheckedUpdateWithoutYearStudyInput>
    create: XOR<StudentCreateWithoutYearStudyInput, StudentUncheckedCreateWithoutYearStudyInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutYearStudyInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutYearStudyInput, StudentUncheckedUpdateWithoutYearStudyInput>
  }

  export type StudentUpdateManyWithWhereWithoutYearStudyInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentCreateWithoutStudentResponsablesInput = {
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    section: SectionCreateNestedOneWithoutStudentsInput
    yearStudy: YearStudyCreateNestedOneWithoutStudentInput
    studentStatus: StudentStatusCreateNestedOneWithoutStudentsInput
    acceptedType: AcceptedTypeCreateNestedOneWithoutStudentsInput
    administrativeOrders?: AdministrativeOrderCreateNestedManyWithoutStudentInput
    studentSchool?: StudentSchoolCreateNestedOneWithoutStudentInput
    studentLevel?: StudentLevelCreateNestedManyWithoutStudentInput
    studentGraduation?: StudentGraduationCreateNestedOneWithoutStudentInput
    nationalInfo?: NationalInfoCreateNestedOneWithoutStudentInput
    nationalityCertificate?: NationalityCertificateCreateNestedManyWithoutStudentInput
    studentImage?: StudentImageCreateNestedManyWithoutStudentInput
    address?: AddressCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentResponsablesInput = {
    idStudent?: number
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    sectionId: number
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    registerYearId: number
    studentStatusId: number
    acceptedTypeId: number
    administrativeOrders?: AdministrativeOrderUncheckedCreateNestedManyWithoutStudentInput
    studentSchool?: StudentSchoolUncheckedCreateNestedOneWithoutStudentInput
    studentLevel?: StudentLevelUncheckedCreateNestedManyWithoutStudentInput
    studentGraduation?: StudentGraduationUncheckedCreateNestedOneWithoutStudentInput
    nationalInfo?: NationalInfoUncheckedCreateNestedOneWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUncheckedCreateNestedManyWithoutStudentInput
    studentImage?: StudentImageUncheckedCreateNestedManyWithoutStudentInput
    address?: AddressUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentResponsablesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentResponsablesInput, StudentUncheckedCreateWithoutStudentResponsablesInput>
  }

  export type StudentUpsertWithoutStudentResponsablesInput = {
    update: XOR<StudentUpdateWithoutStudentResponsablesInput, StudentUncheckedUpdateWithoutStudentResponsablesInput>
    create: XOR<StudentCreateWithoutStudentResponsablesInput, StudentUncheckedCreateWithoutStudentResponsablesInput>
  }

  export type StudentUpdateWithoutStudentResponsablesInput = {
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    section?: SectionUpdateOneRequiredWithoutStudentsInput
    yearStudy?: YearStudyUpdateOneRequiredWithoutStudentInput
    studentStatus?: StudentStatusUpdateOneRequiredWithoutStudentsInput
    acceptedType?: AcceptedTypeUpdateOneRequiredWithoutStudentsInput
    administrativeOrders?: AdministrativeOrderUpdateManyWithoutStudentInput
    studentSchool?: StudentSchoolUpdateOneWithoutStudentInput
    studentLevel?: StudentLevelUpdateManyWithoutStudentInput
    studentGraduation?: StudentGraduationUpdateOneWithoutStudentInput
    nationalInfo?: NationalInfoUpdateOneWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUpdateManyWithoutStudentInput
    studentImage?: StudentImageUpdateManyWithoutStudentInput
    address?: AddressUpdateOneWithoutStudentInput
  }

  export type StudentUncheckedUpdateWithoutStudentResponsablesInput = {
    idStudent?: IntFieldUpdateOperationsInput | number
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    sectionId?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    registerYearId?: IntFieldUpdateOperationsInput | number
    studentStatusId?: IntFieldUpdateOperationsInput | number
    acceptedTypeId?: IntFieldUpdateOperationsInput | number
    administrativeOrders?: AdministrativeOrderUncheckedUpdateManyWithoutStudentInput
    studentSchool?: StudentSchoolUncheckedUpdateOneWithoutStudentInput
    studentLevel?: StudentLevelUncheckedUpdateManyWithoutStudentInput
    studentGraduation?: StudentGraduationUncheckedUpdateOneWithoutStudentInput
    nationalInfo?: NationalInfoUncheckedUpdateOneWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUncheckedUpdateManyWithoutStudentInput
    studentImage?: StudentImageUncheckedUpdateManyWithoutStudentInput
    address?: AddressUncheckedUpdateOneWithoutStudentInput
  }

  export type StudentCreateWithoutNationalityCertificateInput = {
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    section: SectionCreateNestedOneWithoutStudentsInput
    yearStudy: YearStudyCreateNestedOneWithoutStudentInput
    studentStatus: StudentStatusCreateNestedOneWithoutStudentsInput
    acceptedType: AcceptedTypeCreateNestedOneWithoutStudentsInput
    administrativeOrders?: AdministrativeOrderCreateNestedManyWithoutStudentInput
    studentSchool?: StudentSchoolCreateNestedOneWithoutStudentInput
    studentLevel?: StudentLevelCreateNestedManyWithoutStudentInput
    studentGraduation?: StudentGraduationCreateNestedOneWithoutStudentInput
    nationalInfo?: NationalInfoCreateNestedOneWithoutStudentInput
    studentResponsables?: StudentResponsibleCreateNestedManyWithoutStudentInput
    studentImage?: StudentImageCreateNestedManyWithoutStudentInput
    address?: AddressCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutNationalityCertificateInput = {
    idStudent?: number
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    sectionId: number
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    registerYearId: number
    studentStatusId: number
    acceptedTypeId: number
    administrativeOrders?: AdministrativeOrderUncheckedCreateNestedManyWithoutStudentInput
    studentSchool?: StudentSchoolUncheckedCreateNestedOneWithoutStudentInput
    studentLevel?: StudentLevelUncheckedCreateNestedManyWithoutStudentInput
    studentGraduation?: StudentGraduationUncheckedCreateNestedOneWithoutStudentInput
    nationalInfo?: NationalInfoUncheckedCreateNestedOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUncheckedCreateNestedManyWithoutStudentInput
    studentImage?: StudentImageUncheckedCreateNestedManyWithoutStudentInput
    address?: AddressUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutNationalityCertificateInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutNationalityCertificateInput, StudentUncheckedCreateWithoutNationalityCertificateInput>
  }

  export type StudentUpsertWithoutNationalityCertificateInput = {
    update: XOR<StudentUpdateWithoutNationalityCertificateInput, StudentUncheckedUpdateWithoutNationalityCertificateInput>
    create: XOR<StudentCreateWithoutNationalityCertificateInput, StudentUncheckedCreateWithoutNationalityCertificateInput>
  }

  export type StudentUpdateWithoutNationalityCertificateInput = {
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    section?: SectionUpdateOneRequiredWithoutStudentsInput
    yearStudy?: YearStudyUpdateOneRequiredWithoutStudentInput
    studentStatus?: StudentStatusUpdateOneRequiredWithoutStudentsInput
    acceptedType?: AcceptedTypeUpdateOneRequiredWithoutStudentsInput
    administrativeOrders?: AdministrativeOrderUpdateManyWithoutStudentInput
    studentSchool?: StudentSchoolUpdateOneWithoutStudentInput
    studentLevel?: StudentLevelUpdateManyWithoutStudentInput
    studentGraduation?: StudentGraduationUpdateOneWithoutStudentInput
    nationalInfo?: NationalInfoUpdateOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUpdateManyWithoutStudentInput
    studentImage?: StudentImageUpdateManyWithoutStudentInput
    address?: AddressUpdateOneWithoutStudentInput
  }

  export type StudentUncheckedUpdateWithoutNationalityCertificateInput = {
    idStudent?: IntFieldUpdateOperationsInput | number
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    sectionId?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    registerYearId?: IntFieldUpdateOperationsInput | number
    studentStatusId?: IntFieldUpdateOperationsInput | number
    acceptedTypeId?: IntFieldUpdateOperationsInput | number
    administrativeOrders?: AdministrativeOrderUncheckedUpdateManyWithoutStudentInput
    studentSchool?: StudentSchoolUncheckedUpdateOneWithoutStudentInput
    studentLevel?: StudentLevelUncheckedUpdateManyWithoutStudentInput
    studentGraduation?: StudentGraduationUncheckedUpdateOneWithoutStudentInput
    nationalInfo?: NationalInfoUncheckedUpdateOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUncheckedUpdateManyWithoutStudentInput
    studentImage?: StudentImageUncheckedUpdateManyWithoutStudentInput
    address?: AddressUncheckedUpdateOneWithoutStudentInput
  }

  export type StudentCreateWithoutNationalInfoInput = {
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    section: SectionCreateNestedOneWithoutStudentsInput
    yearStudy: YearStudyCreateNestedOneWithoutStudentInput
    studentStatus: StudentStatusCreateNestedOneWithoutStudentsInput
    acceptedType: AcceptedTypeCreateNestedOneWithoutStudentsInput
    administrativeOrders?: AdministrativeOrderCreateNestedManyWithoutStudentInput
    studentSchool?: StudentSchoolCreateNestedOneWithoutStudentInput
    studentLevel?: StudentLevelCreateNestedManyWithoutStudentInput
    studentGraduation?: StudentGraduationCreateNestedOneWithoutStudentInput
    studentResponsables?: StudentResponsibleCreateNestedManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateCreateNestedManyWithoutStudentInput
    studentImage?: StudentImageCreateNestedManyWithoutStudentInput
    address?: AddressCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutNationalInfoInput = {
    idStudent?: number
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    sectionId: number
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    registerYearId: number
    studentStatusId: number
    acceptedTypeId: number
    administrativeOrders?: AdministrativeOrderUncheckedCreateNestedManyWithoutStudentInput
    studentSchool?: StudentSchoolUncheckedCreateNestedOneWithoutStudentInput
    studentLevel?: StudentLevelUncheckedCreateNestedManyWithoutStudentInput
    studentGraduation?: StudentGraduationUncheckedCreateNestedOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUncheckedCreateNestedManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUncheckedCreateNestedManyWithoutStudentInput
    studentImage?: StudentImageUncheckedCreateNestedManyWithoutStudentInput
    address?: AddressUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutNationalInfoInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutNationalInfoInput, StudentUncheckedCreateWithoutNationalInfoInput>
  }

  export type StudentUpsertWithoutNationalInfoInput = {
    update: XOR<StudentUpdateWithoutNationalInfoInput, StudentUncheckedUpdateWithoutNationalInfoInput>
    create: XOR<StudentCreateWithoutNationalInfoInput, StudentUncheckedCreateWithoutNationalInfoInput>
  }

  export type StudentUpdateWithoutNationalInfoInput = {
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    section?: SectionUpdateOneRequiredWithoutStudentsInput
    yearStudy?: YearStudyUpdateOneRequiredWithoutStudentInput
    studentStatus?: StudentStatusUpdateOneRequiredWithoutStudentsInput
    acceptedType?: AcceptedTypeUpdateOneRequiredWithoutStudentsInput
    administrativeOrders?: AdministrativeOrderUpdateManyWithoutStudentInput
    studentSchool?: StudentSchoolUpdateOneWithoutStudentInput
    studentLevel?: StudentLevelUpdateManyWithoutStudentInput
    studentGraduation?: StudentGraduationUpdateOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUpdateManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUpdateManyWithoutStudentInput
    studentImage?: StudentImageUpdateManyWithoutStudentInput
    address?: AddressUpdateOneWithoutStudentInput
  }

  export type StudentUncheckedUpdateWithoutNationalInfoInput = {
    idStudent?: IntFieldUpdateOperationsInput | number
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    sectionId?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    registerYearId?: IntFieldUpdateOperationsInput | number
    studentStatusId?: IntFieldUpdateOperationsInput | number
    acceptedTypeId?: IntFieldUpdateOperationsInput | number
    administrativeOrders?: AdministrativeOrderUncheckedUpdateManyWithoutStudentInput
    studentSchool?: StudentSchoolUncheckedUpdateOneWithoutStudentInput
    studentLevel?: StudentLevelUncheckedUpdateManyWithoutStudentInput
    studentGraduation?: StudentGraduationUncheckedUpdateOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUncheckedUpdateManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUncheckedUpdateManyWithoutStudentInput
    studentImage?: StudentImageUncheckedUpdateManyWithoutStudentInput
    address?: AddressUncheckedUpdateOneWithoutStudentInput
  }

  export type StudentCreateWithoutStudentGraduationInput = {
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    section: SectionCreateNestedOneWithoutStudentsInput
    yearStudy: YearStudyCreateNestedOneWithoutStudentInput
    studentStatus: StudentStatusCreateNestedOneWithoutStudentsInput
    acceptedType: AcceptedTypeCreateNestedOneWithoutStudentsInput
    administrativeOrders?: AdministrativeOrderCreateNestedManyWithoutStudentInput
    studentSchool?: StudentSchoolCreateNestedOneWithoutStudentInput
    studentLevel?: StudentLevelCreateNestedManyWithoutStudentInput
    nationalInfo?: NationalInfoCreateNestedOneWithoutStudentInput
    studentResponsables?: StudentResponsibleCreateNestedManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateCreateNestedManyWithoutStudentInput
    studentImage?: StudentImageCreateNestedManyWithoutStudentInput
    address?: AddressCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentGraduationInput = {
    idStudent?: number
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    sectionId: number
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    registerYearId: number
    studentStatusId: number
    acceptedTypeId: number
    administrativeOrders?: AdministrativeOrderUncheckedCreateNestedManyWithoutStudentInput
    studentSchool?: StudentSchoolUncheckedCreateNestedOneWithoutStudentInput
    studentLevel?: StudentLevelUncheckedCreateNestedManyWithoutStudentInput
    nationalInfo?: NationalInfoUncheckedCreateNestedOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUncheckedCreateNestedManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUncheckedCreateNestedManyWithoutStudentInput
    studentImage?: StudentImageUncheckedCreateNestedManyWithoutStudentInput
    address?: AddressUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentGraduationInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentGraduationInput, StudentUncheckedCreateWithoutStudentGraduationInput>
  }

  export type StudentUpsertWithoutStudentGraduationInput = {
    update: XOR<StudentUpdateWithoutStudentGraduationInput, StudentUncheckedUpdateWithoutStudentGraduationInput>
    create: XOR<StudentCreateWithoutStudentGraduationInput, StudentUncheckedCreateWithoutStudentGraduationInput>
  }

  export type StudentUpdateWithoutStudentGraduationInput = {
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    section?: SectionUpdateOneRequiredWithoutStudentsInput
    yearStudy?: YearStudyUpdateOneRequiredWithoutStudentInput
    studentStatus?: StudentStatusUpdateOneRequiredWithoutStudentsInput
    acceptedType?: AcceptedTypeUpdateOneRequiredWithoutStudentsInput
    administrativeOrders?: AdministrativeOrderUpdateManyWithoutStudentInput
    studentSchool?: StudentSchoolUpdateOneWithoutStudentInput
    studentLevel?: StudentLevelUpdateManyWithoutStudentInput
    nationalInfo?: NationalInfoUpdateOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUpdateManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUpdateManyWithoutStudentInput
    studentImage?: StudentImageUpdateManyWithoutStudentInput
    address?: AddressUpdateOneWithoutStudentInput
  }

  export type StudentUncheckedUpdateWithoutStudentGraduationInput = {
    idStudent?: IntFieldUpdateOperationsInput | number
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    sectionId?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    registerYearId?: IntFieldUpdateOperationsInput | number
    studentStatusId?: IntFieldUpdateOperationsInput | number
    acceptedTypeId?: IntFieldUpdateOperationsInput | number
    administrativeOrders?: AdministrativeOrderUncheckedUpdateManyWithoutStudentInput
    studentSchool?: StudentSchoolUncheckedUpdateOneWithoutStudentInput
    studentLevel?: StudentLevelUncheckedUpdateManyWithoutStudentInput
    nationalInfo?: NationalInfoUncheckedUpdateOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUncheckedUpdateManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUncheckedUpdateManyWithoutStudentInput
    studentImage?: StudentImageUncheckedUpdateManyWithoutStudentInput
    address?: AddressUncheckedUpdateOneWithoutStudentInput
  }

  export type YearStudyCreateWithoutStudentLevelInput = {
    year: string
    currentYear: boolean
    Student?: StudentCreateNestedManyWithoutYearStudyInput
  }

  export type YearStudyUncheckedCreateWithoutStudentLevelInput = {
    idYearStudy?: number
    year: string
    currentYear: boolean
    Student?: StudentUncheckedCreateNestedManyWithoutYearStudyInput
  }

  export type YearStudyCreateOrConnectWithoutStudentLevelInput = {
    where: YearStudyWhereUniqueInput
    create: XOR<YearStudyCreateWithoutStudentLevelInput, YearStudyUncheckedCreateWithoutStudentLevelInput>
  }

  export type StudentCreateWithoutStudentLevelInput = {
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    section: SectionCreateNestedOneWithoutStudentsInput
    yearStudy: YearStudyCreateNestedOneWithoutStudentInput
    studentStatus: StudentStatusCreateNestedOneWithoutStudentsInput
    acceptedType: AcceptedTypeCreateNestedOneWithoutStudentsInput
    administrativeOrders?: AdministrativeOrderCreateNestedManyWithoutStudentInput
    studentSchool?: StudentSchoolCreateNestedOneWithoutStudentInput
    studentGraduation?: StudentGraduationCreateNestedOneWithoutStudentInput
    nationalInfo?: NationalInfoCreateNestedOneWithoutStudentInput
    studentResponsables?: StudentResponsibleCreateNestedManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateCreateNestedManyWithoutStudentInput
    studentImage?: StudentImageCreateNestedManyWithoutStudentInput
    address?: AddressCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentLevelInput = {
    idStudent?: number
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    sectionId: number
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    registerYearId: number
    studentStatusId: number
    acceptedTypeId: number
    administrativeOrders?: AdministrativeOrderUncheckedCreateNestedManyWithoutStudentInput
    studentSchool?: StudentSchoolUncheckedCreateNestedOneWithoutStudentInput
    studentGraduation?: StudentGraduationUncheckedCreateNestedOneWithoutStudentInput
    nationalInfo?: NationalInfoUncheckedCreateNestedOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUncheckedCreateNestedManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUncheckedCreateNestedManyWithoutStudentInput
    studentImage?: StudentImageUncheckedCreateNestedManyWithoutStudentInput
    address?: AddressUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentLevelInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentLevelInput, StudentUncheckedCreateWithoutStudentLevelInput>
  }

  export type YearStudyUpsertWithoutStudentLevelInput = {
    update: XOR<YearStudyUpdateWithoutStudentLevelInput, YearStudyUncheckedUpdateWithoutStudentLevelInput>
    create: XOR<YearStudyCreateWithoutStudentLevelInput, YearStudyUncheckedCreateWithoutStudentLevelInput>
  }

  export type YearStudyUpdateWithoutStudentLevelInput = {
    year?: StringFieldUpdateOperationsInput | string
    currentYear?: BoolFieldUpdateOperationsInput | boolean
    Student?: StudentUpdateManyWithoutYearStudyInput
  }

  export type YearStudyUncheckedUpdateWithoutStudentLevelInput = {
    idYearStudy?: IntFieldUpdateOperationsInput | number
    year?: StringFieldUpdateOperationsInput | string
    currentYear?: BoolFieldUpdateOperationsInput | boolean
    Student?: StudentUncheckedUpdateManyWithoutYearStudyInput
  }

  export type StudentUpsertWithoutStudentLevelInput = {
    update: XOR<StudentUpdateWithoutStudentLevelInput, StudentUncheckedUpdateWithoutStudentLevelInput>
    create: XOR<StudentCreateWithoutStudentLevelInput, StudentUncheckedCreateWithoutStudentLevelInput>
  }

  export type StudentUpdateWithoutStudentLevelInput = {
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    section?: SectionUpdateOneRequiredWithoutStudentsInput
    yearStudy?: YearStudyUpdateOneRequiredWithoutStudentInput
    studentStatus?: StudentStatusUpdateOneRequiredWithoutStudentsInput
    acceptedType?: AcceptedTypeUpdateOneRequiredWithoutStudentsInput
    administrativeOrders?: AdministrativeOrderUpdateManyWithoutStudentInput
    studentSchool?: StudentSchoolUpdateOneWithoutStudentInput
    studentGraduation?: StudentGraduationUpdateOneWithoutStudentInput
    nationalInfo?: NationalInfoUpdateOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUpdateManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUpdateManyWithoutStudentInput
    studentImage?: StudentImageUpdateManyWithoutStudentInput
    address?: AddressUpdateOneWithoutStudentInput
  }

  export type StudentUncheckedUpdateWithoutStudentLevelInput = {
    idStudent?: IntFieldUpdateOperationsInput | number
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    sectionId?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    registerYearId?: IntFieldUpdateOperationsInput | number
    studentStatusId?: IntFieldUpdateOperationsInput | number
    acceptedTypeId?: IntFieldUpdateOperationsInput | number
    administrativeOrders?: AdministrativeOrderUncheckedUpdateManyWithoutStudentInput
    studentSchool?: StudentSchoolUncheckedUpdateOneWithoutStudentInput
    studentGraduation?: StudentGraduationUncheckedUpdateOneWithoutStudentInput
    nationalInfo?: NationalInfoUncheckedUpdateOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUncheckedUpdateManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUncheckedUpdateManyWithoutStudentInput
    studentImage?: StudentImageUncheckedUpdateManyWithoutStudentInput
    address?: AddressUncheckedUpdateOneWithoutStudentInput
  }

  export type StudySubCategoryCreateWithoutStudentSchoolInput = {
    subCategoryName: string
    studyCategory: StudyCategoryCreateNestedOneWithoutStudySubCategoryInput
  }

  export type StudySubCategoryUncheckedCreateWithoutStudentSchoolInput = {
    idStudySubCategory?: number
    subCategoryName: string
    studyCategoryId: number
  }

  export type StudySubCategoryCreateOrConnectWithoutStudentSchoolInput = {
    where: StudySubCategoryWhereUniqueInput
    create: XOR<StudySubCategoryCreateWithoutStudentSchoolInput, StudySubCategoryUncheckedCreateWithoutStudentSchoolInput>
  }

  export type StudentCreateWithoutStudentSchoolInput = {
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    section: SectionCreateNestedOneWithoutStudentsInput
    yearStudy: YearStudyCreateNestedOneWithoutStudentInput
    studentStatus: StudentStatusCreateNestedOneWithoutStudentsInput
    acceptedType: AcceptedTypeCreateNestedOneWithoutStudentsInput
    administrativeOrders?: AdministrativeOrderCreateNestedManyWithoutStudentInput
    studentLevel?: StudentLevelCreateNestedManyWithoutStudentInput
    studentGraduation?: StudentGraduationCreateNestedOneWithoutStudentInput
    nationalInfo?: NationalInfoCreateNestedOneWithoutStudentInput
    studentResponsables?: StudentResponsibleCreateNestedManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateCreateNestedManyWithoutStudentInput
    studentImage?: StudentImageCreateNestedManyWithoutStudentInput
    address?: AddressCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentSchoolInput = {
    idStudent?: number
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    sectionId: number
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    registerYearId: number
    studentStatusId: number
    acceptedTypeId: number
    administrativeOrders?: AdministrativeOrderUncheckedCreateNestedManyWithoutStudentInput
    studentLevel?: StudentLevelUncheckedCreateNestedManyWithoutStudentInput
    studentGraduation?: StudentGraduationUncheckedCreateNestedOneWithoutStudentInput
    nationalInfo?: NationalInfoUncheckedCreateNestedOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUncheckedCreateNestedManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUncheckedCreateNestedManyWithoutStudentInput
    studentImage?: StudentImageUncheckedCreateNestedManyWithoutStudentInput
    address?: AddressUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentSchoolInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentSchoolInput, StudentUncheckedCreateWithoutStudentSchoolInput>
  }

  export type CertificateStatusCreateWithoutStudentSchoolInput = {
    certificateStatusName: string
  }

  export type CertificateStatusUncheckedCreateWithoutStudentSchoolInput = {
    idCertificateStatus?: number
    certificateStatusName: string
  }

  export type CertificateStatusCreateOrConnectWithoutStudentSchoolInput = {
    where: CertificateStatusWhereUniqueInput
    create: XOR<CertificateStatusCreateWithoutStudentSchoolInput, CertificateStatusUncheckedCreateWithoutStudentSchoolInput>
  }

  export type StudySubCategoryUpsertWithoutStudentSchoolInput = {
    update: XOR<StudySubCategoryUpdateWithoutStudentSchoolInput, StudySubCategoryUncheckedUpdateWithoutStudentSchoolInput>
    create: XOR<StudySubCategoryCreateWithoutStudentSchoolInput, StudySubCategoryUncheckedCreateWithoutStudentSchoolInput>
  }

  export type StudySubCategoryUpdateWithoutStudentSchoolInput = {
    subCategoryName?: StringFieldUpdateOperationsInput | string
    studyCategory?: StudyCategoryUpdateOneRequiredWithoutStudySubCategoryInput
  }

  export type StudySubCategoryUncheckedUpdateWithoutStudentSchoolInput = {
    idStudySubCategory?: IntFieldUpdateOperationsInput | number
    subCategoryName?: StringFieldUpdateOperationsInput | string
    studyCategoryId?: IntFieldUpdateOperationsInput | number
  }

  export type StudentUpsertWithoutStudentSchoolInput = {
    update: XOR<StudentUpdateWithoutStudentSchoolInput, StudentUncheckedUpdateWithoutStudentSchoolInput>
    create: XOR<StudentCreateWithoutStudentSchoolInput, StudentUncheckedCreateWithoutStudentSchoolInput>
  }

  export type StudentUpdateWithoutStudentSchoolInput = {
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    section?: SectionUpdateOneRequiredWithoutStudentsInput
    yearStudy?: YearStudyUpdateOneRequiredWithoutStudentInput
    studentStatus?: StudentStatusUpdateOneRequiredWithoutStudentsInput
    acceptedType?: AcceptedTypeUpdateOneRequiredWithoutStudentsInput
    administrativeOrders?: AdministrativeOrderUpdateManyWithoutStudentInput
    studentLevel?: StudentLevelUpdateManyWithoutStudentInput
    studentGraduation?: StudentGraduationUpdateOneWithoutStudentInput
    nationalInfo?: NationalInfoUpdateOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUpdateManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUpdateManyWithoutStudentInput
    studentImage?: StudentImageUpdateManyWithoutStudentInput
    address?: AddressUpdateOneWithoutStudentInput
  }

  export type StudentUncheckedUpdateWithoutStudentSchoolInput = {
    idStudent?: IntFieldUpdateOperationsInput | number
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    sectionId?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    registerYearId?: IntFieldUpdateOperationsInput | number
    studentStatusId?: IntFieldUpdateOperationsInput | number
    acceptedTypeId?: IntFieldUpdateOperationsInput | number
    administrativeOrders?: AdministrativeOrderUncheckedUpdateManyWithoutStudentInput
    studentLevel?: StudentLevelUncheckedUpdateManyWithoutStudentInput
    studentGraduation?: StudentGraduationUncheckedUpdateOneWithoutStudentInput
    nationalInfo?: NationalInfoUncheckedUpdateOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUncheckedUpdateManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUncheckedUpdateManyWithoutStudentInput
    studentImage?: StudentImageUncheckedUpdateManyWithoutStudentInput
    address?: AddressUncheckedUpdateOneWithoutStudentInput
  }

  export type CertificateStatusUpsertWithoutStudentSchoolInput = {
    update: XOR<CertificateStatusUpdateWithoutStudentSchoolInput, CertificateStatusUncheckedUpdateWithoutStudentSchoolInput>
    create: XOR<CertificateStatusCreateWithoutStudentSchoolInput, CertificateStatusUncheckedCreateWithoutStudentSchoolInput>
  }

  export type CertificateStatusUpdateWithoutStudentSchoolInput = {
    certificateStatusName?: StringFieldUpdateOperationsInput | string
  }

  export type CertificateStatusUncheckedUpdateWithoutStudentSchoolInput = {
    idCertificateStatus?: IntFieldUpdateOperationsInput | number
    certificateStatusName?: StringFieldUpdateOperationsInput | string
  }

  export type StudySubCategoryCreateWithoutStudyCategoryInput = {
    subCategoryName: string
    StudentSchool?: StudentSchoolCreateNestedManyWithoutStudySubCategoryInput
  }

  export type StudySubCategoryUncheckedCreateWithoutStudyCategoryInput = {
    idStudySubCategory?: number
    subCategoryName: string
    StudentSchool?: StudentSchoolUncheckedCreateNestedManyWithoutStudySubCategoryInput
  }

  export type StudySubCategoryCreateOrConnectWithoutStudyCategoryInput = {
    where: StudySubCategoryWhereUniqueInput
    create: XOR<StudySubCategoryCreateWithoutStudyCategoryInput, StudySubCategoryUncheckedCreateWithoutStudyCategoryInput>
  }

  export type StudySubCategoryCreateManyStudyCategoryInputEnvelope = {
    data: Enumerable<StudySubCategoryCreateManyStudyCategoryInput>
    skipDuplicates?: boolean
  }

  export type StudySubCategoryUpsertWithWhereUniqueWithoutStudyCategoryInput = {
    where: StudySubCategoryWhereUniqueInput
    update: XOR<StudySubCategoryUpdateWithoutStudyCategoryInput, StudySubCategoryUncheckedUpdateWithoutStudyCategoryInput>
    create: XOR<StudySubCategoryCreateWithoutStudyCategoryInput, StudySubCategoryUncheckedCreateWithoutStudyCategoryInput>
  }

  export type StudySubCategoryUpdateWithWhereUniqueWithoutStudyCategoryInput = {
    where: StudySubCategoryWhereUniqueInput
    data: XOR<StudySubCategoryUpdateWithoutStudyCategoryInput, StudySubCategoryUncheckedUpdateWithoutStudyCategoryInput>
  }

  export type StudySubCategoryUpdateManyWithWhereWithoutStudyCategoryInput = {
    where: StudySubCategoryScalarWhereInput
    data: XOR<StudySubCategoryUpdateManyMutationInput, StudySubCategoryUncheckedUpdateManyWithoutStudySubCategoryInput>
  }

  export type StudySubCategoryScalarWhereInput = {
    AND?: Enumerable<StudySubCategoryScalarWhereInput>
    OR?: Enumerable<StudySubCategoryScalarWhereInput>
    NOT?: Enumerable<StudySubCategoryScalarWhereInput>
    idStudySubCategory?: IntFilter | number
    subCategoryName?: StringFilter | string
    studyCategoryId?: IntFilter | number
  }

  export type StudyCategoryCreateWithoutStudySubCategoryInput = {
    categoryName: string
  }

  export type StudyCategoryUncheckedCreateWithoutStudySubCategoryInput = {
    idStudyCategory?: number
    categoryName: string
  }

  export type StudyCategoryCreateOrConnectWithoutStudySubCategoryInput = {
    where: StudyCategoryWhereUniqueInput
    create: XOR<StudyCategoryCreateWithoutStudySubCategoryInput, StudyCategoryUncheckedCreateWithoutStudySubCategoryInput>
  }

  export type StudentSchoolCreateWithoutStudySubCategoryInput = {
    schoolName: string
    graduationDate: string
    documentDate: string
    totalMarks: number
    average: number
    documentNumber: number
    lessonCount: number
    Directorate: string
    certificateStatusDescription: string
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentSchoolInput
    certificateStatus: CertificateStatusCreateNestedOneWithoutStudentSchoolInput
  }

  export type StudentSchoolUncheckedCreateWithoutStudySubCategoryInput = {
    idStudentSchool?: number
    schoolName: string
    graduationDate: string
    documentDate: string
    totalMarks: number
    average: number
    documentNumber: number
    lessonCount: number
    Directorate: string
    studentId: number
    certificateStatusId: number
    certificateStatusDescription: string
    createdAt?: Date | string
  }

  export type StudentSchoolCreateOrConnectWithoutStudySubCategoryInput = {
    where: StudentSchoolWhereUniqueInput
    create: XOR<StudentSchoolCreateWithoutStudySubCategoryInput, StudentSchoolUncheckedCreateWithoutStudySubCategoryInput>
  }

  export type StudentSchoolCreateManyStudySubCategoryInputEnvelope = {
    data: Enumerable<StudentSchoolCreateManyStudySubCategoryInput>
    skipDuplicates?: boolean
  }

  export type StudyCategoryUpsertWithoutStudySubCategoryInput = {
    update: XOR<StudyCategoryUpdateWithoutStudySubCategoryInput, StudyCategoryUncheckedUpdateWithoutStudySubCategoryInput>
    create: XOR<StudyCategoryCreateWithoutStudySubCategoryInput, StudyCategoryUncheckedCreateWithoutStudySubCategoryInput>
  }

  export type StudyCategoryUpdateWithoutStudySubCategoryInput = {
    categoryName?: StringFieldUpdateOperationsInput | string
  }

  export type StudyCategoryUncheckedUpdateWithoutStudySubCategoryInput = {
    idStudyCategory?: IntFieldUpdateOperationsInput | number
    categoryName?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSchoolUpsertWithWhereUniqueWithoutStudySubCategoryInput = {
    where: StudentSchoolWhereUniqueInput
    update: XOR<StudentSchoolUpdateWithoutStudySubCategoryInput, StudentSchoolUncheckedUpdateWithoutStudySubCategoryInput>
    create: XOR<StudentSchoolCreateWithoutStudySubCategoryInput, StudentSchoolUncheckedCreateWithoutStudySubCategoryInput>
  }

  export type StudentSchoolUpdateWithWhereUniqueWithoutStudySubCategoryInput = {
    where: StudentSchoolWhereUniqueInput
    data: XOR<StudentSchoolUpdateWithoutStudySubCategoryInput, StudentSchoolUncheckedUpdateWithoutStudySubCategoryInput>
  }

  export type StudentSchoolUpdateManyWithWhereWithoutStudySubCategoryInput = {
    where: StudentSchoolScalarWhereInput
    data: XOR<StudentSchoolUpdateManyMutationInput, StudentSchoolUncheckedUpdateManyWithoutStudentSchoolInput>
  }

  export type StudentSchoolScalarWhereInput = {
    AND?: Enumerable<StudentSchoolScalarWhereInput>
    OR?: Enumerable<StudentSchoolScalarWhereInput>
    NOT?: Enumerable<StudentSchoolScalarWhereInput>
    idStudentSchool?: IntFilter | number
    schoolName?: StringFilter | string
    graduationDate?: StringFilter | string
    documentDate?: StringFilter | string
    totalMarks?: IntFilter | number
    average?: FloatFilter | number
    documentNumber?: IntFilter | number
    lessonCount?: IntFilter | number
    Directorate?: StringFilter | string
    studySubCategoryId?: IntFilter | number
    studentId?: IntFilter | number
    certificateStatusId?: IntFilter | number
    certificateStatusDescription?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type StudentSchoolCreateWithoutCertificateStatusInput = {
    schoolName: string
    graduationDate: string
    documentDate: string
    totalMarks: number
    average: number
    documentNumber: number
    lessonCount: number
    Directorate: string
    certificateStatusDescription: string
    createdAt?: Date | string
    studySubCategory: StudySubCategoryCreateNestedOneWithoutStudentSchoolInput
    student: StudentCreateNestedOneWithoutStudentSchoolInput
  }

  export type StudentSchoolUncheckedCreateWithoutCertificateStatusInput = {
    idStudentSchool?: number
    schoolName: string
    graduationDate: string
    documentDate: string
    totalMarks: number
    average: number
    documentNumber: number
    lessonCount: number
    Directorate: string
    studySubCategoryId: number
    studentId: number
    certificateStatusDescription: string
    createdAt?: Date | string
  }

  export type StudentSchoolCreateOrConnectWithoutCertificateStatusInput = {
    where: StudentSchoolWhereUniqueInput
    create: XOR<StudentSchoolCreateWithoutCertificateStatusInput, StudentSchoolUncheckedCreateWithoutCertificateStatusInput>
  }

  export type StudentSchoolCreateManyCertificateStatusInputEnvelope = {
    data: Enumerable<StudentSchoolCreateManyCertificateStatusInput>
    skipDuplicates?: boolean
  }

  export type StudentSchoolUpsertWithWhereUniqueWithoutCertificateStatusInput = {
    where: StudentSchoolWhereUniqueInput
    update: XOR<StudentSchoolUpdateWithoutCertificateStatusInput, StudentSchoolUncheckedUpdateWithoutCertificateStatusInput>
    create: XOR<StudentSchoolCreateWithoutCertificateStatusInput, StudentSchoolUncheckedCreateWithoutCertificateStatusInput>
  }

  export type StudentSchoolUpdateWithWhereUniqueWithoutCertificateStatusInput = {
    where: StudentSchoolWhereUniqueInput
    data: XOR<StudentSchoolUpdateWithoutCertificateStatusInput, StudentSchoolUncheckedUpdateWithoutCertificateStatusInput>
  }

  export type StudentSchoolUpdateManyWithWhereWithoutCertificateStatusInput = {
    where: StudentSchoolScalarWhereInput
    data: XOR<StudentSchoolUpdateManyMutationInput, StudentSchoolUncheckedUpdateManyWithoutStudentSchoolInput>
  }

  export type StudentCreateWithoutStudentStatusInput = {
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    section: SectionCreateNestedOneWithoutStudentsInput
    yearStudy: YearStudyCreateNestedOneWithoutStudentInput
    acceptedType: AcceptedTypeCreateNestedOneWithoutStudentsInput
    administrativeOrders?: AdministrativeOrderCreateNestedManyWithoutStudentInput
    studentSchool?: StudentSchoolCreateNestedOneWithoutStudentInput
    studentLevel?: StudentLevelCreateNestedManyWithoutStudentInput
    studentGraduation?: StudentGraduationCreateNestedOneWithoutStudentInput
    nationalInfo?: NationalInfoCreateNestedOneWithoutStudentInput
    studentResponsables?: StudentResponsibleCreateNestedManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateCreateNestedManyWithoutStudentInput
    studentImage?: StudentImageCreateNestedManyWithoutStudentInput
    address?: AddressCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentStatusInput = {
    idStudent?: number
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    sectionId: number
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    registerYearId: number
    acceptedTypeId: number
    administrativeOrders?: AdministrativeOrderUncheckedCreateNestedManyWithoutStudentInput
    studentSchool?: StudentSchoolUncheckedCreateNestedOneWithoutStudentInput
    studentLevel?: StudentLevelUncheckedCreateNestedManyWithoutStudentInput
    studentGraduation?: StudentGraduationUncheckedCreateNestedOneWithoutStudentInput
    nationalInfo?: NationalInfoUncheckedCreateNestedOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUncheckedCreateNestedManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUncheckedCreateNestedManyWithoutStudentInput
    studentImage?: StudentImageUncheckedCreateNestedManyWithoutStudentInput
    address?: AddressUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentStatusInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentStatusInput, StudentUncheckedCreateWithoutStudentStatusInput>
  }

  export type StudentCreateManyStudentStatusInputEnvelope = {
    data: Enumerable<StudentCreateManyStudentStatusInput>
    skipDuplicates?: boolean
  }

  export type StudentUpsertWithWhereUniqueWithoutStudentStatusInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutStudentStatusInput, StudentUncheckedUpdateWithoutStudentStatusInput>
    create: XOR<StudentCreateWithoutStudentStatusInput, StudentUncheckedCreateWithoutStudentStatusInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutStudentStatusInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutStudentStatusInput, StudentUncheckedUpdateWithoutStudentStatusInput>
  }

  export type StudentUpdateManyWithWhereWithoutStudentStatusInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutStudentsInput>
  }

  export type StudentCreateWithoutAcceptedTypeInput = {
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    section: SectionCreateNestedOneWithoutStudentsInput
    yearStudy: YearStudyCreateNestedOneWithoutStudentInput
    studentStatus: StudentStatusCreateNestedOneWithoutStudentsInput
    administrativeOrders?: AdministrativeOrderCreateNestedManyWithoutStudentInput
    studentSchool?: StudentSchoolCreateNestedOneWithoutStudentInput
    studentLevel?: StudentLevelCreateNestedManyWithoutStudentInput
    studentGraduation?: StudentGraduationCreateNestedOneWithoutStudentInput
    nationalInfo?: NationalInfoCreateNestedOneWithoutStudentInput
    studentResponsables?: StudentResponsibleCreateNestedManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateCreateNestedManyWithoutStudentInput
    studentImage?: StudentImageCreateNestedManyWithoutStudentInput
    address?: AddressCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAcceptedTypeInput = {
    idStudent?: number
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    sectionId: number
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    registerYearId: number
    studentStatusId: number
    administrativeOrders?: AdministrativeOrderUncheckedCreateNestedManyWithoutStudentInput
    studentSchool?: StudentSchoolUncheckedCreateNestedOneWithoutStudentInput
    studentLevel?: StudentLevelUncheckedCreateNestedManyWithoutStudentInput
    studentGraduation?: StudentGraduationUncheckedCreateNestedOneWithoutStudentInput
    nationalInfo?: NationalInfoUncheckedCreateNestedOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUncheckedCreateNestedManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUncheckedCreateNestedManyWithoutStudentInput
    studentImage?: StudentImageUncheckedCreateNestedManyWithoutStudentInput
    address?: AddressUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAcceptedTypeInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAcceptedTypeInput, StudentUncheckedCreateWithoutAcceptedTypeInput>
  }

  export type StudentCreateManyAcceptedTypeInputEnvelope = {
    data: Enumerable<StudentCreateManyAcceptedTypeInput>
    skipDuplicates?: boolean
  }

  export type StudentUpsertWithWhereUniqueWithoutAcceptedTypeInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutAcceptedTypeInput, StudentUncheckedUpdateWithoutAcceptedTypeInput>
    create: XOR<StudentCreateWithoutAcceptedTypeInput, StudentUncheckedCreateWithoutAcceptedTypeInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutAcceptedTypeInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutAcceptedTypeInput, StudentUncheckedUpdateWithoutAcceptedTypeInput>
  }

  export type StudentUpdateManyWithWhereWithoutAcceptedTypeInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutStudentsInput>
  }

  export type StudentCreateWithoutStudentImageInput = {
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    section: SectionCreateNestedOneWithoutStudentsInput
    yearStudy: YearStudyCreateNestedOneWithoutStudentInput
    studentStatus: StudentStatusCreateNestedOneWithoutStudentsInput
    acceptedType: AcceptedTypeCreateNestedOneWithoutStudentsInput
    administrativeOrders?: AdministrativeOrderCreateNestedManyWithoutStudentInput
    studentSchool?: StudentSchoolCreateNestedOneWithoutStudentInput
    studentLevel?: StudentLevelCreateNestedManyWithoutStudentInput
    studentGraduation?: StudentGraduationCreateNestedOneWithoutStudentInput
    nationalInfo?: NationalInfoCreateNestedOneWithoutStudentInput
    studentResponsables?: StudentResponsibleCreateNestedManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateCreateNestedManyWithoutStudentInput
    address?: AddressCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentImageInput = {
    idStudent?: number
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    sectionId: number
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    registerYearId: number
    studentStatusId: number
    acceptedTypeId: number
    administrativeOrders?: AdministrativeOrderUncheckedCreateNestedManyWithoutStudentInput
    studentSchool?: StudentSchoolUncheckedCreateNestedOneWithoutStudentInput
    studentLevel?: StudentLevelUncheckedCreateNestedManyWithoutStudentInput
    studentGraduation?: StudentGraduationUncheckedCreateNestedOneWithoutStudentInput
    nationalInfo?: NationalInfoUncheckedCreateNestedOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUncheckedCreateNestedManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUncheckedCreateNestedManyWithoutStudentInput
    address?: AddressUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentImageInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentImageInput, StudentUncheckedCreateWithoutStudentImageInput>
  }

  export type StudentUpsertWithoutStudentImageInput = {
    update: XOR<StudentUpdateWithoutStudentImageInput, StudentUncheckedUpdateWithoutStudentImageInput>
    create: XOR<StudentCreateWithoutStudentImageInput, StudentUncheckedCreateWithoutStudentImageInput>
  }

  export type StudentUpdateWithoutStudentImageInput = {
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    section?: SectionUpdateOneRequiredWithoutStudentsInput
    yearStudy?: YearStudyUpdateOneRequiredWithoutStudentInput
    studentStatus?: StudentStatusUpdateOneRequiredWithoutStudentsInput
    acceptedType?: AcceptedTypeUpdateOneRequiredWithoutStudentsInput
    administrativeOrders?: AdministrativeOrderUpdateManyWithoutStudentInput
    studentSchool?: StudentSchoolUpdateOneWithoutStudentInput
    studentLevel?: StudentLevelUpdateManyWithoutStudentInput
    studentGraduation?: StudentGraduationUpdateOneWithoutStudentInput
    nationalInfo?: NationalInfoUpdateOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUpdateManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUpdateManyWithoutStudentInput
    address?: AddressUpdateOneWithoutStudentInput
  }

  export type StudentUncheckedUpdateWithoutStudentImageInput = {
    idStudent?: IntFieldUpdateOperationsInput | number
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    sectionId?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    registerYearId?: IntFieldUpdateOperationsInput | number
    studentStatusId?: IntFieldUpdateOperationsInput | number
    acceptedTypeId?: IntFieldUpdateOperationsInput | number
    administrativeOrders?: AdministrativeOrderUncheckedUpdateManyWithoutStudentInput
    studentSchool?: StudentSchoolUncheckedUpdateOneWithoutStudentInput
    studentLevel?: StudentLevelUncheckedUpdateManyWithoutStudentInput
    studentGraduation?: StudentGraduationUncheckedUpdateOneWithoutStudentInput
    nationalInfo?: NationalInfoUncheckedUpdateOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUncheckedUpdateManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUncheckedUpdateManyWithoutStudentInput
    address?: AddressUncheckedUpdateOneWithoutStudentInput
  }

  export type AddressCreateWithoutProvinceInput = {
    district: string
    avenue: string
    houseNumber: string
    streetNumber: string
    student: StudentCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutProvinceInput = {
    idAddress?: number
    district: string
    avenue: string
    houseNumber: string
    streetNumber: string
    studentId: number
  }

  export type AddressCreateOrConnectWithoutProvinceInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutProvinceInput, AddressUncheckedCreateWithoutProvinceInput>
  }

  export type AddressCreateManyProvinceInputEnvelope = {
    data: Enumerable<AddressCreateManyProvinceInput>
    skipDuplicates?: boolean
  }

  export type AddressUpsertWithWhereUniqueWithoutProvinceInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutProvinceInput, AddressUncheckedUpdateWithoutProvinceInput>
    create: XOR<AddressCreateWithoutProvinceInput, AddressUncheckedCreateWithoutProvinceInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutProvinceInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutProvinceInput, AddressUncheckedUpdateWithoutProvinceInput>
  }

  export type AddressUpdateManyWithWhereWithoutProvinceInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutAddressesInput>
  }

  export type AddressScalarWhereInput = {
    AND?: Enumerable<AddressScalarWhereInput>
    OR?: Enumerable<AddressScalarWhereInput>
    NOT?: Enumerable<AddressScalarWhereInput>
    idAddress?: IntFilter | number
    provinceId?: IntFilter | number
    district?: StringFilter | string
    avenue?: StringFilter | string
    houseNumber?: StringFilter | string
    streetNumber?: StringFilter | string
    studentId?: IntFilter | number
  }

  export type ProvinceCreateWithoutAddressesInput = {
    provinceName: string
    provinceNameEn: string
  }

  export type ProvinceUncheckedCreateWithoutAddressesInput = {
    idProvince?: number
    provinceName: string
    provinceNameEn: string
  }

  export type ProvinceCreateOrConnectWithoutAddressesInput = {
    where: ProvinceWhereUniqueInput
    create: XOR<ProvinceCreateWithoutAddressesInput, ProvinceUncheckedCreateWithoutAddressesInput>
  }

  export type StudentCreateWithoutAddressInput = {
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    section: SectionCreateNestedOneWithoutStudentsInput
    yearStudy: YearStudyCreateNestedOneWithoutStudentInput
    studentStatus: StudentStatusCreateNestedOneWithoutStudentsInput
    acceptedType: AcceptedTypeCreateNestedOneWithoutStudentsInput
    administrativeOrders?: AdministrativeOrderCreateNestedManyWithoutStudentInput
    studentSchool?: StudentSchoolCreateNestedOneWithoutStudentInput
    studentLevel?: StudentLevelCreateNestedManyWithoutStudentInput
    studentGraduation?: StudentGraduationCreateNestedOneWithoutStudentInput
    nationalInfo?: NationalInfoCreateNestedOneWithoutStudentInput
    studentResponsables?: StudentResponsibleCreateNestedManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateCreateNestedManyWithoutStudentInput
    studentImage?: StudentImageCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAddressInput = {
    idStudent?: number
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    sectionId: number
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    registerYearId: number
    studentStatusId: number
    acceptedTypeId: number
    administrativeOrders?: AdministrativeOrderUncheckedCreateNestedManyWithoutStudentInput
    studentSchool?: StudentSchoolUncheckedCreateNestedOneWithoutStudentInput
    studentLevel?: StudentLevelUncheckedCreateNestedManyWithoutStudentInput
    studentGraduation?: StudentGraduationUncheckedCreateNestedOneWithoutStudentInput
    nationalInfo?: NationalInfoUncheckedCreateNestedOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUncheckedCreateNestedManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUncheckedCreateNestedManyWithoutStudentInput
    studentImage?: StudentImageUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAddressInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAddressInput, StudentUncheckedCreateWithoutAddressInput>
  }

  export type ProvinceUpsertWithoutAddressesInput = {
    update: XOR<ProvinceUpdateWithoutAddressesInput, ProvinceUncheckedUpdateWithoutAddressesInput>
    create: XOR<ProvinceCreateWithoutAddressesInput, ProvinceUncheckedCreateWithoutAddressesInput>
  }

  export type ProvinceUpdateWithoutAddressesInput = {
    provinceName?: StringFieldUpdateOperationsInput | string
    provinceNameEn?: StringFieldUpdateOperationsInput | string
  }

  export type ProvinceUncheckedUpdateWithoutAddressesInput = {
    idProvince?: IntFieldUpdateOperationsInput | number
    provinceName?: StringFieldUpdateOperationsInput | string
    provinceNameEn?: StringFieldUpdateOperationsInput | string
  }

  export type StudentUpsertWithoutAddressInput = {
    update: XOR<StudentUpdateWithoutAddressInput, StudentUncheckedUpdateWithoutAddressInput>
    create: XOR<StudentCreateWithoutAddressInput, StudentUncheckedCreateWithoutAddressInput>
  }

  export type StudentUpdateWithoutAddressInput = {
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    section?: SectionUpdateOneRequiredWithoutStudentsInput
    yearStudy?: YearStudyUpdateOneRequiredWithoutStudentInput
    studentStatus?: StudentStatusUpdateOneRequiredWithoutStudentsInput
    acceptedType?: AcceptedTypeUpdateOneRequiredWithoutStudentsInput
    administrativeOrders?: AdministrativeOrderUpdateManyWithoutStudentInput
    studentSchool?: StudentSchoolUpdateOneWithoutStudentInput
    studentLevel?: StudentLevelUpdateManyWithoutStudentInput
    studentGraduation?: StudentGraduationUpdateOneWithoutStudentInput
    nationalInfo?: NationalInfoUpdateOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUpdateManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUpdateManyWithoutStudentInput
    studentImage?: StudentImageUpdateManyWithoutStudentInput
  }

  export type StudentUncheckedUpdateWithoutAddressInput = {
    idStudent?: IntFieldUpdateOperationsInput | number
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    sectionId?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    registerYearId?: IntFieldUpdateOperationsInput | number
    studentStatusId?: IntFieldUpdateOperationsInput | number
    acceptedTypeId?: IntFieldUpdateOperationsInput | number
    administrativeOrders?: AdministrativeOrderUncheckedUpdateManyWithoutStudentInput
    studentSchool?: StudentSchoolUncheckedUpdateOneWithoutStudentInput
    studentLevel?: StudentLevelUncheckedUpdateManyWithoutStudentInput
    studentGraduation?: StudentGraduationUncheckedUpdateOneWithoutStudentInput
    nationalInfo?: NationalInfoUncheckedUpdateOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUncheckedUpdateManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUncheckedUpdateManyWithoutStudentInput
    studentImage?: StudentImageUncheckedUpdateManyWithoutStudentInput
  }

  export type AdministrativeOrderCreateManyOrderTitleInput = {
    idAdministrative?: number
    orderNumber: number
    orderDescription: string
    orderYear: string
    orderLevel: number
    studentId: number
    orderDate: Date | string
    createdBy: number
    createdAt?: Date | string
  }

  export type AdministrativeOrderUpdateWithoutOrderTitleInput = {
    orderNumber?: IntFieldUpdateOperationsInput | number
    orderDescription?: StringFieldUpdateOperationsInput | string
    orderYear?: StringFieldUpdateOperationsInput | string
    orderLevel?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutAdministrativeOrdersInput
    user?: UserUpdateOneRequiredWithoutAdministrativeOrdersInput
  }

  export type AdministrativeOrderUncheckedUpdateWithoutOrderTitleInput = {
    idAdministrative?: IntFieldUpdateOperationsInput | number
    orderNumber?: IntFieldUpdateOperationsInput | number
    orderDescription?: StringFieldUpdateOperationsInput | string
    orderYear?: StringFieldUpdateOperationsInput | string
    orderLevel?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdministrativeOrderUncheckedUpdateManyWithoutAdministrativeOrdersInput = {
    idAdministrative?: IntFieldUpdateOperationsInput | number
    orderNumber?: IntFieldUpdateOperationsInput | number
    orderDescription?: StringFieldUpdateOperationsInput | string
    orderYear?: StringFieldUpdateOperationsInput | string
    orderLevel?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PassTypeCreateManyUserInput = {
    idPassType?: number
    passName: string
    createdAt?: Date | string
  }

  export type AdministrativeOrderCreateManyUserInput = {
    idAdministrative?: number
    orderTitleId: number
    orderNumber: number
    orderDescription: string
    orderYear: string
    orderLevel: number
    studentId: number
    orderDate: Date | string
    createdAt?: Date | string
  }

  export type OrderTitleCreateManyUserInput = {
    idOrderTitle?: number
    title: string
    createdAt?: Date | string
  }

  export type ExitCausesCreateManyUserInput = {
    idExitCauses?: number
    exitCausesTitle: string
    createdAt?: Date | string
  }

  export type PassTypeUpdateWithoutUserInput = {
    passName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PassTypeUncheckedUpdateWithoutUserInput = {
    idPassType?: IntFieldUpdateOperationsInput | number
    passName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PassTypeUncheckedUpdateManyWithoutPassTypesInput = {
    idPassType?: IntFieldUpdateOperationsInput | number
    passName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdministrativeOrderUpdateWithoutUserInput = {
    orderNumber?: IntFieldUpdateOperationsInput | number
    orderDescription?: StringFieldUpdateOperationsInput | string
    orderYear?: StringFieldUpdateOperationsInput | string
    orderLevel?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderTitle?: OrderTitleUpdateOneRequiredWithoutAdministrativeOrdersInput
    student?: StudentUpdateOneRequiredWithoutAdministrativeOrdersInput
  }

  export type AdministrativeOrderUncheckedUpdateWithoutUserInput = {
    idAdministrative?: IntFieldUpdateOperationsInput | number
    orderTitleId?: IntFieldUpdateOperationsInput | number
    orderNumber?: IntFieldUpdateOperationsInput | number
    orderDescription?: StringFieldUpdateOperationsInput | string
    orderYear?: StringFieldUpdateOperationsInput | string
    orderLevel?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderTitleUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    administrativeOrders?: AdministrativeOrderUpdateManyWithoutOrderTitleInput
  }

  export type OrderTitleUncheckedUpdateWithoutUserInput = {
    idOrderTitle?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    administrativeOrders?: AdministrativeOrderUncheckedUpdateManyWithoutOrderTitleInput
  }

  export type OrderTitleUncheckedUpdateManyWithoutOrderTitlesInput = {
    idOrderTitle?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExitCausesUpdateWithoutUserInput = {
    exitCausesTitle?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExitCausesUncheckedUpdateWithoutUserInput = {
    idExitCauses?: IntFieldUpdateOperationsInput | number
    exitCausesTitle?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExitCausesUncheckedUpdateManyWithoutExitCausesInput = {
    idExitCauses?: IntFieldUpdateOperationsInput | number
    exitCausesTitle?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyRoleInput = {
    idUser?: number
    userName: string
    password: string
    sectionId: number
    createdAt?: Date | string
  }

  export type UserUpdateWithoutRoleInput = {
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: SectionUpdateOneRequiredWithoutUserInput
    passTypes?: PassTypeUpdateManyWithoutUserInput
    administrativeOrders?: AdministrativeOrderUpdateManyWithoutUserInput
    OrderTitles?: OrderTitleUpdateManyWithoutUserInput
    ExitCauses?: ExitCausesUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    idUser?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sectionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passTypes?: PassTypeUncheckedUpdateManyWithoutUserInput
    administrativeOrders?: AdministrativeOrderUncheckedUpdateManyWithoutUserInput
    OrderTitles?: OrderTitleUncheckedUpdateManyWithoutUserInput
    ExitCauses?: ExitCausesUncheckedUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateManyWithoutUsersInput = {
    idUser?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    sectionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateManySectionInput = {
    idStudent?: number
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    registerYearId: number
    studentStatusId: number
    acceptedTypeId: number
  }

  export type UserCreateManySectionInput = {
    idUser?: number
    userName: string
    password: string
    roleId: number
    createdAt?: Date | string
  }

  export type StudentUpdateWithoutSectionInput = {
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    yearStudy?: YearStudyUpdateOneRequiredWithoutStudentInput
    studentStatus?: StudentStatusUpdateOneRequiredWithoutStudentsInput
    acceptedType?: AcceptedTypeUpdateOneRequiredWithoutStudentsInput
    administrativeOrders?: AdministrativeOrderUpdateManyWithoutStudentInput
    studentSchool?: StudentSchoolUpdateOneWithoutStudentInput
    studentLevel?: StudentLevelUpdateManyWithoutStudentInput
    studentGraduation?: StudentGraduationUpdateOneWithoutStudentInput
    nationalInfo?: NationalInfoUpdateOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUpdateManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUpdateManyWithoutStudentInput
    studentImage?: StudentImageUpdateManyWithoutStudentInput
    address?: AddressUpdateOneWithoutStudentInput
  }

  export type StudentUncheckedUpdateWithoutSectionInput = {
    idStudent?: IntFieldUpdateOperationsInput | number
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    registerYearId?: IntFieldUpdateOperationsInput | number
    studentStatusId?: IntFieldUpdateOperationsInput | number
    acceptedTypeId?: IntFieldUpdateOperationsInput | number
    administrativeOrders?: AdministrativeOrderUncheckedUpdateManyWithoutStudentInput
    studentSchool?: StudentSchoolUncheckedUpdateOneWithoutStudentInput
    studentLevel?: StudentLevelUncheckedUpdateManyWithoutStudentInput
    studentGraduation?: StudentGraduationUncheckedUpdateOneWithoutStudentInput
    nationalInfo?: NationalInfoUncheckedUpdateOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUncheckedUpdateManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUncheckedUpdateManyWithoutStudentInput
    studentImage?: StudentImageUncheckedUpdateManyWithoutStudentInput
    address?: AddressUncheckedUpdateOneWithoutStudentInput
  }

  export type StudentUncheckedUpdateManyWithoutStudentsInput = {
    idStudent?: IntFieldUpdateOperationsInput | number
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    registerYearId?: IntFieldUpdateOperationsInput | number
    studentStatusId?: IntFieldUpdateOperationsInput | number
    acceptedTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpdateWithoutSectionInput = {
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersInput
    passTypes?: PassTypeUpdateManyWithoutUserInput
    administrativeOrders?: AdministrativeOrderUpdateManyWithoutUserInput
    OrderTitles?: OrderTitleUpdateManyWithoutUserInput
    ExitCauses?: ExitCausesUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutSectionInput = {
    idUser?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passTypes?: PassTypeUncheckedUpdateManyWithoutUserInput
    administrativeOrders?: AdministrativeOrderUncheckedUpdateManyWithoutUserInput
    OrderTitles?: OrderTitleUncheckedUpdateManyWithoutUserInput
    ExitCauses?: ExitCausesUncheckedUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateManyWithoutUserInput = {
    idUser?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdministrativeOrderCreateManyStudentInput = {
    idAdministrative?: number
    orderTitleId: number
    orderNumber: number
    orderDescription: string
    orderYear: string
    orderLevel: number
    orderDate: Date | string
    createdBy: number
    createdAt?: Date | string
  }

  export type StudentLevelCreateManyStudentInput = {
    idStudentLevel?: number
    level: number
    class: string
    yearStudyId: number
  }

  export type StudentResponsibleCreateManyStudentInput = {
    idStudentResponsible?: number
    responsibleName: string
    responsiblePhone: string
  }

  export type NationalityCertificateCreateManyStudentInput = {
    idNationalityCertificate?: number
    nationalityNumber: string
    nationalityIssue: string
    nationalityPlace: string
  }

  export type StudentImageCreateManyStudentInput = {
    idStudentImage?: number
    imagePath: string
  }

  export type AdministrativeOrderUpdateWithoutStudentInput = {
    orderNumber?: IntFieldUpdateOperationsInput | number
    orderDescription?: StringFieldUpdateOperationsInput | string
    orderYear?: StringFieldUpdateOperationsInput | string
    orderLevel?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderTitle?: OrderTitleUpdateOneRequiredWithoutAdministrativeOrdersInput
    user?: UserUpdateOneRequiredWithoutAdministrativeOrdersInput
  }

  export type AdministrativeOrderUncheckedUpdateWithoutStudentInput = {
    idAdministrative?: IntFieldUpdateOperationsInput | number
    orderTitleId?: IntFieldUpdateOperationsInput | number
    orderNumber?: IntFieldUpdateOperationsInput | number
    orderDescription?: StringFieldUpdateOperationsInput | string
    orderYear?: StringFieldUpdateOperationsInput | string
    orderLevel?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentLevelUpdateWithoutStudentInput = {
    level?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    yearStudy?: YearStudyUpdateOneRequiredWithoutStudentLevelInput
  }

  export type StudentLevelUncheckedUpdateWithoutStudentInput = {
    idStudentLevel?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    yearStudyId?: IntFieldUpdateOperationsInput | number
  }

  export type StudentLevelUncheckedUpdateManyWithoutStudentLevelInput = {
    idStudentLevel?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    yearStudyId?: IntFieldUpdateOperationsInput | number
  }

  export type StudentResponsibleUpdateWithoutStudentInput = {
    responsibleName?: StringFieldUpdateOperationsInput | string
    responsiblePhone?: StringFieldUpdateOperationsInput | string
  }

  export type StudentResponsibleUncheckedUpdateWithoutStudentInput = {
    idStudentResponsible?: IntFieldUpdateOperationsInput | number
    responsibleName?: StringFieldUpdateOperationsInput | string
    responsiblePhone?: StringFieldUpdateOperationsInput | string
  }

  export type StudentResponsibleUncheckedUpdateManyWithoutStudentResponsablesInput = {
    idStudentResponsible?: IntFieldUpdateOperationsInput | number
    responsibleName?: StringFieldUpdateOperationsInput | string
    responsiblePhone?: StringFieldUpdateOperationsInput | string
  }

  export type NationalityCertificateUpdateWithoutStudentInput = {
    nationalityNumber?: StringFieldUpdateOperationsInput | string
    nationalityIssue?: StringFieldUpdateOperationsInput | string
    nationalityPlace?: StringFieldUpdateOperationsInput | string
  }

  export type NationalityCertificateUncheckedUpdateWithoutStudentInput = {
    idNationalityCertificate?: IntFieldUpdateOperationsInput | number
    nationalityNumber?: StringFieldUpdateOperationsInput | string
    nationalityIssue?: StringFieldUpdateOperationsInput | string
    nationalityPlace?: StringFieldUpdateOperationsInput | string
  }

  export type NationalityCertificateUncheckedUpdateManyWithoutNationalityCertificateInput = {
    idNationalityCertificate?: IntFieldUpdateOperationsInput | number
    nationalityNumber?: StringFieldUpdateOperationsInput | string
    nationalityIssue?: StringFieldUpdateOperationsInput | string
    nationalityPlace?: StringFieldUpdateOperationsInput | string
  }

  export type StudentImageUpdateWithoutStudentInput = {
    imagePath?: StringFieldUpdateOperationsInput | string
  }

  export type StudentImageUncheckedUpdateWithoutStudentInput = {
    idStudentImage?: IntFieldUpdateOperationsInput | number
    imagePath?: StringFieldUpdateOperationsInput | string
  }

  export type StudentImageUncheckedUpdateManyWithoutStudentImageInput = {
    idStudentImage?: IntFieldUpdateOperationsInput | number
    imagePath?: StringFieldUpdateOperationsInput | string
  }

  export type StudentLevelCreateManyYearStudyInput = {
    idStudentLevel?: number
    level: number
    class: string
    studentId: number
  }

  export type StudentCreateManyYearStudyInput = {
    idStudent?: number
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    sectionId: number
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    studentStatusId: number
    acceptedTypeId: number
  }

  export type StudentLevelUpdateWithoutYearStudyInput = {
    level?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutStudentLevelInput
  }

  export type StudentLevelUncheckedUpdateWithoutYearStudyInput = {
    idStudentLevel?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    studentId?: IntFieldUpdateOperationsInput | number
  }

  export type StudentUpdateWithoutYearStudyInput = {
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    section?: SectionUpdateOneRequiredWithoutStudentsInput
    studentStatus?: StudentStatusUpdateOneRequiredWithoutStudentsInput
    acceptedType?: AcceptedTypeUpdateOneRequiredWithoutStudentsInput
    administrativeOrders?: AdministrativeOrderUpdateManyWithoutStudentInput
    studentSchool?: StudentSchoolUpdateOneWithoutStudentInput
    studentLevel?: StudentLevelUpdateManyWithoutStudentInput
    studentGraduation?: StudentGraduationUpdateOneWithoutStudentInput
    nationalInfo?: NationalInfoUpdateOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUpdateManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUpdateManyWithoutStudentInput
    studentImage?: StudentImageUpdateManyWithoutStudentInput
    address?: AddressUpdateOneWithoutStudentInput
  }

  export type StudentUncheckedUpdateWithoutYearStudyInput = {
    idStudent?: IntFieldUpdateOperationsInput | number
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    sectionId?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    studentStatusId?: IntFieldUpdateOperationsInput | number
    acceptedTypeId?: IntFieldUpdateOperationsInput | number
    administrativeOrders?: AdministrativeOrderUncheckedUpdateManyWithoutStudentInput
    studentSchool?: StudentSchoolUncheckedUpdateOneWithoutStudentInput
    studentLevel?: StudentLevelUncheckedUpdateManyWithoutStudentInput
    studentGraduation?: StudentGraduationUncheckedUpdateOneWithoutStudentInput
    nationalInfo?: NationalInfoUncheckedUpdateOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUncheckedUpdateManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUncheckedUpdateManyWithoutStudentInput
    studentImage?: StudentImageUncheckedUpdateManyWithoutStudentInput
    address?: AddressUncheckedUpdateOneWithoutStudentInput
  }

  export type StudentUncheckedUpdateManyWithoutStudentInput = {
    idStudent?: IntFieldUpdateOperationsInput | number
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    sectionId?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    studentStatusId?: IntFieldUpdateOperationsInput | number
    acceptedTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type StudySubCategoryCreateManyStudyCategoryInput = {
    idStudySubCategory?: number
    subCategoryName: string
  }

  export type StudySubCategoryUpdateWithoutStudyCategoryInput = {
    subCategoryName?: StringFieldUpdateOperationsInput | string
    StudentSchool?: StudentSchoolUpdateManyWithoutStudySubCategoryInput
  }

  export type StudySubCategoryUncheckedUpdateWithoutStudyCategoryInput = {
    idStudySubCategory?: IntFieldUpdateOperationsInput | number
    subCategoryName?: StringFieldUpdateOperationsInput | string
    StudentSchool?: StudentSchoolUncheckedUpdateManyWithoutStudySubCategoryInput
  }

  export type StudySubCategoryUncheckedUpdateManyWithoutStudySubCategoryInput = {
    idStudySubCategory?: IntFieldUpdateOperationsInput | number
    subCategoryName?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSchoolCreateManyStudySubCategoryInput = {
    idStudentSchool?: number
    schoolName: string
    graduationDate: string
    documentDate: string
    totalMarks: number
    average: number
    documentNumber: number
    lessonCount: number
    Directorate: string
    studentId: number
    certificateStatusId: number
    certificateStatusDescription: string
    createdAt?: Date | string
  }

  export type StudentSchoolUpdateWithoutStudySubCategoryInput = {
    schoolName?: StringFieldUpdateOperationsInput | string
    graduationDate?: StringFieldUpdateOperationsInput | string
    documentDate?: StringFieldUpdateOperationsInput | string
    totalMarks?: IntFieldUpdateOperationsInput | number
    average?: FloatFieldUpdateOperationsInput | number
    documentNumber?: IntFieldUpdateOperationsInput | number
    lessonCount?: IntFieldUpdateOperationsInput | number
    Directorate?: StringFieldUpdateOperationsInput | string
    certificateStatusDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentSchoolInput
    certificateStatus?: CertificateStatusUpdateOneRequiredWithoutStudentSchoolInput
  }

  export type StudentSchoolUncheckedUpdateWithoutStudySubCategoryInput = {
    idStudentSchool?: IntFieldUpdateOperationsInput | number
    schoolName?: StringFieldUpdateOperationsInput | string
    graduationDate?: StringFieldUpdateOperationsInput | string
    documentDate?: StringFieldUpdateOperationsInput | string
    totalMarks?: IntFieldUpdateOperationsInput | number
    average?: FloatFieldUpdateOperationsInput | number
    documentNumber?: IntFieldUpdateOperationsInput | number
    lessonCount?: IntFieldUpdateOperationsInput | number
    Directorate?: StringFieldUpdateOperationsInput | string
    studentId?: IntFieldUpdateOperationsInput | number
    certificateStatusId?: IntFieldUpdateOperationsInput | number
    certificateStatusDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSchoolUncheckedUpdateManyWithoutStudentSchoolInput = {
    idStudentSchool?: IntFieldUpdateOperationsInput | number
    schoolName?: StringFieldUpdateOperationsInput | string
    graduationDate?: StringFieldUpdateOperationsInput | string
    documentDate?: StringFieldUpdateOperationsInput | string
    totalMarks?: IntFieldUpdateOperationsInput | number
    average?: FloatFieldUpdateOperationsInput | number
    documentNumber?: IntFieldUpdateOperationsInput | number
    lessonCount?: IntFieldUpdateOperationsInput | number
    Directorate?: StringFieldUpdateOperationsInput | string
    studentId?: IntFieldUpdateOperationsInput | number
    certificateStatusId?: IntFieldUpdateOperationsInput | number
    certificateStatusDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSchoolCreateManyCertificateStatusInput = {
    idStudentSchool?: number
    schoolName: string
    graduationDate: string
    documentDate: string
    totalMarks: number
    average: number
    documentNumber: number
    lessonCount: number
    Directorate: string
    studySubCategoryId: number
    studentId: number
    certificateStatusDescription: string
    createdAt?: Date | string
  }

  export type StudentSchoolUpdateWithoutCertificateStatusInput = {
    schoolName?: StringFieldUpdateOperationsInput | string
    graduationDate?: StringFieldUpdateOperationsInput | string
    documentDate?: StringFieldUpdateOperationsInput | string
    totalMarks?: IntFieldUpdateOperationsInput | number
    average?: FloatFieldUpdateOperationsInput | number
    documentNumber?: IntFieldUpdateOperationsInput | number
    lessonCount?: IntFieldUpdateOperationsInput | number
    Directorate?: StringFieldUpdateOperationsInput | string
    certificateStatusDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studySubCategory?: StudySubCategoryUpdateOneRequiredWithoutStudentSchoolInput
    student?: StudentUpdateOneRequiredWithoutStudentSchoolInput
  }

  export type StudentSchoolUncheckedUpdateWithoutCertificateStatusInput = {
    idStudentSchool?: IntFieldUpdateOperationsInput | number
    schoolName?: StringFieldUpdateOperationsInput | string
    graduationDate?: StringFieldUpdateOperationsInput | string
    documentDate?: StringFieldUpdateOperationsInput | string
    totalMarks?: IntFieldUpdateOperationsInput | number
    average?: FloatFieldUpdateOperationsInput | number
    documentNumber?: IntFieldUpdateOperationsInput | number
    lessonCount?: IntFieldUpdateOperationsInput | number
    Directorate?: StringFieldUpdateOperationsInput | string
    studySubCategoryId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    certificateStatusDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateManyStudentStatusInput = {
    idStudent?: number
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    sectionId: number
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    registerYearId: number
    acceptedTypeId: number
  }

  export type StudentUpdateWithoutStudentStatusInput = {
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    section?: SectionUpdateOneRequiredWithoutStudentsInput
    yearStudy?: YearStudyUpdateOneRequiredWithoutStudentInput
    acceptedType?: AcceptedTypeUpdateOneRequiredWithoutStudentsInput
    administrativeOrders?: AdministrativeOrderUpdateManyWithoutStudentInput
    studentSchool?: StudentSchoolUpdateOneWithoutStudentInput
    studentLevel?: StudentLevelUpdateManyWithoutStudentInput
    studentGraduation?: StudentGraduationUpdateOneWithoutStudentInput
    nationalInfo?: NationalInfoUpdateOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUpdateManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUpdateManyWithoutStudentInput
    studentImage?: StudentImageUpdateManyWithoutStudentInput
    address?: AddressUpdateOneWithoutStudentInput
  }

  export type StudentUncheckedUpdateWithoutStudentStatusInput = {
    idStudent?: IntFieldUpdateOperationsInput | number
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    sectionId?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    registerYearId?: IntFieldUpdateOperationsInput | number
    acceptedTypeId?: IntFieldUpdateOperationsInput | number
    administrativeOrders?: AdministrativeOrderUncheckedUpdateManyWithoutStudentInput
    studentSchool?: StudentSchoolUncheckedUpdateOneWithoutStudentInput
    studentLevel?: StudentLevelUncheckedUpdateManyWithoutStudentInput
    studentGraduation?: StudentGraduationUncheckedUpdateOneWithoutStudentInput
    nationalInfo?: NationalInfoUncheckedUpdateOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUncheckedUpdateManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUncheckedUpdateManyWithoutStudentInput
    studentImage?: StudentImageUncheckedUpdateManyWithoutStudentInput
    address?: AddressUncheckedUpdateOneWithoutStudentInput
  }

  export type StudentCreateManyAcceptedTypeInput = {
    idStudent?: number
    studentName: string
    englishName: string
    mail: string
    password: string
    dob: string
    sectionId: number
    nationality: string
    phone: string
    gender: boolean
    studyType: boolean
    relationships: boolean
    note: string
    religion: string
    motherName: string
    collegeNumber: string
    registerYearId: number
    studentStatusId: number
  }

  export type StudentUpdateWithoutAcceptedTypeInput = {
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    section?: SectionUpdateOneRequiredWithoutStudentsInput
    yearStudy?: YearStudyUpdateOneRequiredWithoutStudentInput
    studentStatus?: StudentStatusUpdateOneRequiredWithoutStudentsInput
    administrativeOrders?: AdministrativeOrderUpdateManyWithoutStudentInput
    studentSchool?: StudentSchoolUpdateOneWithoutStudentInput
    studentLevel?: StudentLevelUpdateManyWithoutStudentInput
    studentGraduation?: StudentGraduationUpdateOneWithoutStudentInput
    nationalInfo?: NationalInfoUpdateOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUpdateManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUpdateManyWithoutStudentInput
    studentImage?: StudentImageUpdateManyWithoutStudentInput
    address?: AddressUpdateOneWithoutStudentInput
  }

  export type StudentUncheckedUpdateWithoutAcceptedTypeInput = {
    idStudent?: IntFieldUpdateOperationsInput | number
    studentName?: StringFieldUpdateOperationsInput | string
    englishName?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    dob?: StringFieldUpdateOperationsInput | string
    sectionId?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    gender?: BoolFieldUpdateOperationsInput | boolean
    studyType?: BoolFieldUpdateOperationsInput | boolean
    relationships?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    collegeNumber?: StringFieldUpdateOperationsInput | string
    registerYearId?: IntFieldUpdateOperationsInput | number
    studentStatusId?: IntFieldUpdateOperationsInput | number
    administrativeOrders?: AdministrativeOrderUncheckedUpdateManyWithoutStudentInput
    studentSchool?: StudentSchoolUncheckedUpdateOneWithoutStudentInput
    studentLevel?: StudentLevelUncheckedUpdateManyWithoutStudentInput
    studentGraduation?: StudentGraduationUncheckedUpdateOneWithoutStudentInput
    nationalInfo?: NationalInfoUncheckedUpdateOneWithoutStudentInput
    studentResponsables?: StudentResponsibleUncheckedUpdateManyWithoutStudentInput
    nationalityCertificate?: NationalityCertificateUncheckedUpdateManyWithoutStudentInput
    studentImage?: StudentImageUncheckedUpdateManyWithoutStudentInput
    address?: AddressUncheckedUpdateOneWithoutStudentInput
  }

  export type AddressCreateManyProvinceInput = {
    idAddress?: number
    district: string
    avenue: string
    houseNumber: string
    streetNumber: string
    studentId: number
  }

  export type AddressUpdateWithoutProvinceInput = {
    district?: StringFieldUpdateOperationsInput | string
    avenue?: StringFieldUpdateOperationsInput | string
    houseNumber?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutAddressInput
  }

  export type AddressUncheckedUpdateWithoutProvinceInput = {
    idAddress?: IntFieldUpdateOperationsInput | number
    district?: StringFieldUpdateOperationsInput | string
    avenue?: StringFieldUpdateOperationsInput | string
    houseNumber?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    studentId?: IntFieldUpdateOperationsInput | number
  }

  export type AddressUncheckedUpdateManyWithoutAddressesInput = {
    idAddress?: IntFieldUpdateOperationsInput | number
    district?: StringFieldUpdateOperationsInput | string
    avenue?: StringFieldUpdateOperationsInput | string
    houseNumber?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    studentId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}